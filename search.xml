<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++字符串分割</title>
    <url>/2021/05/10/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<p>字符串分割方式汇总</p>
<span id="more"></span>

<h2 id="string-find"><a href="#string-find" class="headerlink" title="string.find"></a>string.find</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line">std::string delimiter = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">std::string token;</span><br><span class="line">std::vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">while</span> ((pos = s.<span class="built_in">find</span>(delimiter)) != std::string::npos) &#123;</span><br><span class="line">    token = s.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    v.<span class="built_in">push_back</span>(token);</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">0</span>, pos + delimiter.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line">v.<span class="built_in">push_back</span>(s);</span><br></pre></td></tr></table></figure>

<h2 id="boost-split"><a href="#boost-split" class="headerlink" title="boost::split()"></a>boost::split()</h2><p>注意split在处理多字符分隔符的时候会有一些更奇妙的行为。<br>此外要处理结果中的空字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/algorithm/string.hpp&gt;</span></span></span><br><span class="line">std::string line = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line">boost::<span class="built_in">split</span>(v,line,boost::<span class="built_in">is_any_of</span>(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="strotk"><a href="#strotk" class="headerlink" title="strotk"></a>strotk</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *token = <span class="built_in">strtok</span>(str.<span class="built_in">data</span>(), <span class="string">&quot;,&quot;</span>);</span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line"><span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    token = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(token));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>c++/cpp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>C++异常捕获</title>
    <url>/2021/12/02/C++%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<p>有时我们无法确定一段代码会抛出何种异常，但是又希望能捕获这些异常</p>
<span id="more"></span>

<p>在不能确定异常类型时，首先应该尝试捕获std::exception, 通过what()方法可以得到一个较为详细的报错信息。</p>
<p>但有时，也可能会遇到一些不按套路出牌的代码，这时就需要使用<code>catch(...)</code>来进行捕获，通过<code>__cxa_exception_type</code>可以大致确定报错的类型，之后再修改代码进行进一步的处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// some thing</span></span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> std::exception &amp;e) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* describe = e.<span class="built_in">what</span>();</span><br><span class="line">  <span class="comment">// some print describe</span></span><br><span class="line">&#125; <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">  std::exception_ptr p = std::<span class="built_in">current_exception</span>();</span><br><span class="line">  std::string type_name = (p ? p.__cxa_exception_type()-&gt;<span class="built_in">name</span>() : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="comment">// some print type_name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>c++/cpp</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>C++重写和虚函数对比</title>
    <url>/2021/09/22/C++%E9%87%8D%E5%86%99%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>在子类中，可以声明一个和父类相同的函数，此时父类函数是否标记为virtual将会影响这一行为</p>
<span id="more"></span>

<p>当父类没有标记为virtual时，将子类转换为父类之后，执行的将会是父类方法</p>
<p>当父类标记为virtual时，将子类转换为父类之后，执行的将会是子类方法</p>
<p>核心：</p>
<ul>
<li>只有函数名和参数都相同才算相同的函数</li>
<li>只用在父子类中相同函数，且该函数在父类中标记了virtual，才能通过子类调用</li>
</ul>
<h2 id="指针-Base-basep-amp-sub-和引用-Base-amp-base-sub"><a href="#指针-Base-basep-amp-sub-和引用-Base-amp-base-sub" class="headerlink" title="指针(Base *basep = &amp;sub;)和引用(Base &amp;base = sub;)"></a>指针(Base *basep = &amp;sub;)和引用(Base &amp;base = sub;)</h2><table>
<thead>
<tr>
<th></th>
<th>无virtual</th>
<th>有virtual</th>
</tr>
</thead>
<tbody><tr>
<td>参数相同</td>
<td>子调用子方法<br>父调用父方法</td>
<td>子调用子方法<br><strong>父调用子方法</strong></td>
</tr>
<tr>
<td>参数不同</td>
<td>子调用子方法，无法调用父<br>父调用父方法，无法调用子</td>
<td>子调用子方法，无法调用父<br>父调用父方法，无法调用子</td>
</tr>
</tbody></table>
<h2 id="直接赋值-Base-base-sub"><a href="#直接赋值-Base-base-sub" class="headerlink" title="直接赋值(Base base = sub;)"></a>直接赋值(Base base = sub;)</h2><table>
<thead>
<tr>
<th></th>
<th>无virtual</th>
<th>有virtual</th>
</tr>
</thead>
<tbody><tr>
<td>参数相同</td>
<td>子调用子方法<br>父调用父方法</td>
<td>子调用子方法<br><strong>父调用子方法</strong></td>
</tr>
<tr>
<td>参数不同</td>
<td>子调用子方法，无法调用父<br>父调用父方法，无法调用子</td>
<td>子调用子方法，无法调用父<br>父调用父方法，无法调用子</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vexecute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base virtual execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hexecute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base hide execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vhexecute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base hide execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Sub execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vexecute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Sub virtual execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hexecute</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Sub hide execute &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">vhexecute</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Sub hide execute &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    Sub sub;</span><br><span class="line">    Base base = sub;</span><br><span class="line">    sub.<span class="built_in">execute</span>();      <span class="comment">// Sub execute</span></span><br><span class="line">    base.<span class="built_in">execute</span>();     <span class="comment">// Base execute</span></span><br><span class="line">    sub.<span class="built_in">vexecute</span>();     <span class="comment">// Sub virtual execute</span></span><br><span class="line">    base.<span class="built_in">vexecute</span>();    <span class="comment">// Base virtual execute</span></span><br><span class="line">    sub.<span class="built_in">hexecute</span>(<span class="number">0</span>);    <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// sub.hexecute();  no matching function for call to ‘Sub::hexecute()’</span></span><br><span class="line">    base.<span class="built_in">hexecute</span>();    <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// base.hexecute(0); no matching function for call to ‘Base::hexecute(int)’</span></span><br><span class="line">    sub.<span class="built_in">vhexecute</span>(<span class="number">0</span>);    <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// sub.vhexecute();  no matching function for call to ‘Sub::vhexecute()’</span></span><br><span class="line">    base.<span class="built_in">vhexecute</span>();    <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// base.vhexecute(0); no matching function for call to ‘Base::vhexecute(int)’</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">    Sub sub;</span><br><span class="line">    Base &amp;base = sub;</span><br><span class="line">    sub.<span class="built_in">execute</span>();      <span class="comment">// Sub execute</span></span><br><span class="line">    base.<span class="built_in">execute</span>();     <span class="comment">// Base execute</span></span><br><span class="line">    sub.<span class="built_in">vexecute</span>();     <span class="comment">// Sub virtual execute</span></span><br><span class="line">    base.<span class="built_in">vexecute</span>();    <span class="comment">// Sub virtual execute</span></span><br><span class="line">    sub.<span class="built_in">hexecute</span>(<span class="number">0</span>);    <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// sub.hexecute();  no matching function for call to ‘Sub::hexecute()’</span></span><br><span class="line">    base.<span class="built_in">hexecute</span>();    <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// base.hexecute(0); no matching function for call to ‘Base::hexecute(int)’</span></span><br><span class="line">    sub.<span class="built_in">vhexecute</span>(<span class="number">0</span>);    <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// sub.vhexecute();  no matching function for call to ‘Sub::vhexecute()’</span></span><br><span class="line">    base.<span class="built_in">vhexecute</span>();    <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// base.vhexecute(0); no matching function for call to ‘Base::vhexecute(int)’</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">    Sub *subp = <span class="keyword">new</span> <span class="built_in">Sub</span>();</span><br><span class="line">    Base *basep = subp;</span><br><span class="line">    subp-&gt;<span class="built_in">execute</span>();        <span class="comment">// Sub execute</span></span><br><span class="line">    basep-&gt;<span class="built_in">execute</span>();       <span class="comment">// Base execute</span></span><br><span class="line">    subp-&gt;<span class="built_in">vexecute</span>();       <span class="comment">// Sub virtual execute</span></span><br><span class="line">    basep-&gt;<span class="built_in">vexecute</span>();      <span class="comment">// Sub virtual execute</span></span><br><span class="line">    subp-&gt;<span class="built_in">hexecute</span>(<span class="number">0</span>);      <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// subp-&gt;hexecute();    no matching function for call to ‘Sub::hexecute()’</span></span><br><span class="line">    basep-&gt;<span class="built_in">hexecute</span>();      <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// basep-&gt;hexecute(0);  no matching function for call to ‘Base::hexecute(int)’</span></span><br><span class="line">    subp-&gt;<span class="built_in">vhexecute</span>(<span class="number">0</span>);     <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// subp-&gt;vhexecute();   no matching function for call to ‘Sub::vhexecute()’</span></span><br><span class="line">    basep-&gt;<span class="built_in">vhexecute</span>();     <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// basep-&gt;vhexecute(0); no matching function for call to ‘Base::vhexecute(int)’</span></span><br><span class="line">    <span class="keyword">delete</span> subp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>c++/cpp</tag>
        <tag>overwrite</tag>
        <tag>overriding</tag>
        <tag>virtual function</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 输入输出 stdio</title>
    <url>/2021/06/14/Golang%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%20stdio/</url>
    <content><![CDATA[<p>Golang 的标准输入输出常见用法</p>
<span id="more"></span>

<h1 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Scanln 实际上需要知道一行中有多少被空格分隔的输入才能使用，直接读取一行作为字符串需要用到scanner或者reader</span></span><br><span class="line">	<span class="comment">// var str1, str2 string</span></span><br><span class="line">	<span class="comment">// fmt.Scanln(str1, str2) </span></span><br><span class="line">	<span class="comment">// fmt.Println(str1, str2);</span></span><br><span class="line">  <span class="comment">// 方式一：</span></span><br><span class="line">  scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">      fmt.Println(scanner.Text())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 方式二：</span></span><br><span class="line">  reader := bufio.NewReader(os.Stdin)</span><br><span class="line">  text, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  fmt.Println(text)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="空格分割"><a href="#空格分割" class="headerlink" title="空格分割"></a>空格分割</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 方式一：</span></span><br><span class="line">  scanner := bufio.NewScanner(bufio.NewReader(os.Stdin))</span><br><span class="line">  scanner.Split(bufio.ScanWords)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">      fmt.Println(scanner.Text())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">100.12</span></span><br><span class="line">  <span class="comment">// 保留一位小数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.1f\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>stdio</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 调用 Linux Netlink 管理路由表</title>
    <url>/2020/07/07/Golang-%E8%B0%83%E7%94%A8-Linux-Netlink-%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E8%A1%A8/</url>
    <content><![CDATA[<p>通常我们使用route命令或者ip命令来管理linux路由表(routing table), 但是如何使用linux原生的接口来进行操作呢？</p>
<span id="more"></span>

<h2 id="NetLink"><a href="#NetLink" class="headerlink" title="NetLink"></a>NetLink</h2><p>netlink 是一种与内核交互的方式，首先创建一个netlink类型的socket，之后向这个socket发送指定格式的数据，就可以从该socket拿到内核的返回。<br>linux的route就是通过这种方式来进行管理的。<br>关于netlink的详细信息建议直接<code>man 7 netlink</code>，网上的信息通常都不够直观。下面节选部分文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NETLINK(7) </span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       netlink - communication between kernel and user space (AF_NETLINK)</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;asm&#x2F;types.h&gt;</span><br><span class="line">       #include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">       #include &lt;linux&#x2F;netlink.h&gt;</span><br><span class="line"></span><br><span class="line">       netlink_socket &#x3D; socket(AF_NETLINK, socket_type, netlink_family);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Netlink  is  used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for</span><br><span class="line">       kernel modules.  The internal kernel interface is not documented in this manual page.  There is also an obsolete netlink interface via netlink character devices; this  interface  is  not  docu‐</span><br><span class="line">       mented here and is provided only for backward compatibility.</span><br><span class="line"></span><br><span class="line">       Netlink is a datagram-oriented service.  Both SOCK_RAW and SOCK_DGRAM are valid values for socket_type.  However, the netlink protocol does not distinguish between datagram and raw sockets.</span><br><span class="line"></span><br><span class="line">       netlink_family selects the kernel module or netlink group to communicate with.  The currently assigned netlink families are:</span><br><span class="line"></span><br><span class="line">       NETLINK_ROUTE</span><br><span class="line">              Receives routing and link updates and may be used to modify the routing tables (both IPv4 and IPv6), IP addresses, link parameters, neighbor setups, queueing disciplines, traffic classes</span><br><span class="line">              and packet classifiers (see rtnetlink(7)).</span><br><span class="line"></span><br><span class="line">       NETLINK_W1 (Linux 2.6.13 to 2.16.17)</span><br><span class="line">              Messages from 1-wire subsystem.</span><br><span class="line"></span><br><span class="line">       NETLINK_USERSOCK</span><br><span class="line">              Reserved for user-mode socket protocols.</span><br><span class="line"></span><br><span class="line">       NETLINK_FIREWALL (up to and including Linux 3.4)</span><br><span class="line">              Transport IPv4 packets from netfilter to user space.  Used by ip_queue kernel module.  After a long period of being declared obsolete (in favor of the more advanced nfnetlink_queue  fea‐</span><br><span class="line">              ture), NETLINK_FIREWALL was removed in Linux 3.5.</span><br></pre></td></tr></table></figure>

<h2 id="golang-netlink-接口"><a href="#golang-netlink-接口" class="headerlink" title="golang netlink 接口"></a>golang netlink 接口</h2><h2 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h2><p>goalng的syscall库中包装了部分函数帮助我们通过netlink完成查询工作。方便起见我们使用最为通用的<code>syscall.NetlinkRIB</code>函数，该函数会一次将所有table查询出来，无法指定，但是不需要我们手动设置查询结构体，同时帮我们完成了数据接收工作，使用起来较为方便。<br><code>syscall.NetlinkRIB</code>的返回为[]byte，我们需要手动将该字节串转为结构体。在syscall中提供了<code>syscall.ParseNetlinkMessage</code>函数可以帮我们完成这一步操作。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">tab, err := syscall.NetlinkRIB(syscall.RTM_GETROUTE, syscall.AF_INET)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">msgs, err := syscall.ParseNetlinkMessage(tab)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>msgs</code>类型为<code>[]NetlinkMessage</code>每一个table中的路由都会被存储为一个<code>NetlinkMessage</code>结构体，接下来我们遍历<code>msgs</code>来取出所有table的路由。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, m := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.Header.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> syscall.NLMSG_DONE:</span><br><span class="line">			fmt.Println(<span class="string">&quot;recv done&quot;</span>)</span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">        <span class="keyword">case</span> syscall.RTM_NEWROUTE:</span><br><span class="line">            <span class="comment">// 解析数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>对于每一个<code>NetlinkMessage</code>结构，我们需要先判断其类型，如果为<code>NLMSG_DONE</code>则表示数据结束，有人可能觉得数组遍历完了就好，为什么非要把最后一个元素设置为<code>NLMSG_DONE</code>，这其实也是socket传输结束的标志，<code>NetlinkRIB</code>和<code>ParseNetlinkMessage</code>只是将他原样解析了而已。</p>
<p>第二个需要注意的点是，我们使用<code>syscall.RTM_GETROUTE</code>标志get的到的路由表，其头类型为<code>syscall.RTM_NEWROUTE</code>而不是<code>syscall.RTM_GETROUTE</code>，其原因我还没有仔细查过。</p>
<h2 id="路由-表属性-解析"><a href="#路由-表属性-解析" class="headerlink" title="路由 表属性 解析"></a>路由 表属性 解析</h2><p>当进入<code>case syscall.RTM_NEWROUTE:</code>分支后，我们就可以拿到一个路由表的具体数据了。首先需要使用unsafe指针将<code>NetlinkMessage</code>的data解析为<code>RtMsg</code>结构体。之后我们可以从<code>rtmsg</code>中解析出路由表的各项属性。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">rtmsg := (*syscall.RtMsg)(unsafe.Pointer(&amp;m.Data[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot;Scope &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Scope &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_UNIVERSE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_UNIVERSE &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_SITE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_SITE &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_LINK:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_LINK &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_HOST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_HOST &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_NOWHERE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_NOWHERE &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot; Protocol &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Protocol &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_UNSPEC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_UNSPEC&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_REDIRECT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_REDIRECT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_KERNEL:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_KERNEL&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_BOOT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_BOOT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_STATIC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_STATIC&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot; Type &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNSPEC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNSPEC&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNICAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNICAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_LOCAL:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_LOCAL&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_BROADCAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_BROADCAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_ANYCAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_ANYCAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_MULTICAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_MULTICAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_BLACKHOLE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_BLACKHOLE&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNREACHABLE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNREACHABLE&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_PROHIBIT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_PROHIBIT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_THROW:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_THROW&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_NAT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_NAT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_XRESOLVE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_XRESOLVE&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">&quot; Family &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Family &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.AF_INET:</span><br><span class="line">        fmt.Print(<span class="string">&quot;AF_INET&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.AF_INET6:</span><br><span class="line">        fmt.Print(<span class="string">&quot;AF_INET6&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由-解析"><a href="#路由-解析" class="headerlink" title="路由 解析"></a>路由 解析</h2><p>使用<code>syscall.ParseNetlinkRouteAttr</code>函数可以将<code>NetlinkMessage</code>结构体中的每一项路由属性解析出来。每一个<code>attr</code>既代表路由表中的一项路由</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">attrs, err := syscall.ParseNetlinkRouteAttr(&amp;m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, attr := <span class="keyword">range</span> attrs &#123;</span><br><span class="line">    <span class="keyword">switch</span> attr.Attr.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_DST:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_DST &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_SRC:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_SRC &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_GATEWAY:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_GATEWAY &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_PRIORITY:</span><br><span class="line">        priority := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_PRIORITY &quot;</span>, priority, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_TABLE:</span><br><span class="line">        table := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_TABLE &quot;</span>, strconv.Itoa(table), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_METRICS:</span><br><span class="line">        metrics := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_METRICS &quot;</span>, metrics, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_IIF:</span><br><span class="line">        iif := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_IIF &quot;</span>, iif, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_OIF:</span><br><span class="line">        oif := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_OIF &quot;</span>, oif, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;============&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.studygolang.com/2017/07/linux-netlink-and-go-part-1-netlink/">LINUX，NETLINK 和 GO – 第 1 部分：NETLINK</a></li>
<li><a href="https://mdlayher.com/blog/linux-netlink-and-go-part-1-netlink/">Linux, Netlink, and Go - Part 1: netlink</a></li>
<li>[<a href="https://beej-zhcn.netdpi.net/]">https://beej-zhcn.netdpi.net/]</a>(Beej’s Guide to Network Programming)</li>
<li><a href="https://tools.ietf.org/html/rfc3549#section-2.3.2">RFC3549</a></li>
</ol>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>linux</tag>
        <tag>table</tag>
        <tag>route</tag>
        <tag>routing</tag>
        <tag>netlink</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU相关题目</title>
    <url>/2021/05/03/LRU%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>LRU(最近最少使用缓存)相关题目</p>
<span id="more"></span>

<h1 id="LRU-最近最少使用-缓存机制-MD"><a href="#LRU-最近最少使用-缓存机制-MD" class="headerlink" title="LRU (最近最少使用) 缓存机制.MD"></a>LRU (最近最少使用) 缓存机制.MD</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/submissions/">https://leetcode-cn.com/problems/lru-cache/submissions/</a></p>
<p>需要用到一个哈希表和一个双向链表。哈希表记录链表节点和键值</p>
<p>每次进行put或get时操作链表，将节点移动至队头。</p>
<p>使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>NFS挂载失效处理</title>
    <url>/2020/07/07/NFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E6%95%88%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在使用NFS的过程中，我们往往会遇到网络问题导致NFS断开，不幸的是，当NFS断开的时候，NFS会继续尝试重连而不会报错，此时如果有软件尝试读取NFS中的内容，就会卡在read函数中无法kill掉。由于文件系统的read不超时，所以它就会永远的卡在里面。同样的现象也会发生在我们尝试执行df命令或者ls NFS目录的时候。此时必须先解挂NFS目录，使程序退出read。</p>
<span id="more"></span>

<h2 id="查找NFS目录位置"><a href="#查找NFS目录位置" class="headerlink" title="查找NFS目录位置"></a>查找NFS目录位置</h2><p>由于NFS目录直接卡死，导致df等命令直接失效，我们只能曲线救国查询NFS目录位置。通常来说，下述两条命令都可以正确执行。</p>
<ol>
<li><code>nfsstat -m</code></li>
<li><code>mount</code></li>
</ol>
<h2 id="解挂"><a href="#解挂" class="headerlink" title="解挂"></a>解挂</h2><p>解挂可以尝试<code>umount -f /path</code>如果提示目录忙，可以继续尝<code>umount -l /path</code>。解挂后相关程序就可以正常退出，此时在重新挂载NFS启动即可。</p>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nvidia Triton 使用教程</title>
    <url>/2021/06/10/Nvidia%20Triton%20Server%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>近年来，在深度学习模型的部署中，涌现了许多新技术，从最早的tf/pytorch直接部署，到onnx，到trnsorrt(trt)，模型的运行效率越来越高。但即便是使用trt方式部署模型，也依旧无法避免巨大的工作量。在使用c++部署trt时，代码量较大，还需要预处理困难。而使用python部署trt，受限于python的GIL问题，需要同时部署多个模型，又失去了trt节省显存的优点。同时，不论使用何种方式，都无法避免面对组batch等问题，整个系统的工程实现会变得非常复杂。<br>在这样的情况下，triton应运而生一站式的帮助我们解决了几乎所有的工程问题，作为一款强大的模型执行引擎，triton支持几乎所有主流的网络模型，对于pytorch，tensorflow，onnx，trt都有良好的支持。</p>
<p>本文将从trt/onnx模型的部署介绍triton的部署流程。</p>
<span id="more"></span>

<h1 id="triton项目的组件"><a href="#triton项目的组件" class="headerlink" title="triton项目的组件"></a>triton项目的组件</h1><ol>
<li><p><a href="https://github.com/triton-inference-server/server">triton server</a><br>triton的服务端可以直接使用docker方式部署，从<a href="https://ngc.nvidia.com/catalog/containers/nvidia:tritonserver/tags">triton的镜像列表</a>中选择tag为xx.xx-py3的镜像即可。</p>
</li>
<li><p><a href="https://github.com/triton-inference-server/client">triton client</a><br>triton的客户端可以从pip直接安装，但为了测试方便，可以直接使用包含测试端的容器环境，tag为xx.xx-py3-sdk的镜像中包含了客户端。</p>
</li>
</ol>
<h1 id="triton-server"><a href="#triton-server" class="headerlink" title="triton server"></a>triton server</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>triton部署模型可以参考<a href="https://github.com/triton-inference-server/server/blob/main/docs/quickstart.md#create-a-model-repository">文档1</a>和<a href="https://github.com/triton-inference-server/server/blob/main/docs/model_repository.md">文档2</a>，但是对于onnx和trt模型，由于模型内已经包含了输入和输出的信息，因此triton可以自动生成配置文件，部署会变得非常简单。</p>
<p>按照triton的教程，我们创建三层目录结构，之后直接把onnx或trt模型拷贝进去即可。</p>
<p>onnx的默认模型名称为model.onnx，而trt的默认模型名称为model.plan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p model_repository/your_model_name/1</span><br><span class="line"><span class="comment"># onnx</span></span><br><span class="line">cp your_model_name.onnx model_repository/your_model_name/1/model.onnx</span><br><span class="line"><span class="comment"># trt</span></span><br><span class="line">cp your_model_name.trt model_repository/your_model_name/1/model.plan</span><br></pre></td></tr></table></figure>

<p>此时你的目录结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;model-repository-path&gt;/</span><br><span class="line">  &lt;your_model_name&gt;/</span><br><span class="line">    1/</span><br><span class="line">      model.plan</span><br></pre></td></tr></table></figure>

<p>准备好模型文件的目录结构之后，我们启动triton服务，并使用<code>--strict-model-config=false</code>要求他自动生成模型文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm --gpus all \</span><br><span class="line">-p8000:8000 -p8001:8001 -p8002:8002 \</span><br><span class="line">-v model_repository:/models \</span><br><span class="line">nvcr.io/nvidia/tritonserver:21.05-py3 \</span><br><span class="line">tritonserver --strict-model-config=<span class="literal">false</span> --model-repository=/models</span><br></pre></td></tr></table></figure>

<p>如果模型正常启动，你将会看到类似下面的的输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------------+---------+--------+</span><br><span class="line">| Model                | Version | Status |</span><br><span class="line">+----------------------+---------+--------+</span><br><span class="line">| &lt;model_name&gt;         | &lt;v&gt;     | READY  |</span><br><span class="line">| ..                   | .       | ..     |</span><br><span class="line">| ..                   | .       | ..     |</span><br><span class="line">+----------------------+---------+--------+</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">I1002 21:58:57.891440 62 grpc_server.cc:3914] Started GRPCInferenceService at 0.0.0.0:8001</span><br><span class="line">I1002 21:58:57.893177 62 http_server.cc:2717] Started HTTPService at 0.0.0.0:8000</span><br><span class="line">I1002 21:58:57.935518 62 http_server.cc:2736] Started Metrics Service at 0.0.0.0:8002</span><br></pre></td></tr></table></figure>

<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>接下来我们需要修改triton为我们生成的配置文件，使用如下命令可以获得当前的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl localhost:8000&#x2F;v2&#x2F;models&#x2F;&lt;your_model_name&gt;&#x2F;config</span><br></pre></td></tr></table></figure>

<p>得到json输出之后，我们需要收到修改为pbconfig的格式。可以参考<a href="https://github.com/triton-inference-server/server/blob/main/docs/model_configuration.md">这篇教程</a>，基本格式如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform: &quot;your_model_name&quot;</span><br><span class="line">max_batch_size: 8</span><br><span class="line">input [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;input0&quot;</span><br><span class="line">    data_type: TYPE_FP32</span><br><span class="line">    dims: [ 16 ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">output [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;output0&quot;</span><br><span class="line">    data_type: TYPE_FP32</span><br><span class="line">    dims: [ 4 ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>修改之后，保存为<code>model_repository/your_model_name/config.pbtxt</code>，保存后你的模型目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;model-repository-path&gt;&#x2F;</span><br><span class="line">  &lt;your_model_name&gt;&#x2F;</span><br><span class="line">    config.pbtxt</span><br><span class="line">    1&#x2F;</span><br><span class="line">      model.plan</span><br></pre></td></tr></table></figure>

<p>这时我们可以关闭triton，去掉<code>--strict-model-config=false</code>选项后重启服务，修改好的配置文件就会生效了。</p>
<h1 id="triton-client"><a href="#triton-client" class="headerlink" title="triton client"></a>triton client</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>此处以python client为例</p>
<p>triton python client的安装非常简单，使用如下方式即可，如果你只使用http或grpc方式调用，可以将<code>tritonclient[all]</code>替换为<code>tritonclient[http]</code>或<code>tritonclient[grpc]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install nvidia-pyindex</span><br><span class="line">pip install tritonclient[all]</span><br></pre></td></tr></table></figure>

<p>如果你安装完之后报错<code>ModuleNotFoundError: No module named &#39;tritonclient&#39;</code>不妨尝试一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pip install nvidia-pyindex</span><br><span class="line">python -m pip install tritonclient[all]</span><br></pre></td></tr></table></figure>
<p>这样可以确保你的依赖被安装到你使用的python环境中。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>根据我的测试，grpc方式调用triton的性能远远高于http方式，在极端情况下甚至可以达到十倍的性能差距，因此如果没有特殊需要，我不建议使用http方式调用。</p>
<p>客户端示例可以看<a href="https://github.com/triton-inference-server/client/tree/main/src/python/examples">此处</a>，推荐从<code>simple_grpc_infer_client.py</code>这个例子入手</p>
<h2 id="shared-memory"><a href="#shared-memory" class="headerlink" title="shared memory"></a>shared memory</h2><p>对于本机内部调用，triton还支持使用shm方式进行数据共享，减小通信开销。更进一步的，你还可以使用cuda shm方式直接共享显存，在数据发送端就将显存设置好，直接调用triton进行推理。但需要注意的是cuda shm会消耗较多显存，需要用户自己去控制，否则会导致显存用尽，在我自己的测试中。</p>
<p>如果有这部分需要可以参考<a href="https://maple.link/2021/11/22/Tensorrt%20shared%20memory/">Triton shared memory</a></p>
<h2 id="异步模式-async-mode"><a href="#异步模式-async-mode" class="headerlink" title="异步模式(async mode)"></a>异步模式(async mode)</h2><p>triton client还支持异步调用，可以查看<code>simple_grpc_async_infer_client.py</code>。</p>
<h2 id="将triton客户端封装为协程"><a href="#将triton客户端封装为协程" class="headerlink" title="将triton客户端封装为协程"></a>将triton客户端封装为协程</h2><p>triton的客户端仅支持异步模式而不支持协程，需要我们手动进行封装</p>
<p>一次原始的异步调用形式如下，当执行结束，callback函数会被调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">triton_client.async_infer(</span><br><span class="line">        model_name&#x3D;model_name,</span><br><span class="line">        inputs&#x3D;inputs,</span><br><span class="line">        callback&#x3D;callback,</span><br><span class="line">        outputs&#x3D;outputs)</span><br></pre></td></tr></table></figure>

<p>因此我们需要在callback中通知协程。需要注意的是callback会在另个一个triton client的线程中被调用，因此需要使用<code>loop.call_soon_threadsafe</code>方法为future设置结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">def callback(loop, future, result, error):</span><br><span class="line">    if error:</span><br><span class="line">        loop.call_soon_threadsafe(future.set_exception, error)</span><br><span class="line">    else:</span><br><span class="line">        loop.call_soon_threadsafe(future.set_result, result)</span><br><span class="line"></span><br><span class="line">def await_infer(triton_client, model_name, inputs, outputs)</span><br><span class="line">    loop &#x3D; asyncio.get_running_loop()</span><br><span class="line">    future &#x3D; loop.create_future()</span><br><span class="line"></span><br><span class="line">    triton_client.async_infer(</span><br><span class="line">        model_name&#x3D;model_name,</span><br><span class="line">        inputs&#x3D;inputs,</span><br><span class="line">        callback&#x3D;partial(callback, loop, future),</span><br><span class="line">        outputs&#x3D;outputs)</span><br><span class="line">    return future</span><br></pre></td></tr></table></figure>

<p>包装好后我们就可以使用<code>await</code>关键字去调用<code>await_infer</code>了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async_result &#x3D; await await_infer(</span><br><span class="line">                triton_client &#x3D; service.triton_client, </span><br><span class="line">                model_name &#x3D; model_name, </span><br><span class="line">                inputs &#x3D; inputs,</span><br><span class="line">                outputs &#x3D; outputs</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>triton</tag>
      </tags>
  </entry>
  <entry>
    <title>ONNX 模型 转 TRT engine</title>
    <url>/2021/06/10/ONNX%E6%A8%A1%E5%9E%8B%E8%BD%ACTRT%20engine/</url>
    <content><![CDATA[<p>本文将介绍如何将ONNX文件转换为TRT engine文件</p>
<span id="more"></span>

<h2 id="准备转换环境"><a href="#准备转换环境" class="headerlink" title="准备转换环境"></a>准备转换环境</h2><p>强烈不推荐自己搭建，可以直接使用nvidia官方的trt环境（如nvcr.io/nvidia/tritonserver:21.05-py3），之后运行也可以直接在容器中运行。</p>
<h2 id="python方案"><a href="#python方案" class="headerlink" title="python方案"></a>python方案</h2><p>在进入容器后，可以使用如下的python脚本进行转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import argparse</span><br><span class="line">import tensorrt as trt</span><br><span class="line"></span><br><span class="line">EXPLICIT_BATCH &#x3D; 1 &lt;&lt; (int)(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH)</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    parser &#x3D; argparse.ArgumentParser(description&#x3D;&quot;PyTorch Object Detection Inference&quot;)</span><br><span class="line">    parser.add_argument(&quot;--onnx_path&quot;, default&#x3D;&quot;&quot;, dest&#x3D;&quot;onnx_path&quot;, help&#x3D;&quot;path to onnx file&quot;, type&#x3D;str)</span><br><span class="line">    parser.add_argument(&quot;--trt_path&quot;, default&#x3D;&quot;&quot;, dest&#x3D;&quot;trt_path&quot;, help&#x3D;&quot;path to trt file&quot;, type&#x3D;str)</span><br><span class="line">    args &#x3D; parser.parse_args()</span><br><span class="line">    onnx_file_path &#x3D; args.onnx_path</span><br><span class="line">    engine_file_path &#x3D; args.trt_path</span><br><span class="line">    print(&#39;get start&#39;)</span><br><span class="line">    TRT_LOGGER &#x3D; trt.Logger()</span><br><span class="line">    with trt.Builder(TRT_LOGGER) as builder, builder.create_network(EXPLICIT_BATCH) as network, trt.OnnxParser(network, TRT_LOGGER) as parser:</span><br><span class="line">        config &#x3D; builder.create_builder_config()</span><br><span class="line">        #builder.max_workspace_size &#x3D;( 1 &lt;&lt; 30 ) * 2</span><br><span class="line">        config.max_workspace_size &#x3D;( 1 &lt;&lt; 20 ) * 3 * 1024 # 3GB，可以根据需求改的更大</span><br><span class="line">        builder.max_batch_size &#x3D; 128</span><br><span class="line">        config.set_flag(trt.BuilderFlag.FP16)</span><br><span class="line">        #builder.fp16_mode &#x3D; True</span><br><span class="line">        # Parse model file</span><br><span class="line">        if not os.path.exists(onnx_file_path):</span><br><span class="line">            print(&#39;ONNX file &#123;&#125; not found, please run yolov3_to_onnx.py first to generate it.&#39;.format(onnx_file_path))</span><br><span class="line">            exit(0)</span><br><span class="line">        print(&#39;Loading ONNX file from path &#123;&#125;...&#39;.format(onnx_file_path))</span><br><span class="line">        with open(onnx_file_path, &#39;rb&#39;) as model:</span><br><span class="line">            print(&#39;Beginning ONNX file parsing&#39;)</span><br><span class="line">            if not parser.parse(model.read()):</span><br><span class="line">                print (&#39;ERROR: Failed to parse the ONNX file.&#39;)</span><br><span class="line">                for error in range(parser.num_errors):</span><br><span class="line">                    print (parser.get_error(error))</span><br><span class="line">        print(f&quot;raw shape of &#123;network.get_input(0).name&#125; is: &quot;, network.get_input(0).shape)</span><br><span class="line">        # network.get_input(0).shape &#x3D; [-1, 3, 32, -1] #dynamic model example</span><br><span class="line">        for i in range(1):</span><br><span class="line">            profile &#x3D; builder.create_optimization_profile()</span><br><span class="line">            # 最小值 常规值 最大值</span><br><span class="line">            profile.set_shape(network.get_input(0).name, (1, 3, 32, 32), (16, 3, 32, 320), (128, 3, 32, 960))</span><br><span class="line">            config.add_optimization_profile(profile)</span><br><span class="line">        print(&#39;Completed parsing of ONNX file&#39;)</span><br><span class="line">        print(&#39;Building an engine from file &#123;&#125;; this may take a while...&#39;.format(onnx_file_path))</span><br><span class="line">        engine &#x3D; builder.build_engine(network,config)</span><br><span class="line">        print(&quot;Completed creating Engine&quot;)</span><br><span class="line">        with open(engine_file_path, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(engine.serialize())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="官方工具转换"><a href="#官方工具转换" class="headerlink" title="官方工具转换"></a>官方工具转换</h2><p>推荐使用官方工具，简单快捷</p>
<ul>
<li><p>–workspace=4096 单位为MB</p>
</li>
<li><p>–explicitBatch 开启动态batch</p>
</li>
<li><p>–minShapes 最小输入 </p>
<p>格式为 节点名:<code>&lt;b&gt;x&lt;d1&gt;x&lt;d2&gt;x...x&lt;dn&gt;</code> </p>
<p>注意节点名的引号需要使用反斜杠转译，如网络输入节点是’data’，那么需要写成<code>\&#39;data\&#39;:1x2x3x4</code>这样的格式。</p>
</li>
<li><p>–optShapes 平均输入</p>
</li>
<li><p>–maxShapes 最大输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run --gpus all --rm -v /models:/models nvcr.io/nvidia/tensorrt:21.04-py3 \</span><br><span class="line">/usr/src/tensorrt/bin/trtexec --explicitBatch --workspace=4096 \</span><br><span class="line">--minShapes=\<span class="string">&#x27;data\&#x27;</span>:1x3x32x32 --optShapes=\<span class="string">&#x27;data\&#x27;</span>:128x3x32x320 --maxShapes=\<span class="string">&#x27;data\&#x27;</span>:256x3x32x960 --fp16 \</span><br><span class="line">--onnx=/models/model.onnx --saveEngine=/models/model.plan</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>tensorrt</tag>
        <tag>onnx</tag>
        <tag>trtexec</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用Pipe控制命令行输入输出</title>
    <url>/2021/07/13/Python%E4%BD%BF%E7%94%A8Pipe%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>在开发过程中，我们有时需要在python中调用诸如ffmpeg这样的命令。此时就不可避免的需要用到pipe。</p>
<span id="more"></span>

<p>当我们仅需要使用输入或输出时，可以直接指定stdin/stdout/stderr为Pipe，但是当我们需要同时使用输入输出时，直接使用pipe的读写时无法工作的。</p>
<p>此时只能使用<code>pipe.communicate</code>方法，通过这种一锤子买卖一次性把所有的输入设置完，并读取所有的输出。</p>
<p>下面的例子是一个使用pipe将音频文件的字节流送给ffmpeg处理，并且从ffmpeg读取处理结果的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># init command</span><br><span class="line"># set ffmpeg read write to pipe</span><br><span class="line">ffmpeg_command &#x3D; [&quot;ffmpeg&quot;, &quot;-f&quot;, &quot;aac&quot;,&quot;-i&quot;, &quot;-&quot;, &quot;-f&quot;, &quot;wav&quot;, &quot;-&quot;]</span><br><span class="line"></span><br><span class="line"># excute ffmpeg command</span><br><span class="line">pipe &#x3D; subprocess.Popen(ffmpeg_command,</span><br><span class="line">                    stdin&#x3D;subprocess.PIPE,</span><br><span class="line">                    stdout&#x3D;subprocess.PIPE,</span><br><span class="line">                    bufsize&#x3D;1024*1024*128)</span><br><span class="line"></span><br><span class="line"># get you byte stream from anywhere</span><br><span class="line">with open(&quot;audio.aac&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    data &#x3D; f.read()</span><br><span class="line"></span><br><span class="line"># only way you can read and write in same time</span><br><span class="line">output, stderr &#x3D; pipe.communicate(data)</span><br><span class="line"></span><br><span class="line">with open(&quot;test.wav&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    data &#x3D; output</span><br><span class="line">    print(len(data))</span><br><span class="line">    f.write(data)</span><br><span class="line">pipe.wait()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pipe</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorrt Engine 输出模型输入输出信息</title>
    <url>/2021/09/08/Tensorrt%20Engine%20%E8%BE%93%E5%87%BA%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>调试plan文件的时候经常需要输出相关信息，在这里分享一个方便的程序脚本，可以输出每个输入输出节点的相关信息</p>
<span id="more"></span>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorrt as trt</span><br><span class="line">import sys</span><br><span class="line">import numpy as np</span><br><span class="line">trt_logger &#x3D; trt.Logger(trt.Logger.INFO)</span><br><span class="line">runtime &#x3D; trt.Runtime(trt_logger)</span><br><span class="line">with open(sys.argv[1], &quot;rb&quot;) as f:</span><br><span class="line">    engine &#x3D; runtime.deserialize_cuda_engine(f.read())</span><br><span class="line">print(&quot;Engine Info:&quot;)</span><br><span class="line">for i, binding in enumerate(engine):</span><br><span class="line">    shape &#x3D; [engine.max_batch_size, *engine.get_binding_shape(binding)]</span><br><span class="line">    dtype &#x3D; trt.nptype(engine.get_binding_dtype(binding))</span><br><span class="line">    volume &#x3D; abs(trt.volume(engine.get_binding_shape(binding)))</span><br><span class="line">    if engine.binding_is_input(binding):</span><br><span class="line">        desc &#x3D; &quot;input&quot; </span><br><span class="line">    else:</span><br><span class="line">        desc &#x3D; &quot;output&quot;</span><br><span class="line">    print(f&quot;&#123;i&#125; type:    &#123;desc&#125;\n  binding: &#123;binding&#125; \n  data:    &#123;np.dtype(dtype).name&#125;\n  shape:   &#123;shape&#125; &#x3D;&gt; &#123;volume&#125; \n&quot;)</span><br></pre></td></tr></table></figure>
<p>输入形式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TensorRT] INFO: [MemUsageChange] Init CUDA: CPU +329, GPU +0, now: CPU 341, GPU 999 (MiB)</span><br><span class="line">[TensorRT] INFO: Loaded engine size: 4 MB</span><br><span class="line">[TensorRT] INFO: [MemUsageSnapshot] deserializeCudaEngine begin: CPU 346 MiB, GPU 999 MiB</span><br><span class="line">[TensorRT] INFO: [MemUsageChange] Init cuBLAS&#x2F;cuBLASLt: CPU +491, GPU +210, now: CPU 842, GPU 1211 (MiB)</span><br><span class="line">[TensorRT] INFO: [MemUsageChange] Init cuDNN: CPU +287, GPU +200, now: CPU 1129, GPU 1411 (MiB)</span><br><span class="line">[TensorRT] INFO: [MemUsageChange] Init cuBLAS&#x2F;cuBLASLt: CPU +0, GPU +0, now: CPU 1129, GPU 1393 (MiB)</span><br><span class="line">[TensorRT] INFO: [MemUsageSnapshot] deserializeCudaEngine end: CPU 1129 MiB, GPU 1393 MiB</span><br><span class="line">Engine Info:</span><br><span class="line">0 type:    input</span><br><span class="line">  binding: data </span><br><span class="line">  data:    float32</span><br><span class="line">  shape:   [1, 1, 3, 256, 256] &#x3D;&gt; 36864 </span><br><span class="line"></span><br><span class="line">1 type:    output</span><br><span class="line">  binding: result </span><br><span class="line">  data:    float32</span><br><span class="line">  shape:   [1, 8, 8] &#x3D;&gt; 8 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --gpus all \</span><br><span class="line">  --rm -v /home/user/trtdebug.py:/models/trtdebug.py \</span><br><span class="line">  --rm -v /home/user/model.plan:/models/model.plan \</span><br><span class="line">  geminihub.oa.com:80/karizhang/nvcr.io/nvidia/tensorrt:21.08-py3 python /models/trtdebug.py /models/model.plan</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>tensorrt</tag>
      </tags>
  </entry>
  <entry>
    <title>Triton shared memory</title>
    <url>/2021/11/22/Triton%20shared%20memory/</url>
    <content><![CDATA[<p>在使用triton时，可以使用shared memory方式加速数据传输的过程</p>
<span id="more"></span>

<h1 id="shared-memory-与-cuda-shared-memory"><a href="#shared-memory-与-cuda-shared-memory" class="headerlink" title="shared memory 与 cuda shared memory"></a>shared memory 与 cuda shared memory</h1><ul>
<li>在<code>shared memory</code>模式下，triton会在数据存放于<code>/dev/shm</code>目录下，之后将文件路径通过rpc接口发送给triton server</li>
<li>在<code>cuda shared memory</code>模式下，triton会在指定显卡上申请一块显存区域，之后直接将数据存放于显存中并通过rpc通知triton server</li>
</ul>
<p>两种shm模式均会使用额外的显存或内存区域，并且依赖程序主动注销申请的空间，因此程序编写时需要特别注意资源的回收和释放，否则将会导致内存或显存泄露</p>
<p>考虑到一般情况下内存空间会远大于显存空间，在发生泄漏时内存空间也比显存空间更好回收，因此虽然cuda-shm模式的速度相比shm更快，但是我依旧更推荐使用shm模式。</p>
<h1 id="shm-memory-pool"><a href="#shm-memory-pool" class="headerlink" title="shm memory pool"></a>shm memory pool</h1><p>使用shm模式的最简单的方式是每次使用随机或顺序递增的文件名去申请内存，在使用结束后立刻释放，但是考虑到保持内存用量的稳定以及复用内存空间来进一步加速，可以使用shm内存池来更好的使用shm模式</p>
<p>内存池的代码如下，主要特性：</p>
<ol>
<li>根据用户提供的<code>shm_name_prefix, shm_key_prefix</code>创建指定数量的共享内存对象，如果使用该名称的对象已经存在则原有对象删除重新创建，这一步保证了过去泄露的内存空间能够被回收</li>
<li>将申请的所有内存空间注册到triton server</li>
<li>支持asyncio，使用await语句等待空闲内存对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tritonclient.grpc <span class="keyword">as</span> grpcclient</span><br><span class="line"><span class="keyword">import</span> tritonclient.utils.shared_memory <span class="keyword">as</span> shm</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Awaitable</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShmRegion</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, triton_client: grpcclient, shm_queue: Queue, max_data_size, shm_name, shm_key</span>):</span></span><br><span class="line">        self.name = shm_name</span><br><span class="line">        self.key = shm_key</span><br><span class="line">        self.shm_queue = shm_queue</span><br><span class="line">        self.size = max_data_size</span><br><span class="line">        self.triton_client: grpcclient = triton_client</span><br><span class="line">        <span class="comment"># 这里要注意，也许triton升级之后shm就不放这里了，这样清理过期资源不是长久之计</span></span><br><span class="line">        self.shm_path = Path(<span class="string">f&quot;/dev/shm/<span class="subst">&#123;self.key&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.shm_path.exists():</span><br><span class="line">            os.remove(self.shm_path)</span><br><span class="line">        self.triton_client.unregister_system_shared_memory(self.name)</span><br><span class="line">        self.handle = shm.create_shared_memory_region(self.name, self.key, max_data_size)</span><br><span class="line">        self.triton_client.register_system_shared_memory(self.name, self.key, max_data_size)</span><br><span class="line">        logging.info(<span class="string">f&quot;shm region <span class="subst">&#123;self.name&#125;</span> registered&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addToQueue</span>(<span class="params">self, shm_queue=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> shm_queue <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">assert</span> self.shm_queue <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.shm_queue <span class="keyword">is</span> shm_queue</span><br><span class="line">            self.shm_queue = shm_queue</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> self.shm_queue <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        self.shm_queue.put_nowait(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, trace</span>):</span></span><br><span class="line">        self.addToQueue()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        logging.info(<span class="string">f&quot;shm region <span class="subst">&#123;self.name&#125;</span> removed&quot;</span>)</span><br><span class="line">        self.triton_client.unregister_system_shared_memory(self.name)</span><br><span class="line">        shm.destroy_shared_memory_region(self.handle)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShmTritonClient</span>(<span class="params"><span class="built_in">object</span></span>):</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, triton_client, max_queue_size, max_data_size, shm_name_prefix, shm_key_prefix</span>):</span></span><br><span class="line">        self.triton_client = triton_client</span><br><span class="line">        <span class="comment"># self.triton_client.unregister_system_shared_memory()</span></span><br><span class="line">        <span class="comment"># 这似乎是一个异步请求，执行后会导致后面的注册失效</span></span><br><span class="line">        <span class="comment"># 等到能拿到loop的时候再执行</span></span><br><span class="line">        <span class="comment"># self.shm_queue = Queue(maxsize=max_queue_size, loop=None)</span></span><br><span class="line">        self.shm_queue = <span class="literal">None</span></span><br><span class="line">        self.max_queue_size = max_queue_size</span><br><span class="line">        self.regions = []</span><br><span class="line">        self.registered_regions = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_queue_size):</span><br><span class="line">            region = ShmRegion(self.triton_client, self.shm_queue, max_data_size, <span class="string">f&quot;<span class="subst">&#123;shm_name_prefix&#125;</span>_<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;shm_key_prefix&#125;</span>_<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">            self.regions.append(region)</span><br><span class="line">            <span class="comment"># 等到能拿到loop的时候再执行</span></span><br><span class="line">            <span class="comment"># region.addToQueue()</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRegion</span>(<span class="params">self</span>) -&gt; Awaitable[ShmRegion] :</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;每次调用时如果还有未被注册的region, 则注册一个, &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.shm_queue <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            loop = asyncio.get_running_loop()</span><br><span class="line">            self.shm_queue = Queue(maxsize=self.max_queue_size, loop=loop)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.regions) &gt; self.registered_regions:</span><br><span class="line">            self.regions[self.registered_regions].addToQueue(self.shm_queue)</span><br><span class="line">            self.registered_regions += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.shm_queue.get()</span><br></pre></td></tr></table></figure>

<p>使用例子如下：</p>
<ol>
<li>初始化</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tritonclient.grpc <span class="keyword">as</span> grpcclient</span><br><span class="line">triton_client = grpcclient.InferenceServerClient(url=<span class="string">&quot;localhost:8001&quot;</span>)</span><br><span class="line"><span class="comment"># 计算你的数据的最大内存使用，比如最大的batch=32，最大size=3*512*512</span></span><br><span class="line">max_data = np.zeros(shape=(<span class="number">32</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>), dtype=np.float32)</span><br><span class="line">byte_size = max_data.size * max_data.itemsize</span><br><span class="line">shm_client = ShmTritonClient(triton_client, max_queue_size=<span class="number">16</span>, max_data_size=byte_size, shm_name_prefix=<span class="string">&quot;shm_data&quot;</span>, shm_key_prefix=<span class="string">&quot;/shm_data&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>调用</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tritonclient.utils <span class="keyword">as</span> utils</span><br><span class="line"><span class="keyword">import</span> tritonclient.utils.shared_memory <span class="keyword">as</span> shm</span><br><span class="line"><span class="keyword">from</span> await_infer <span class="keyword">import</span> await_infer</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">infer</span>(<span class="params">img, triton_client</span>):</span></span><br><span class="line">    input_byte_size = img.size * img.itemsize</span><br><span class="line">    <span class="comment"># 一次性获取2个region分别用于输入输出</span></span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">await</span> shm_client.getRegion()) <span class="keyword">as</span> inpRegion, \</span><br><span class="line">        (<span class="keyword">await</span> shm_client.getRegion()) <span class="keyword">as</span> outRegion:</span><br><span class="line">        shm.set_shared_memory_region(inpRegion.handle, [img])</span><br><span class="line">        inputs = [grpcclient.InferInput(<span class="string">&#x27;input&#x27;</span>, [*img.shape], <span class="string">&quot;FP32&quot;</span>)]</span><br><span class="line">        <span class="comment"># 输入为FP32的图片，很大，需要使用shm加速</span></span><br><span class="line">        inputs[<span class="number">0</span>].set_shared_memory(inpRegion.name, input_byte_size)</span><br><span class="line">        <span class="comment"># 假设网络有2个输出，第一个输出比较大使用shm模式，第二个输出很小，直接使用grpc完成传输</span></span><br><span class="line">        outputs = [grpcclient.InferRequestedOutput(name) <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">&#x27;shm_output&#x27;</span>， <span class="string">&#x27;plain_output&#x27;</span>]]</span><br><span class="line">        outputs[<span class="number">0</span>].set_shared_memory(outRegion.name, outRegion.size)</span><br><span class="line">        <span class="comment"># await_inferd的代码参考文章 &quot;Nvidia Triton 使用教程&quot;</span></span><br><span class="line">        <span class="comment"># https://maple.link/2021/06/10/Nvidia%20Triton%20Server%E7%9A%84%E4%BD%BF%E7%94%A8/</span></span><br><span class="line">        results = <span class="keyword">await</span> await_infer(</span><br><span class="line">                triton_client = triton_client, </span><br><span class="line">                model_name = <span class="string">&quot;model_name&quot;</span>, </span><br><span class="line">                inputs = inputs,</span><br><span class="line">                outputs = outputs</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        shm_output = results.get_output(<span class="string">&quot;shm_output&quot;</span>)</span><br><span class="line">        shm_output = shm.get_contents_as_numpy(</span><br><span class="line">            outRegion.handle, utils.triton_to_np_dtype(shm_output.datatype),</span><br><span class="line">            shm_output.shape)</span><br><span class="line">        plain_output = results.as_numpy(<span class="string">&#x27;plain_output&#x27;</span>)</span><br><span class="line">        <span class="comment"># copy前shm_output, plain_output都是只读的，无法编辑</span></span><br><span class="line">        shm_output = shm_output.copy()</span><br><span class="line">        plain_output = plain_output.copy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shm_output, plain_output</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>tensorrt</tag>
        <tag>shared memory</tag>
      </tags>
  </entry>
  <entry>
    <title>Yolo发展整理</title>
    <url>/2021/05/03/Yolo%E5%8F%91%E5%B1%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>因为算法面试，整理了一些yolo相关的点</p>
<span id="more"></span>

<h2 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h2><p>region proposals 而不是滑动窗口</p>
<p>输入尺寸固定</p>
<p>小目标检测不好</p>
<p>一个单元格只能预测两个框和一个类别</p>
<h2 id="yolo9000"><a href="#yolo9000" class="headerlink" title="yolo9000"></a>yolo9000</h2><p>替换全连接为卷积，没有了输入尺寸的限制</p>
<p>引入anchor box, 使用kmeans聚类，5 anchor</p>
<p>darknet-19</p>
<p>13 * 13 detection， 2种尺度13 * 13， 26 * 26</p>
<p>训练过程中遇到带标签的检测图像，就基于 YOLOv2 整个损失函数进行反向传播，遇到分类图像，只反向传播网络的分类损失。</p>
<h2 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h2><p>9 anchor</p>
<p>darknet-53</p>
<p>13 * 13， 26 * 26， 52*52， 3个detection</p>
<p>YOLOv3 为每个边界框都预测了一个分数 objectness score，打分依据是预测框与物体的重叠度。如果某个框的重叠度比其他框都高，它的分数就是 1</p>
]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>Yolo发展整理</tag>
      </tags>
  </entry>
  <entry>
    <title>hdfs命令行流式处理</title>
    <url>/2021/12/20/hdfs%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="文件流式处理"><a href="#文件流式处理" class="headerlink" title="文件流式处理"></a>文件流式处理</h1><p>在处理hdfs数据时，可能会遇到本地磁盘空间不足以存放数据的问题，这时我们可以使用linux的stdio对数据进行流式处理，以替换每行内容为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop -cat hdfs://your_path/your_file |\</span><br><span class="line">sed  <span class="string">&quot;s/some_thing/some_other/g&quot;</span> |\</span><br><span class="line">hadoop -put - hdfs://your_path/your_processed_file</span><br></pre></td></tr></table></figure>

<p>这样利用pipe完成了对数据的处理，同时避免了数据在本地落盘。</p>
<h1 id="遍历文件夹处理"><a href="#遍历文件夹处理" class="headerlink" title="遍历文件夹处理"></a>遍历文件夹处理</h1><p>此外还可以搭配xargs遍历整个目录</p>
<ul>
<li><code>hadoop -ls -h hdfs://your_path</code> 列出整个目录</li>
<li><code>awk -F&#39; &#39; &#39;&#123;print $NF&#125;&#39;</code> 取出最后一列，也就是文件地址列</li>
<li><code>awk -F&#39;/&#39; &#39;&#123;print $NF&#125;&#39;</code> 将地址中的文件名取出</li>
<li><code>xargs -I &#123;&#125; bash -c ...</code> 将每个文件名依次作为参数处理</li>
<li><code>&quot;hadoop -cat  ...&quot;</code> 按照之前流式处理的方式处理每一个文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop -ls -h hdfs://your_path | awk -F<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | awk -F<span class="string">&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | xargs -I &#123;&#125; bash -c <span class="string">&quot;hadoop -cat hdfs://your_path/&#123;&#125; | sed &#x27;s/some_thing/some_other/g&#x27; | hadoop -put - hdfs://your_other_path/&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hdfs</category>
      </categories>
      <tags>
        <tag>hdfs</tag>
        <tag>stdin</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客配合Github Action完成自动CI/CD</title>
    <url>/2021/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E5%90%88Github-Action%E5%AE%8C%E6%88%90%E8%87%AA%E5%8A%A8CI-CD/</url>
    <content><![CDATA[<p>每次部署博客时都需要在本地完成编译和上传，维护工具链成为一件很繁琐的事情，有什么办法能够将这一步自动化，为将来随时随地写博客打下基础呢？</p>
<p>现在来一起学(白)习(嫖)Github Action吧！</p>
<p><small>PS.阅读本文，你需要提前了解一些sh和yaml相关的知识。</small></p>
<span id="more"></span>

<h2 id="CI实现"><a href="#CI实现" class="headerlink" title="CI实现"></a>CI实现</h2><p>为了从源码构建Hexo博客，我们需要进行如下几步：</p>
<ol>
<li>clone源码</li>
<li>clone主题(可选)</li>
<li>安装依赖</li>
<li>构建</li>
</ol>
<p>那么如果使用Github Action实现如上几步呢？</p>
<p>下面直接上配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Action 名称</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Auto</span> <span class="string">Deploy</span></span><br><span class="line"><span class="comment"># 触发条件</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># 代码变动时触发</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 保留此行代表运行手动触发</span></span><br><span class="line">  <span class="comment"># 详情轻参考 https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_dispatch</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="comment"># 主题代码</span></span><br><span class="line">  <span class="attr">THEME_REPO:</span> <span class="string">theme-next/hexo-theme-next</span></span><br><span class="line">  <span class="attr">THEME_BRANCH:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># 工作环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 设置时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">TimeZone</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">sudo</span> <span class="string">timedatectl</span> <span class="string">set-timezone</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">      <span class="comment"># clone代码到~/Blog目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">Blog</span></span><br><span class="line">      <span class="comment"># 配置Node</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2.1.5</span></span><br><span class="line">      <span class="comment"># 删除旧主题(可选)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clear</span> <span class="string">old</span> <span class="string">theme</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">Blog</span></span><br><span class="line">          <span class="string">rm</span> <span class="string">-rf</span> <span class="string">themes/next</span></span><br><span class="line">      <span class="comment"># 拉取新主题(可选)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">Blog/themes/next</span></span><br><span class="line">      <span class="comment"># 安装主题配置文件，安装依赖</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">deps</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">Blog</span></span><br><span class="line">          <span class="string">cp</span> <span class="string">theme_config.yml</span> <span class="string">themes/next/_config.yml</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="comment"># 构建, 产物在~/Blog/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">Blog</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure>

<h2 id="CD实现"><a href="#CD实现" class="headerlink" title="CD实现"></a>CD实现</h2><p>部署方式因人而异，我选择了最方便的Github Pages方式部署。以这种方式部署时，构建好的项目需要被上传到pages项目中。</p>
<p>创建pages项目的教程请参考 <a href="https://pages.github.com/%E3%80%82">https://pages.github.com/。</a></p>
<p>创建完成后，我们需要在pages项目的Settings-&gt;Deploy keys中增加一个公钥。</p>
<p>在博客源码项目中的Settings-&gt;Secrets-&gt;Actions secrets中增加一个私钥。此处我命名为了MAPLE_BLOG，并在步骤Set up git中使用。</p>
<p>密钥对的生成可以使用ssh-keygen(linux/mac)或puttygen(win)，此处不再赘述。</p>
<p>之后在上述流程中增加如下几个env和steps。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ... 省略了一些东西</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="comment"># 增加如下几个env</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">Casxt</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="number">774714620</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">casxt/casxt.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">git@github.com:casxt/blog.github.io.git</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># ... 构建的steps</span></span><br><span class="line">      <span class="comment"># 增加如下step</span></span><br><span class="line">      <span class="comment"># clone pages 项目到~/public目录</span></span><br><span class="line">      <span class="comment"># 需要注意的是我们构建好的产物在~/Blog/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">blog</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;env.DEPLOY_REPO&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;env.DEPLOY_BRANCH&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">public</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 设置私钥，以便向pages项目推送代码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">git</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_KEY:</span> <span class="string">$&#123;&#123;secrets.MAPLE_BLOG&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;$DEPLOY_KEY&quot;</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$GIT_USER</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 拷贝产物，并push</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">git</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">Blog</span></span><br><span class="line">          <span class="string">cp</span> <span class="string">-R</span> <span class="string">public/*</span> <span class="string">../public/</span> </span><br><span class="line">          <span class="string">cd</span> <span class="string">../public/</span></span><br><span class="line">          <span class="string">git</span> <span class="string">remote</span> <span class="string">set-url</span> <span class="string">origin</span> <span class="string">$DEPLOY_GIT_REMOTE</span></span><br><span class="line">          <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">          <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;auto deploy&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端技术</category>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
        <tag>Github Action</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hive中操作json以及对list的处理</title>
    <url>/2021/12/09/hive%E4%B8%AD%E6%93%8D%E4%BD%9Cjson%E4%BB%A5%E5%8F%8A%E5%AF%B9list%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在处理数据时，时常会遇到需要处理json数据的情况, 可以使用<code>get_json_object</code>, <code>regexp_replace</code>, <code>split</code>来组合对json数组进行处理</p>
<span id="more"></span>


<p>假设json数据为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;data&quot;</span>: [<span class="string">&quot;text1&quot;</span>, <span class="string">&quot;text1&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要将data提取后转换为字符串形式”text1,text2”, 可以使用如下写法实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  concat_ws(<span class="string">&#x27;;&#x27;</span>, </span><br><span class="line">    split(</span><br><span class="line">      regexp_replace(</span><br><span class="line">        get_json_object(</span><br><span class="line">            <span class="string">&#x27;&#123;&quot;data&quot;: [&quot;text1&quot;, &quot;text2&quot;]&#125;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;$.data&#x27;</span></span><br><span class="line">        ), </span><br><span class="line">        <span class="string">&#x27;[\\[\\]&quot;\\s]&#x27;</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">      ), </span><br><span class="line">      <span class="string">&#x27;,&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>首先使用<code>get_json_object</code>将json中需要的字段提取出来, 然后使用<code>regexp_replace</code>对输出的字符串进行处理, 正则<code>[\\[\\]&quot;\\s]</code>会将<code>[</code>, <code>]</code>, <code>&quot;</code>以及<code>空白符号删除</code>, 最后输出<code>text1,text2</code>, <code>split</code>函数会使用<code>,</code>作为分割符, 将字符串转换为array, 最后<code>concat_ws</code>通过<code>;</code>将array中的所有字符串拼接。</p>
<p>写正则表达式时，不同的系统可能会有不同的转义规则，需要特别注意<code>\</code>的数量。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>get_json_object</tag>
        <tag>hive</tag>
        <tag>spark</tag>
        <tag>presto</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables基础概念</title>
    <url>/2020/03/02/iptables%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>iptables 是标准的linux防火墙命令行控制工具, 其底层调用netfilter来实现各种功能</p>
<p>iptables 中最重要的概念就是 table, chain 和 rule</p>
<span id="more"></span>
<h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>iptables 中包含多个 table, 每个 table 又包含多个 chain, table 是 chain 的集合, 通常可以将 table 视作 chain 按照目的进行的分类</p>
<p>从数据进入网卡到流出网卡的过程中, iptables 会按照一定顺序调用各个 table 的 chain, 我们可以在某个 table 中添加 chain 或 rule 来在某个特定的时间点处理数据。</p>
<p>iptables 中包含了 raw, filter, nat, mangle, security 五个 table, 其中最常用的就是 nat 和 filter。</p>
<p>nat 中包含了会在数据<strong>收发阶段</strong>被调用的 chain, 因此可以用来对数据进行预处理和后处理。</p>
<p>filter 中包含了会在<strong>收发阶段</strong>和<strong>转发阶段</strong>被调用的 chain, 因此通常用来实现防火墙, 对数据的原目的地址端口协议等进行检查。</p>
<h1 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h1><p>chain 是规则(rule)的集合, 每个 table 中会包含数量不定的 chain, 不同 table 中的 chain 可能具有相同的名字 </p>
<p>例如 nat 中包含了 PREROUTING, POSTROUTING, OUTPUT 三个 chain, filter 中包含了 INPUT, OUTPUT, FORWARD 三个 chain</p>
<p>在 iptables 默认的5个 table 中, 每个 table 都包含了数量不一的 chain, 这些 chain 会在数据处理的各个节点被调用, 我们通过在这些默认的 chain 中添加 rule 就可以实现对数据包的捕获和处理。</p>
<h1 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h1><p>rule 是处理数据的具体规则, 数据收发过程中, iptables 会按照一定顺序调用各个 table 的 chain, 我们在这些 chain 中添加规则就可以随心所欲的处理数据。</p>
<p>通常来说, 一个 rule 功能包括:</p>
<ol>
<li>接受或拒绝一个包</li>
<li>将一个包送到某个 chain 里继续处理</li>
<li>改写包</li>
</ol>
<h1 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h1><p>按照下图所示, 我们只关注 filter 和 nat</p>
<p>对于收到的目的地址为本机的数据包, 依次经过 filter 和 nat 的5个 chain:</p>
<ol>
<li>nat: PEROUTING</li>
<li>filter: INPUT</li>
<li>nat: OUTPUT</li>
<li>filter: OUTPUT</li>
<li>nat: POSTOUTING</li>
</ol>
<p>对于收到的目的地址不为本机的数据包, 依次经过 filter 和 nat 的3个 chain:</p>
<ol>
<li>nat: PEROUTING</li>
<li>filter: FORWARD</li>
<li>nat: POSTOUTING</li>
</ol>
<blockquote>
<div style="width:50%;margin:auto"> <img src="/2020/03/02/iptables%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/iptables.jpg" class="" title="iptables 200"> </div>
<small>https://www.it.uu.se/edu/course/homepage/sakdat/vt09/pm/programme/iptables.pdfhexo</small>
</blockquote>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>table</tag>
        <tag>iptables</tag>
        <tag>chain</tag>
        <tag>rule</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb静态编译及snappy支持</title>
    <url>/2021/11/17/leveldb%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%8F%8Asnappy%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>由于服务器依赖比较老旧，因此需要重新安装各种依赖</p>
<span id="more"></span>
<h2 id="leveldb依赖安装"><a href="#leveldb依赖安装" class="headerlink" title="leveldb依赖安装"></a>leveldb依赖安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install cmake gcc g++</span><br></pre></td></tr></table></figure>
<p>如果cmake无法安装到3.9以上的版本，可以从<a href="https://cmake.org/download/">官网</a>下载，然后直接解压到项目目录下，之后直接使用绝对路径或相对路径调用cmake，gcc和g++推荐使用7.5</p>
<h2 id="snappy编译"><a href="#snappy编译" class="headerlink" title="snappy编译"></a>snappy编译</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;snappy.git</span><br><span class="line">cd snappy</span><br><span class="line">git submodule update --init</span><br><span class="line">git checkout 1.1.9</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE&#x3D;Release ..&#x2F;</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h2 id="leveldb编译"><a href="#leveldb编译" class="headerlink" title="leveldb编译"></a>leveldb编译</h2><p>使用<code>--recurse-submodules</code>下载subgit中的内容，使用<code>git tag</code>查看tag，选择最新的release，最后使用<code>git checkout</code>切换到最新的release版本上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone --recurse-submodules https:&#x2F;&#x2F;github.com&#x2F;google&#x2F;leveldb.git</span><br><span class="line">cd leveldb</span><br><span class="line">git tag</span><br><span class="line">git checkout 1.23</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE&#x3D;Release .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure>
<p>执行测试检查编译是否成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;db_bench</span><br></pre></td></tr></table></figure>

<h3 id="snappy支持"><a href="#snappy支持" class="headerlink" title="snappy支持"></a>snappy支持</h3><p>修改<code>leveldb/CMakeLists.txt</code>, 在<code>check_library_exists(snappy snappy_compress &quot;&quot; HAVE_SNAPPY)</code>语句前后添加依赖</p>
<p>其中<code>/home/someone/project/snappy</code>和<code>/home/someone/project/snappy/build</code>需要替换成自己的snappy源码目录和build目录<br>添加后形式如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 之前添加依赖</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="string">&quot;/home/someone/project/snappy/build&quot;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;/home/someone/project/snappy&quot;</span> <span class="string">&quot;/home/someone/project/snappy/build&quot;</span>)</span><br><span class="line">check_library_exists(snappy snappy_compress <span class="string">&quot;&quot;</span> HAVE_SNAPPY)</span><br><span class="line"><span class="comment"># 之后强制开启HAVE_SNAPPY</span></span><br><span class="line"><span class="keyword">set</span>(HAVE_SNAPPY <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
<p>重新编译和测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br><span class="line">./db_bench</span><br></pre></td></tr></table></figure>

<h3 id="静态编译leveldb"><a href="#静态编译leveldb" class="headerlink" title="静态编译leveldb"></a>静态编译leveldb</h3><p>因为服务器环境问题，需要静态编译leveldb, 尤其是静态编译libgcc和libg++</p>
<p>在<code>check_library_exists(snappy snappy_compress &quot;&quot; HAVE_SNAPPY)</code>语句前后添加<code>link_libraries</code>标签配置所有的目标静态链接gcc和g++</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link_libraries(-static-libgcc -static-libstdc++)</span><br></pre></td></tr></table></figure>
<p>执行<code>ldd db_bench</code>可以看到已经不再依赖gcc和g++了</p>
<p>执行<code>strings /lib64/libstdc++.so.6 | grep GLIBCXX</code>可以查看目前支持的版本</p>
<h3 id="可能会遇到如下报错："><a href="#可能会遇到如下报错：" class="headerlink" title="可能会遇到如下报错："></a>可能会遇到如下报错：</h3><ol>
<li><p>找不到成员</p>
<p> 这种情况是由于gcc、g++版本太低导致的，需要升级版本</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leveldb&#x2F;third_party&#x2F;googletest&#x2F;googletest&#x2F;include&#x2F;gtest&#x2F;gtest-matchers.h:414:12: error: ‘is_trivially_copy_constructible’ is not a member of ‘std’</span><br><span class="line">            std::is_trivially_copy_constructible&lt;M&gt;::value &amp;&amp;</span><br><span class="line">            ^</span><br></pre></td></tr></table></figure>
<p> 使用如下命令检查版本</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br></pre></td></tr></table></figure></li>
<li><p>/bin/c++ /bin/cc缺失</p>
<p> 这种情况是软链缺失导致的，报错如下</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMake Error at CMakeLists.txt:7 (project):</span><br><span class="line">  The CMAKE_CXX_COMPILER:</span><br><span class="line"></span><br><span class="line">    &#x2F;bin&#x2F;c++</span><br><span class="line"></span><br><span class="line">  is not a full path to an existing compiler tool.</span><br><span class="line"></span><br><span class="line">  Tell CMake where to find the compiler by setting either the environment</span><br><span class="line">  variable &quot;CXX&quot; or the CMake cache entry CMAKE_CXX_COMPILER to the full path</span><br><span class="line">  to the compiler, or to the compiler name if it is in the PATH.</span><br></pre></td></tr></table></figure>
<p> 此时需要手动恢复软链，使用<code>which gcc</code>和<code>which g++</code>确定安装位置，然后使用ln设置软链</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/g++ /bin/c++</span><br><span class="line">ln -s gcc /bin/cc</span><br></pre></td></tr></table></figure></li>
<li><p>/lib64/libstdc++.so.6: version `GLIBCXX_3.4.22’ not found</p>
</li>
</ol>
<p>  建议使用静态链接</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>编写一个简单的测试demo, 放在与leveldb根目录同级的目录下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    leveldb::DB *db;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open</span></span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;testdb&quot;</span>, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line"></span><br><span class="line">    string key = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    string value = <span class="string">&quot;shane&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;write:&quot;</span> <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span> <span class="string">&quot;=&gt;&quot;</span> <span class="string">&quot;(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;value);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;read:&quot;</span> <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span> <span class="string">&quot;=&gt;&quot;</span> <span class="string">&quot;(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete</span></span><br><span class="line">    status = db-&gt;<span class="built_in">Delete</span>(leveldb::<span class="built_in">WriteOptions</span>(), key);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span>  &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;value);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read error: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span>  &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read:&quot;</span> <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span> <span class="string">&quot;=&gt;&quot;</span> <span class="string">&quot;(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//close</span></span><br><span class="line">    <span class="keyword">delete</span> db;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令, 编译leveldb需要使用<code>-Ileveldb/include</code>引入头文件，<code>-Lleveldb/build</code>设置链库地址, <code>-lleveldb -lpthread</code> 指定要链接的库, <code>-o leveldbtest</code> 指定输出名字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ leveldbtest.cc -Ileveldb/include -Lleveldb/build -lleveldb -lpthread -o leveldbtest</span><br><span class="line">./leveldbtest </span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">write:(name)&#x3D;&gt;(shane)</span><br><span class="line">read:(name)&#x3D;&gt;(shane)</span><br><span class="line">delete:(name)OK</span><br><span class="line">read error: NotFound: (name)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kv</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
        <tag>gcc</tag>
        <tag>g++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib 多图组合显示</title>
    <url>/2020/05/28/matplotlib%E5%A4%9A%E5%9B%BE%E7%BB%84%E5%90%88%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, dpi=<span class="number">150</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].imshow(im1)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].imshow(im2)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].imshow(im3)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].imshow(im4)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>只有一行时使用一维坐标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, dpi=<span class="number">150</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(im1)</span><br><span class="line">axes[<span class="number">1</span>].imshow(im2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>ORDER BY 与 SORT BY</title>
    <url>/2022/02/28/order-by%E4%B8%8Esort-by/</url>
    <content><![CDATA[<p>一次写sql的时候，脑子发晕，把<code>order by</code>写成了<code>sort by</code></p>
<p>在spark生态中</p>
<ul>
<li><p><code>ORDER BY</code>代表每个分片内部进行排序，使用后，会发现全部数据呈现局部有序性，详情可参考<a href="https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-sortby.html">文档</a></p>
</li>
<li><p><code>SORT BY</code>代表整体排序，它保证最后返回的数据是全部有序的，详情可参考<a href="https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-orderby.html">文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>get_json_object</tag>
        <tag>hive</tag>
        <tag>spark</tag>
        <tag>presto</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf repeated 字段操作总结</title>
    <url>/2021/12/27/protobuf-repeated-%E5%AD%97%E6%AE%B5%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="基本类型复制"><a href="#基本类型复制" class="headerlink" title="基本类型复制"></a>基本类型复制</h1><p>有时会遇到源proto和目标proto具有相同成员的情况, 如果该成员仅仅是定义相同，是不能直接使用CopyFrom方法的，此时需要手动对结构体成员依次进行赋值。<br>以下文件模拟了两个不同proto文件中同时定义了相同的结构体Feature</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message ProtoSrc</span><br><span class="line">&#123;</span><br><span class="line">    message Feature</span><br><span class="line">    &#123;</span><br><span class="line">        repeated float data &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    optional Feature feature &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">message ProtoDst</span><br><span class="line">&#123;</span><br><span class="line">    message Feature</span><br><span class="line">    &#123;</span><br><span class="line">        repeated float data &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    optional Feature feature &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> src = <span class="built_in">ProtoSrc</span>();</span><br><span class="line"><span class="keyword">auto</span> dst = <span class="built_in">ProtoDst</span>();</span><br><span class="line"><span class="keyword">auto</span> srcFeature = src.<span class="built_in">feature</span>();</span><br><span class="line"><span class="keyword">auto</span> &amp;dstFeature = *dst.<span class="built_in">mutable_feature</span>();</span><br><span class="line"><span class="comment">// 👇错误操作，会有类似报错: Tried to merge messages of different types (merge protosrc.Feature to protodst.Feature)</span></span><br><span class="line"><span class="comment">// dstFeature.CopyFrom(srcFeature);</span></span><br><span class="line"><span class="comment">// 👇正确操作</span></span><br><span class="line">dstFeature.<span class="built_in">mutable_data</span>()-&gt;<span class="built_in">CopyFrom</span>(srcFeature.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>

<h1 id="复杂类型复制"><a href="#复杂类型复制" class="headerlink" title="复杂类型复制"></a>复杂类型复制</h1><p>以下文件模拟了两个不同proto文件中同时定义了相同的结构体Result</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message ProtoSrc</span><br><span class="line">&#123;</span><br><span class="line">    message Result</span><br><span class="line">    &#123;</span><br><span class="line">        optional float data &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    repeated Result results &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">message ProtoDst</span><br><span class="line">&#123;</span><br><span class="line">    message Result</span><br><span class="line">    &#123;</span><br><span class="line">        optional float data &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">    repeated Result results &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> src = <span class="built_in">ProtoSrc</span>();</span><br><span class="line"><span class="keyword">auto</span> dst = <span class="built_in">ProtoDst</span>();</span><br><span class="line"><span class="keyword">auto</span> &amp;dstRes = *(dst.<span class="built_in">mutable_results</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;srcRes : *(src.<span class="built_in">mutable_results</span>()))&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;temp = *(dstRes.<span class="built_in">Add</span>());</span><br><span class="line">    temp.<span class="built_in">set_data</span>(srcRes.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>c++</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>python import 机制</title>
    <url>/2021/08/11/python-import-%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>python中的各种import方式</p>
<span id="more"></span>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>目录结构默认如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;root&#x2F;project</span><br><span class="line">├── &#x2F;animal</span><br><span class="line">│   ├── cat.py</span><br><span class="line">│   ├── dog.py</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── main.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>animal/__init__.py</code>中内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;animal imported&quot;)</span><br><span class="line">from .cat import Cat</span><br><span class="line">from .dog import Dog</span><br></pre></td></tr></table></figure>

<p><code>animal/cat.py</code>中内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;Cat imported&quot;)</span><br><span class="line">class Cat(object):</span><br><span class="line">    def __init__(self) -&gt; None:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p>其他文件同理</p>
<h2 id="在main中进行import"><a href="#在main中进行import" class="headerlink" title="在main中进行import"></a>在main中进行import</h2><p>import时一定会执行文件夹下的<code>__init__.py</code></p>
<p><code>main.py</code>中为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import animal</span><br><span class="line"># 或</span><br><span class="line">from animal import Cat</span><br><span class="line"># 或</span><br><span class="line">from animal.cat import Cat</span><br><span class="line"># 或</span><br><span class="line">import animal.cat</span><br></pre></td></tr></table></figure>

<p>在<code>/root/project</code>下执行<code>python main.py</code></p>
<p>此时import执行步骤为<br><code>animal/__init__.py</code> -&gt; <code>animal/cat.py</code><br>输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animal imported</span><br><span class="line">Cat imported</span><br><span class="line">Dog imported</span><br></pre></td></tr></table></figure>


<h2 id="在子目录中执行-init-py"><a href="#在子目录中执行-init-py" class="headerlink" title="在子目录中执行__init__.py"></a>在子目录中执行__init__.py</h2><p>在<code>/root/project/animal</code>下执行<code>python __init__.py</code></p>
<p>会发生报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animal imported</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;__init__.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    from .cat import Cat</span><br><span class="line">ImportError: attempted relative import with no known parent package</span><br></pre></td></tr></table></figure>


<h2 id="在子目录中直接运行文件"><a href="#在子目录中直接运行文件" class="headerlink" title="在子目录中直接运行文件"></a>在子目录中直接运行文件</h2><p>有时需要在子目录中执行方便的脚本，但是这时就会遇到报错</p>
<p>此时可以通过修改sys.path来自定义搜索范围</p>
<p>首先尝试修改<code>animal/__init__.py</code>中内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from pathlib import Path</span><br><span class="line">package_root &#x3D; Path(__file__).absolute().parent.parent</span><br><span class="line">print(f&quot;animal imported, add &#123;package_root&#125; to sys.path&quot;)</span><br><span class="line">sys.path.insert(0, str(package_root))</span><br><span class="line">from animal.cat import Cat</span><br><span class="line">from animal.dog import Dog</span><br></pre></td></tr></table></figure>

<p>在<code>/root/project/animal</code>下执行<code>python __init__.py</code></p>
<p>此时输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animal imported, add &#x2F;root&#x2F;project&#x2F;python_pkg_test to sys.path</span><br><span class="line">animal imported, add &#x2F;root&#x2F;project&#x2F;python_pkg_test to sys.path</span><br><span class="line">Cat imported</span><br><span class="line">Dog imported</span><br></pre></td></tr></table></figure>

<p>可以发现print被执行了两遍，实际上所有语句都被执行了两遍，此时打印sys.path会发现存在两个<code>/root/project</code></p>
<p>所以不能直接这样设置, 首先恢复<code>animal/__init__.py</code></p>
<p>新建<code>animal/__init__.py</code>, 其中内容为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from pathlib import Path</span><br><span class="line">package_root &#x3D; Path(__file__).absolute().parent.parent</span><br><span class="line">print(f&quot;add &#123;package_root&#125; to sys.path&quot;)</span><br><span class="line">sys.path.insert(0, str(package_root))</span><br><span class="line">print(len(sys.path))</span><br></pre></td></tr></table></figure>
<p>在<code>/root/project/animal</code>下执行<code>python mian.py</code></p>
<p>此时输出为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add &#x2F;root&#x2F;project to sys.path</span><br><span class="line">[&#39;&#x2F;root&#x2F;project&#39;, &#39;&#x2F;root&#x2F;project&#x2F;animal&#39;, ...]</span><br><span class="line">animal imported</span><br><span class="line">Cat imported</span><br><span class="line">Dog imported</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>import</tag>
        <tag>from</tag>
        <tag>sys.path</tag>
      </tags>
  </entry>
  <entry>
    <title>python 删除超大目录</title>
    <url>/2021/08/11/python-%E5%88%A0%E9%99%A4%E8%B6%85%E5%A4%A7%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>通常，使用shutil.rmtree就可以轻易的删除目录，但是量变产生质变，当目录中的文件数量达到数百万时，我们需要更加快速和平稳的方式</p>
<p>优化的核心思想就是要尽可能减少一切不必要的io</p>
<span id="more"></span>

<h2 id="通常的删除过程"><a href="#通常的删除过程" class="headerlink" title="通常的删除过程"></a>通常的删除过程</h2><ol>
<li>读取目录数据，获得全部的文件</li>
<li>遍历文件，依次获得文件的创建日期等信息(sata)</li>
<li>删除满足条件的文件</li>
</ol>
<p>这样的流程看似没有问题，但是实际上在第一步就会由于读目录给系统造成极大的压力，百万级的目录光是统计一遍就会花费大量的时间。此外在第二部，连续的sata查询也会带来极大的压力。</p>
<p>此外python常用的接口包含了过多不必要的io开销，这些不必要的sata查询会导致io的次数增加数倍，让本来就很慢的过程雪上加霜。</p>
<p>例如：</p>
<ul>
<li>os.listdir：一次性读取，大目录下增加磁盘压力，并且会执行很久</li>
<li>os.walk：间隙读取，但是存在额外的sata读取开销</li>
</ul>
<p>参考：<a href="https://pythonrepo.com/repo/benhoyt-scandir-python-files">https://pythonrepo.com/repo/benhoyt-scandir-python-files</a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>读取目录数据，获得一个文件</li>
<li>获得文件的创建日期等信息(sata)</li>
<li>删除满足条件的文件</li>
<li>休眠一小段时间</li>
<li>回到第一步</li>
</ol>
<p>这样的流程有相比之前要更加平稳，读取目录和获得sata为一个一个读取，而且可以根据自己的需要灵活的休眠，面对海量文件不会把硬盘打满，给其他程序留一些io资源。</p>
<p>为了达成间断读取的目标，我们需要使用os.scandir这个接口，相比于os.walk，他会直接返回dirent的信息，而不会再去查询sata</p>
<p>以下的代码，实现了对超时文件和目录的删除，但是并没有实现休眠。</p>
<p>关于sata在不同平台上的差异，请参考：<a href="https://docs.python.org/3/library/stat.html">https://docs.python.org/3/library/stat.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line">logger = logging.info</span><br><span class="line"><span class="comment"># logger = print</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_by_ttl</span>(<span class="params">path, ttl, dry_run</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    path: 待扫描的目录</span></span><br><span class="line"><span class="string">    ttl: 文件生存时间(time to live)</span></span><br><span class="line"><span class="string">    dry_run: 是否真正进行删除操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger(<span class="string">f&quot;cleaner: path <span class="subst">&#123;path&#125;</span>, ttl: <span class="subst">&#123;ttl&#125;</span>, dry_run: <span class="subst">&#123;dry_run&#125;</span>&quot;</span>)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    now = time.time()</span><br><span class="line">    <span class="comment"># 待处理列表</span></span><br><span class="line">    process_dir = [path]</span><br><span class="line">    delete_dir = []</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(process_dir) &gt; <span class="number">0</span>:</span><br><span class="line">        logger(<span class="string">f&quot;cleaner: enter dir <span class="subst">&#123;process_dir[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> os.scandir(process_dir[<span class="number">0</span>]) <span class="keyword">as</span> it:</span><br><span class="line">            file_num = <span class="number">0</span></span><br><span class="line">            delete_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> entry <span class="keyword">in</span> it:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 统计目录下所有文件及子目录数量</span></span><br><span class="line">                file_num += <span class="number">1</span></span><br><span class="line">                life_time = now - entry.stat().st_ctime</span><br><span class="line">                <span class="keyword">if</span> life_time &lt; ttl:</span><br><span class="line">                    logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) skip <span class="subst">&#123;entry.path&#125;</span>, life_time: <span class="subst">&#123;life_time&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 统计目录下过期文件及过期子目录数量</span></span><br><span class="line">                    delete_num += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> entry.is_file():</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> dry_run:</span><br><span class="line">                            logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) delete file <span class="subst">&#123;entry.path&#125;</span>, life_time: <span class="subst">&#123;life_time&#125;</span>&quot;</span>)</span><br><span class="line">                            os.remove(entry.path)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) mock delete file <span class="subst">&#123;entry.path&#125;</span>, life_time: <span class="subst">&#123;life_time&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">elif</span> entry.is_dir():</span><br><span class="line">                        logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) discover ttl dir <span class="subst">&#123;entry.path&#125;</span>, life_time: <span class="subst">&#123;life_time&#125;</span>&quot;</span>)</span><br><span class="line">                        <span class="comment"># 过期子目录夹放进处理列表继续处理</span></span><br><span class="line">                        process_dir.append(entry.path)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目录过期，且其下所有文件及子目录均过期，且不是根目录，放进删除列表</span></span><br><span class="line">            <span class="keyword">if</span> process_dir[<span class="number">0</span>] != path:</span><br><span class="line">                <span class="keyword">if</span> file_num == delete_num:</span><br><span class="line">                    logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) determin delete dir <span class="subst">&#123;process_dir[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">                    delete_dir.append(process_dir[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 由于向文件里写文件时会修改文件夹的ctime，所以实际上走不到这个分支</span></span><br><span class="line">                    logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) ttl dir <span class="subst">&#123;entry.path&#125;</span> has unttl file, file_num: <span class="subst">&#123;file_num&#125;</span>, delete_num: <span class="subst">&#123;delete_num&#125;</span>&quot;</span>)</span><br><span class="line">            process_dir = process_dir[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment"># 从最内层文件夹开始删除文件夹，因为文件夹内所有项目均过期，此时应该已经成为空文件夹</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> <span class="built_in">reversed</span>(delete_dir):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dry_run:</span><br><span class="line">                logger(<span class="string">f&quot;cleaner: delete dir <span class="subst">&#123;<span class="built_in">dir</span>&#125;</span>&quot;</span>)</span><br><span class="line">                os.rmdir(<span class="built_in">dir</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger(<span class="string">f&quot;cleaner: mock delete dir <span class="subst">&#123;<span class="built_in">dir</span>&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger(<span class="string">f&quot;cleaner: err=<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            logger(traceback.format_exc())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sata</tag>
        <tag>超大目录</tag>
        <tag>os.listdir</tag>
        <tag>os.walk</tag>
        <tag>os.scandir</tag>
        <tag>dirent</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch GCN 实现以及使用</title>
    <url>/2020/03/05/pytorch-GCN-%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>从最为广泛和简单的理解来看, 在图上利用多个个节点数据进行计算的操作都可以称之为图网络</p>
<span id="more"></span>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>一张图由数个节点组成, 各个节点之间存在单向或双向的边。图只在概念上存在，实际上一张图由节点和邻接矩阵共同表示。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>图中的一个概念上的点, 每个点都携带着一定量的数据。例如以下数据结构, 其中每一行代表一个点, 每一行中的数字代表该点所携带的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4点, 每点包含一个5维的数据</span></span><br><span class="line">[<span class="number">0.4252</span>, <span class="number">0.2733</span>, <span class="number">0.5442</span>, <span class="number">0.7236</span>, <span class="number">0.0515</span>]</span><br><span class="line">[<span class="number">0.5121</span>, <span class="number">0.2056</span>, <span class="number">0.8560</span>, <span class="number">0.3010</span>, <span class="number">0.3110</span>]</span><br><span class="line">[<span class="number">0.0684</span>, <span class="number">0.5282</span>, <span class="number">0.8454</span>, <span class="number">0.0913</span>, <span class="number">0.9803</span>]</span><br><span class="line">[<span class="number">0.4211</span>, <span class="number">0.5779</span>, <span class="number">0.2952</span>, <span class="number">0.3368</span>, <span class="number">0.8389</span>]</span><br></pre></td></tr></table></figure>

<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵是一个 n * n 的矩阵, n 表示节点数目, 每一行都表示一个节点和其他节点是否相连。 对于一个无向图, 他的邻接矩阵总是对称的。例如以下数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4点邻接矩阵</span></span><br><span class="line">[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]</span><br></pre></td></tr></table></figure>

<p>我们观察第一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br></pre></td></tr></table></figure>

<p>表示节点0, 和节点0/2相连。</p>
<h1 id="GCN-定义"><a href="#GCN-定义" class="headerlink" title="GCN 定义"></a>GCN 定义</h1><h1 id="如何实现一个GCN模块"><a href="#如何实现一个GCN模块" class="headerlink" title="如何实现一个GCN模块"></a>如何实现一个GCN模块</h1><p>注意网络输入尺寸为<code>b*(n+c)*n</code>, 前<code>n</code>个channel构成的<code>b*n*n</code>表示邻接矩阵。后<code>b*c*n</code>表示节点数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch import nn</span><br><span class="line">class GraphConvolution(nn.Module):</span><br><span class="line"></span><br><span class="line">    def __init__(self, node_num, input_feature_num, output_feature_num, add_bias&#x3D;True, dtype&#x3D;torch.float,</span><br><span class="line">                 batch_normal&#x3D;True):</span><br><span class="line">        super().__init__()</span><br><span class="line">        # shapes</span><br><span class="line">        self.graph_num &#x3D; node_num</span><br><span class="line">        self.input_feature_num &#x3D; input_feature_num</span><br><span class="line">        self.output_feature_num &#x3D; output_feature_num</span><br><span class="line">        self.add_bias &#x3D; add_bias</span><br><span class="line">        self.batch_normal &#x3D; batch_normal</span><br><span class="line"></span><br><span class="line">        # params</span><br><span class="line">        self.weight &#x3D; nn.Parameter(torch.empty(self.output_feature_num, input_feature_num, dtype&#x3D;dtype))</span><br><span class="line">        self.bias &#x3D; nn.Parameter(torch.empty(self.output_feature_num, self.graph_num, dtype&#x3D;dtype))</span><br><span class="line">        if batch_normal:</span><br><span class="line">            self.norm &#x3D; nn.InstanceNorm1d(node_num)</span><br><span class="line">            </span><br><span class="line">    def set_trainable(self, train&#x3D;True):</span><br><span class="line">        for param in self.parameters():</span><br><span class="line">            param.requires_grad &#x3D; train</span><br><span class="line"></span><br><span class="line">    def forward(self, inp: torch.Tensor):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        @param inp : adjacent: (batch, graph_num, graph_num) cat node_feature: (batch, graph_num, in_feature_num) -&gt; (batch, graph_num, graph_num + in_feature_num)</span><br><span class="line">        @return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        b, c, n &#x3D; inp.shape</span><br><span class="line">        adjacent, node_feature &#x3D; inp[:, 0:n, :], inp[:, n:, :]</span><br><span class="line">        x &#x3D; torch.matmul(self.weight, node_feature)</span><br><span class="line">        x &#x3D; torch.matmul(x, adjacent)</span><br><span class="line">        if self.add_bias:</span><br><span class="line">            x &#x3D; x + self.bias</span><br><span class="line">        if self.batch_normal:</span><br><span class="line">            x &#x3D; self.norm(x)</span><br><span class="line"></span><br><span class="line">        return torch.cat((adjacent, x), dim&#x3D;1)</span><br></pre></td></tr></table></figure>

<h1 id="残差GCN"><a href="#残差GCN" class="headerlink" title="残差GCN"></a>残差GCN</h1><h1 id="GCN存在的问题"><a href="#GCN存在的问题" class="headerlink" title="GCN存在的问题"></a>GCN存在的问题</h1><h1 id="训练中需要注意的"><a href="#训练中需要注意的" class="headerlink" title="训练中需要注意的"></a>训练中需要注意的</h1><ol>
<li>在训练GCN时必须谨慎使用Norm方法, 否则很可能造成网络不收敛</li>
<li>GCN梯度退化较为严重, 尽量使用残差结构</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>gcn</tag>
        <tag>rsenet</tag>
        <tag>残差</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch 矩阵操作</title>
    <url>/2020/03/05/pytorch-%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="矩阵分片取坐标时超出矩阵范围"><a href="#矩阵分片取坐标时超出矩阵范围" class="headerlink" title="矩阵分片取坐标时超出矩阵范围"></a>矩阵分片取坐标时超出矩阵范围</h1><h2 id="分片出现小于0的坐标会导致赋值无效"><a href="#分片出现小于0的坐标会导致赋值无效" class="headerlink" title="分片出现小于0的坐标会导致赋值无效"></a>分片出现小于0的坐标会导致赋值无效</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y, x &#x3D; 1, 1</span><br><span class="line">nearby_mask &#x3D; torch.zeros((6, 6))</span><br><span class="line">nearby_mask[y - 2:y + 2, x - 2:x + 2] &#x3D; 1</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">[[0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.]]</span><br></pre></td></tr></table></figure>

<h2 id="分片出现大于矩阵尺度的坐标会导致部分赋值"><a href="#分片出现大于矩阵尺度的坐标会导致部分赋值" class="headerlink" title="分片出现大于矩阵尺度的坐标会导致部分赋值"></a>分片出现大于矩阵尺度的坐标会导致部分赋值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y, x &#x3D; 5, 2</span><br><span class="line">nearby_mask &#x3D; torch.zeros((6, 6))</span><br><span class="line">nearby_mask[y - 2:y + 2, x - 2:x + 2] &#x3D; 1</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">[[0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.]]</span><br></pre></td></tr></table></figure>

<h2 id="建议写法"><a href="#建议写法" class="headerlink" title="建议写法"></a>建议写法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nearby_mask[max(0, y - 2):y + 2, max(0, x - 2):x + 2] &#x3D; 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireguard 配置部署及技术讲解</title>
    <url>/2020/03/02/wireguard%E9%83%A8%E7%BD%B2%E5%8F%8A%E6%8A%80%E6%9C%AF%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.wireguard.com/">wiregurad</a>目前已经正式合入linux kernal, 日后的应用范围也一定会越来越广, 本文将会介绍如何使用wireguard创建自己的虚拟局域网, 并完成网关设置</p>
<span id="more"></span>

<h1 id="Wireguard-安装"><a href="#Wireguard-安装" class="headerlink" title="Wireguard 安装"></a>Wireguard 安装</h1><p>对于Ubuntu ≥ 19.10以上的用户, 直接安装即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install wireguard</span></span><br></pre></td></tr></table></figure>
<p>对于19.04及以下用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository ppa:wireguard/wireguard</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install wireguard</span></span><br></pre></td></tr></table></figure>

<h1 id="Wireguard-组网设置"><a href="#Wireguard-组网设置" class="headerlink" title="Wireguard 组网设置"></a>Wireguard 组网设置</h1><p>早期的教程中经常使用名为 <code>wg-quick</code> 的命令, 我个人非常不建议使用该工具, 而且官网也移除了关于此命令的相关描述, 因此接下来的操作都讲直接使用 <code>wg</code> 和 <code>ip</code> 命令完成。</p>
<p>wireguard必须在要组网的<strong>所有设备</strong>上都进行以下操作</p>
<h1 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h1><p>首先我们需要添加一块网卡, 并将其命名为 <code>wg0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link add dev wg0 <span class="built_in">type</span> wireguard</span></span><br></pre></td></tr></table></figure>

<h1 id="设置ip"><a href="#设置ip" class="headerlink" title="设置ip"></a>设置ip</h1><p>添加网卡后为这张网卡配置ip, wireguard无法使用dhcp等功能，我们必须手动为其配置ip, 并且每个设备的ip都不能重复。</p>
<p>注意此处的子网掩码。这里指定的掩码将会在之后被用于设置ip route, 通常wg会自动设置, 但我们也可以手动设置, 这在之后会进行讲解。</p>
<p>因为我需要让所有设备都连接到一台公网设备, 所以我给我的公网设备分配了<code>192.168.100.1</code>的ip。其他设备依次使用<code>192.168.100.(2/3/4)</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip address add dev wg0 192.168.100.1/24</span></span><br></pre></td></tr></table></figure>

<h1 id="生成连接密钥"><a href="#生成连接密钥" class="headerlink" title="生成连接密钥"></a>生成连接密钥</h1><p>密钥是wg连中最为重要的一环。在两个节点之间, 数据的的接受和发送都需要单独的密钥对。</p>
<p>以A, B两设备为例。A需要持有A的私钥和B的公钥。B需要持有B的私钥和A的公钥。 B向A发送数据需要使用A的公钥。A接受B的数据需要使用A的私钥。</p>
<p>因此两个节点互联共需要2对共4个密钥。注意三个节点互联需要3对共6个密钥而不是4对共8个。因为节点的公钥可以给多个其他节点使用，不需要生成新的密钥对。</p>
<h2 id="生成一对密钥"><a href="#生成一对密钥" class="headerlink" title="生成一对密钥"></a>生成一对密钥</h2><h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wg genkey</span></span><br><span class="line">6EQR4ABmq4otoOhSYVCJP4BBWKgLzIlTJ4QSPQZAR3s=</span><br></pre></td></tr></table></figure>
<h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><p>生成公钥需要使用之前的私钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 6EQR4ABmq4otoOhSYVCJP4BBWKgLzIlTJ4QSPQZAR3s= | wg pubkey</span></span><br><span class="line">eCffMZ/2nN8nPDPap5lW4K4gDRw+UANqIQIvBebvTS4=</span><br></pre></td></tr></table></figure>

<h1 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h1><p>以下以一个公网设备A和一个私网(家宽)设备B为例</p>
<h2 id="有公网ip的设备-A"><a href="#有公网ip的设备-A" class="headerlink" title="有公网ip的设备 A"></a>有公网ip的设备 A</h2><p>对于有公网ip的设备, 我们不需要指定 peer 的地址(因为存在NAT指定了也没用), 我们只需要配置私钥和连接端口即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># file: A.conf</span><br><span class="line">[Interface]</span><br><span class="line"># Interface on A</span><br><span class="line">PrivateKey &#x3D; &lt;A的私钥&gt;</span><br><span class="line">ListenPort &#x3D; 10240</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line"># A to B</span><br><span class="line">PublicKey &#x3D; &lt;B的公钥&gt;</span><br><span class="line">AllowedIPs &#x3D; 192.168.100.2&#x2F;32</span><br><span class="line">PersistentKeepalive &#x3D; 10</span><br></pre></td></tr></table></figure>

<h2 id="无公网ip设备-B"><a href="#无公网ip设备-B" class="headerlink" title="无公网ip设备 B"></a>无公网ip设备 B</h2><p>对于有无公网ip的设备, 需要使用<code>Endpoint</code>指定 peer A 的地址, 这样才能在 A, B 之间建立起链接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># file: B.conf</span><br><span class="line">[Interface]</span><br><span class="line"># Interface on B</span><br><span class="line">PrivateKey &#x3D; &lt;B的私钥&gt;</span><br><span class="line">ListenPort &#x3D; 51820</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line"># B to A</span><br><span class="line">PublicKey &#x3D; &lt;A的公钥&gt;</span><br><span class="line">Endpoint &#x3D; &lt;A的公网ip:10240&gt;</span><br><span class="line">AllowedIPs &#x3D; 192.168.100.0&#x2F;24</span><br><span class="line">PersistentKeepalive &#x3D; 10</span><br></pre></td></tr></table></figure>

<h2 id="AllowedIPs"><a href="#AllowedIPs" class="headerlink" title="AllowedIPs"></a>AllowedIPs</h2><p>需要注意两份配置的 AllowedIPs 不同, 对于A来说, peer B 的地址必须为<code>192.168.100.2/32</code>, 而对于B来说, 局域网中的所有 peer 都需要通过A来访问, 所以 AllowedIPs 被设置为 <code>192.168.100.0/24</code>。 </p>
<p>AllowedIPs类似于一个白名单机制, 只有目的地址在AllowedIPs中的包才允许发往该 peer。</p>
<h2 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo wg setconf wg0 xxxx.conf</span></span><br></pre></td></tr></table></figure>

<h1 id="启用网卡"><a href="#启用网卡" class="headerlink" title="启用网卡"></a>启用网卡</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> up dev wg0</span></span><br></pre></td></tr></table></figure>

<h1 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h1><p>创建网卡之后, 我们还需要设置路由, 告诉系统使用wg0网卡处理发往192.168.100.0/24地址的数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip route add 192.168.100.0/24 dev wg0</span></span><br></pre></td></tr></table></figure>

<p>或者使用完整写法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip route add 192.168.100.0/24 dev wg0 proto kernel scope link src 192.168.100.x</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 192.168.100.x 指本机ip</span></span><br></pre></td></tr></table></figure>

<p>如果设置的时候提示 <code>RTNETLINK answers: File exists</code> 则表示wg已经自动设置过路由。可以使用以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip route</span> </span><br><span class="line">default via 192.168.1.1 dev enp6s0 proto dhcp src 192.168.1.4 metric 100</span><br><span class="line">192.168.100.0/24 dev wg0 proto kernel scope link src 192.168.100.2</span><br></pre></td></tr></table></figure>

<h1 id="查看连接状态"><a href="#查看连接状态" class="headerlink" title="查看连接状态"></a>查看连接状态</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo wg</span></span><br><span class="line">interface: wg0</span><br><span class="line">  public key: SaarEV3HLvcAaaLhorieaaalNMhCaaaxqVmIpmKwjWY=</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 10240</span><br><span class="line"></span><br><span class="line">peer: taaSMAMx4fMaaXfd1g4Z/c+AaapQRapYnStJ/wVFNjk=</span><br><span class="line">  endpoint: 111.20.8.222:51820</span><br><span class="line">  allowed ips: 192.168.100.2/32</span><br><span class="line">  latest handshake: 1 minute, 48 seconds ago</span><br><span class="line">  transfer: 256.64 KiB received, 200.38 KiB sent</span><br><span class="line">  persistent keepalive: every 10 seconds</span><br></pre></td></tr></table></figure>

<h1 id="网关设置"><a href="#网关设置" class="headerlink" title="网关设置"></a>网关设置</h1><p>请查看iptables forward 及 nat 相关讲解</p>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>route</tag>
        <tag>wireguard</tag>
        <tag>network</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>word文档参考文献按引用顺序自动调整编号</title>
    <url>/2022/05/09/word%E6%96%87%E6%A1%A3%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%8C%89%E5%BC%95%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E7%BC%96%E5%8F%B7/</url>
    <content><![CDATA[<p>最近在写毕业论文，因为不断的修改添加了大量了引用，导致编号非常混乱，显得非常不美观，</p>
<p>又恰逢女朋友学校强制要求引用目录按照引用顺序排序，因此不得已开发了一个程序来对引用进行自动编号，</p>
<p>开发过程一波三折，难度也比一开始的设想大了很多，</p>
<p>因为需要处理书签引用和纯手写的引用，本来是想使用PyDocX的，测试后发现PyDocX读取书签引用有问题，</p>
<p>最后只能手写个简单的代码解析docx，虽然很麻烦但是总算是搞定了。</p>
<p>项目地址：<a href="https://github.com/Casxt/SortReference">https://github.com/Casxt/SortReference</a></p>
<span id="more"></span>

<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://raw.githubusercontent.com/Casxt/SortReference/main/img/demo.jpg" alt="demo" title="demo"></p>
<h2 id="支持的场景"><a href="#支持的场景" class="headerlink" title="支持的场景"></a>支持的场景</h2><p>请确保文件中中有且只有<code>[n]</code>这一种引用格式，<code>[1-3]</code>或 <code>[1,2,3]</code>等形式需要统一改写成<code>[1][2][3]</code>。</p>
<p>请确保word中所有形如<code>[n]</code>的字符串均代表引用。</p>
<p>否则这些字符也会被计入引用而被错误的改写，如果有的话可以先把不代表引用的字符替换为其他格式比如<code>&lt;n&gt;</code>等到程序处理完后再改写回来。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先确保已经安装python3.6或更高版本。</p>
<ol>
<li><p>使用 pip 安装依赖</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pip install sort_reference</span><br></pre></td></tr></table></figure></li>
<li><p>指定输入输出文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m sort_reference [input] [output] </span><br></pre></td></tr></table></figure>
<p> 如：<code>python -m sort_reference testcase/paper.docx testcase/processed_paper.docx</code></p>
</li>
<li><p>手动处理引用目录顺序</p>
<p> 最后的引用目录重新编号后会如效果图的右图所示，因为word文档结构太复杂了，没法自动对引用目录排序，所以执行完后需要手动调整一下目录顺序。</p>
</li>
</ol>
<p><strong>如果有报错请看github主页里的报错处理方案，大部分时候简单修改一下文档就能解决掉</strong></p>
]]></content>
      <categories>
        <category>word</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一个新奇的国产web引擎————YC编译器</title>
    <url>/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    <content><![CDATA[<p>最近在网上听说了一个国产的“浏览器”叫做YC浏览器，说是已经开发了好几年了，能把c++像js一样跑。</p>
<p>这种话一听就不靠谱嘛，微软这么大家业也不搞浏览器了。</p>
<p>抱着好奇心我打开了他们的官网：<a href="http://www.ycbro.com/">http://www.ycbro.com/</a>, 一看果然是编译器嘛不是什么浏览器 (然而编译器也没比浏览器简单多少…)。</p>
<p>反正软件也不大，抱着试试玩的心态，我也下了一个看看。</p>
<span id="more"></span>

<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>安装完成后看到两个快捷方式， “YC服务器 D__ycc” 和 “YC编译器 D__ycc”。</p>
<p>打开YC服务器可以看到一个非常复古的界面</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/1.jpg" class="" title="yc服务器界面 200"> </div>

<p>界面上的按钮我都点了一下，没啥用。</p>
<p>经过一番操作呢，我在他们安装目录下发现了一些模板的ysp文件，估计是文件名改了之后没有调整界面上的链接, 直接在浏览器输入路径, 这次成功的打开了<code>http://127.0.0.1/daoshi_info.ysp</code></p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/2.jpg" class="" title="导师信息界面 200"> </div>

<p>提示要安装access, 我比较偷懒就不安了。</p>
<h1 id="上传功能"><a href="#上传功能" class="headerlink" title="上传功能"></a>上传功能</h1><p>经过一番搜索我终于找到了一个功能还比较齐全的页面，也不需要数据库<code>http://127.0.0.1/upload.ysp</code>，有趣的是第一次访问还报错了404，过了一会再次访问就成功了，不禁让人想到这页面可能是动态编译的。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/3.jpg" class="" title="上传界面 200"> </div>

<p>随手上传了两个文件，页面功能还算正常，不过这些都是传统的js功能，并没有什么意思</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/4.jpg" class="" title="上传界面上传后 200"> </div>


<h1 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h1><p>yc还贴心的为我们提供了开发ide，虽然界面略显过时，但是也能看出开发者确实是在自己一点点打磨的，不然直接依托vscode搞一个ide会更香。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/6.jpg" class="" title="ide 200"> </div>

<p>这个ide甚至可以编辑二进制文件，难道这些开发者喜欢手写机器码吗</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/7.jpg" class="" title="二进制编辑 200"> </div>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>打开yc源码目录，可以看到很多ysp文件和cpp文件，一入眼就是一堆avx，略显硬核</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/5.jpg" class="" title="源码 200"> </div>

<p>我打开了<code>sea.ysp</code>, 映入眼帘的是一堆c风格的代码，不过按照ysp的介绍应该是支持cpp的。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/8.jpg" class="" title="sea.ysp 200"> </div>

<p>可以看出在ysp中prinft类似于php中的echo，用于在页面上输出元素。</p>
<p>顺便该页面的输出效果如下</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/9.jpg" class="" title="sea.ysp页面 200"> </div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>yc可以说是当代浮躁的代码界的一股清流，制作者不为外界所扰，潜心制作了一款cpp版php，虽然在当前的技术环境下很难说ycc能有多大的空间去施展拳脚，但至少从这个项目中可以看出老一辈程序员深厚的编程功底和耐得住寂寞的开发精神。</p>
]]></content>
      <categories>
        <category>大开眼界</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>php</tag>
        <tag>yc</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划相关题目</title>
    <url>/2021/05/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>动态规划类题目笔记</p>
<span id="more"></span>

<h1 id="买卖K次股票"><a href="#买卖K次股票" class="headerlink" title="买卖K次股票"></a>买卖K次股票</h1><p>假设当前天数为i，股价为p。</p>
<p>若此前一直不进行买卖，其最优利润为<code>dp[0] = 0</code>。</p>
<p>若此前只做过1次买入操作，且最优利润为<code>dp[1]</code>，考虑到今天的股价p。<br>则前i天只做过1次买入操作的最优利润为<code>max(dp[1], dp[0]-p)</code>。<code>dp[0]-p</code>表示如果以此前的最优无操作利润，在今天买入可获得的利润。</p>
<p>若此前只做过1次买入1次卖出操作，且最优利润为<code>dp[2]</code>，考虑到今天的股价p。<br>则前i天只做过1次买入1次卖出操作的最优利润为<code>max(dp[2], dp[1]+p)</code>。<code>dp[1]+p</code>表示如果以此前的最优1次买入的最优利润在今天卖出可获得的总利润。<code>dp[1]+p</code>更大则表示考虑到今天的价格，在今天卖出更合适。</p>
<p>若此前只做过2次买入1次卖出操作，且最优利润为<code>dp[3]</code>，考虑到今天的股价p。<br>则前i天只做过2次买入1次卖出操作的最优利润为<code>max(dp[3], dp[2]-p)</code>。<code>dp[2]-p</code>表示如果以此前的最优1次买入1次卖出可得利润的基础上，如果在今天买入可获得的利润。<code>dp[2]-p</code>更大则表示考虑到之前的买卖价格和今天的价格，在今天进行第2次买入要比在之前买入更合适。</p>
<p>若此前只做过2次买入2次卖出操作，且最优利润为<code>dp[4]</code>，考虑到今天的股价p。<br>则前i天只做过2次买入1次卖出操作的最优利润为<code>max(dp[4], dp[3]+p)</code>。<code>dp[3]+p</code>表示如果以此前的最优2次买入1次卖出的最优利润，在今天卖出可获得的总利润。<code>dp[3]+p</code>更大则表示考虑到今天的价格，在今天卖出更合适。</p>
<p>… …</p>
<h1 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h1><p><a href="https://leetcode-cn.com/problems/burst-balloons/">https://leetcode-cn.com/problems/burst-balloons/</a></p>
<p>使用逆向思维，从戳气球变为安置气球，对于区间[i,j]，遍历[i+1,j-1], 假设每一个位置k为第一插入气球，然后其值加上[i,k]和[k,j]的最优结果。</p>
<p>所有的k中，值最大的即为[i,j]中的最优结果。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>堆相关知识点</title>
    <url>/2021/05/03/%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>堆类题目堆相关知识点</p>
<span id="more"></span>

<h1 id="golang-最小堆实现"><a href="#golang-最小堆实现" class="headerlink" title="golang 最小堆实现"></a>golang 最小堆实现</h1><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/submissions/">https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/submissions/</a></p>
<p>参考 <a href="https://ieevee.com/tech/2018/01/29/go-heap.html#2-containerheap%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95">https://ieevee.com/tech/2018/01/29/go-heap.html#2-containerheap%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95</a></p>
<p>container/heap</p>
<p>4.1 heap.Init</p>
<p>4.2 heap.Push</p>
<p>4.3 heap.Pop</p>
<p>4.4 heap.Fix</p>
<p>4.5 heap.Remove</p>
<p>实现</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> KthLargest <span class="keyword">struct</span> &#123;</span><br><span class="line">    sort.IntSlice</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IntSlice类型替我们实现了</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func (h KthLargest) Len() int           &#123; return len(h) &#125;</span></span><br><span class="line"><span class="comment">func (h KthLargest) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125;</span></span><br><span class="line"><span class="comment">func (h KthLargest) Swap(i, j int)      &#123; h[i], h[j] = h[j], h[i] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// add x as element Len()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    kl.IntSlice = <span class="built_in">append</span>(kl.IntSlice, v.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// !!注意此处Pop的实现，由于golang heap库在调用heap.Pop方法时，先把元素和最后一个节点的值交换，然后弹出，然后调用 down。因此我们自己实现的方法接收到Pop时，需要被pop的元素实际已经被放置到队尾了</span></span><br><span class="line"><span class="comment">// remove and return element Len() - 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    a := kl.IntSlice</span><br><span class="line">    v := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    kl.IntSlice = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// heap.Push(kl, val)</span></span><br><span class="line"><span class="comment">// val = heap.Pop(kl)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>知识点速查</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>堆相关题目</title>
    <url>/2021/05/03/%E5%A0%86%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>堆类相关题目</p>
<span id="more"></span>

<h1 id="连续中值"><a href="#连续中值" class="headerlink" title="连续中值"></a>连续中值</h1><p>将半段数字放于一个小根堆，后半段放入大根堆</p>
<p>取小根堆和大根堆的堆顶即可推导出中位数</p>
<p>实际操作时，ruo</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>子序列相关题目</title>
    <url>/2021/05/03/%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>子序列类相关题目</p>
<span id="more"></span>

<h1 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
<p>若nums的前n-1个元素的最大子序列和为M</p>
<p>nums的第N个元素为X</p>
<p>则nums的前n个元素的最大子序列和为max(M+X, X)</p>
<p>以此进行动态规划。</p>
<h1 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h1><p>模拟出入栈即可<br>字符串操作</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">paths := strings.Split(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">s := <span class="string">&quot;/&quot;</span> + strings.Join(stack, <span class="string">&quot;/&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相关题目</title>
    <url>/2021/05/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>字符串类相关题目</p>
<span id="more"></span>

<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
<p>动态规划</p>
<p>已知以位置i-1结束的最长不重复串长为x, 若i处字符到其上一次出现的位置长为n</p>
<p>若 n &gt; x, 则 以位置i结束的最长不重复串长为x+1</p>
<p>若 n &lt;= x, 则 以位置i结束的最长不重复串长为n</p>
<h1 id="验证IP地址"><a href="#验证IP地址" class="headerlink" title="验证IP地址"></a>验证IP地址</h1><p><a href="https://leetcode-cn.com/problems/validate-ip-address/">https://leetcode-cn.com/problems/validate-ip-address/</a></p>
<p>10进制字符串转int<br>n, err := strconv.ParseInt(s, 10, 32)</p>
<p>16进制字符串转int<br>n, err := strconv.ParseInt(s, 16, 32)</p>
<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><p><a href="https://leetcode-cn.com/problems/group-anagrams/">https://leetcode-cn.com/problems/group-anagrams/</a></p>
<p>字符串排序hash</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">code</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">byte</span>(str)</span><br><span class="line">    sort.Slice(s, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;)</span><br><span class="line">    sortedStr := <span class="keyword">string</span>(s)</span><br><span class="line">    <span class="keyword">return</span> sortedStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">https://leetcode-cn.com/problems/minimum-window-substring/</a></p>
<p>双指针法，不匹配时右移右指针，匹配时记录最短串，并右移左指针。</p>
<p>直到右指针达到末尾并且不匹配</p>
<h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h1><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p>
<p>使用双指针标记窗口，移动窗口依次比较。</p>
<p>使用26长数组代替字典。</p>
<p>进阶：</p>
<p>每次移入元素使得字典某字母数量匹配目标数量，使match++</p>
<p>每次移出元素使得字典某字母数量从匹配目标数量变为不匹配，使match–</p>
<p>当match等于元素种类时，记录当前窗口起始位置</p>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p>
<p>递归遍历</p>
<p>每层选择一个位置i</p>
<p>如果i到达序列尾部，则记录结果，否则</p>
<p>依次将i 与 j([i, len])位置处的数据交换。</p>
<p>如果位置j处的数据在此层之前([i, j-1])出现过，则跳过到下一位置</p>
<p>交换数据后进行递归，从位置i+1开始</p>
<p>递归结束后再次交换，恢复序列，并循环下一j。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>手动挂载Nvidia显卡到docker容器中</title>
    <url>/2020/03/29/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDNvidia%E6%98%BE%E5%8D%A1%E5%88%B0docker%E5%AE%B9%E5%99%A8%E4%B8%AD/</url>
    <content><![CDATA[<p>在docker使用显卡往往需要nvidia的nvidia-container驱动，本文将叫你如何使用原生docker挂载显卡。<br>虽然在最新版的docker中已经内置了nvidia驱动，但是对于podman等其他容器管理来说，这套方法依旧是有意义的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run -it --rm \</span><br><span class="line">--device /dev/nvidia-uvm:/dev/nvidia-uvm:rwm \</span><br><span class="line">--device /dev/nvidia-uvm-tools:/dev/nvidia-uvm-tools:rwm \</span><br><span class="line">--device /dev/nvidia0:/dev/nvidia0:rwm \</span><br><span class="line">--device /dev/nvidiactl:/dev/nvidiactl:rwm \</span><br><span class="line">-v /usr/bin/nvidia-smi:/usr/bin/nvidia-smi:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:ro \</span><br><span class="line">ubuntu nvidia-smi</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h1><p>需要映射到容器中的控制设备包括</p>
<ul>
<li>/dev/nvidia-uvm</li>
<li>/dev/nvidia-uvm-tools</li>
<li>/dev/nvidiactl</li>
</ul>
<p>需要映射到容器中的显卡</p>
<ul>
<li>/dev/nvidia0</li>
<li>/dev/nvidia1</li>
</ul>
<p>可以根据需要自行增减数量，显卡编号从0开始，自动增加，nvidia0/nvidia1/nvidia2等等</p>
<h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><p>需要将nvidia驱动映射入容器</p>
<ul>
<li>/usr/bin/nvidia-smi</li>
<li>/usr/lib/x86_64-linux-gnu</li>
</ul>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>对于我们一开始的命令，其输出是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sun Mar 29 06:58:45 2020</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 440.33.01    Driver Version: 440.33.01    CUDA Version: 10.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage&#x2F;Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</span><br><span class="line">|   0  GeForce RTX 208...  Off  | 00000000:AF:00.0 Off |                  N&#x2F;A |</span><br><span class="line">|  0%   25C    P8    15W &#x2F; 260W |      0MiB &#x2F; 11019MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>device</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>数学相关题目</title>
    <url>/2021/05/03/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>数学类相关题目</p>
<span id="more"></span>

<h1 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h1><p><a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p>
<p>考虑数字为4的情况，最大结果为2<em>2<br>考虑数字为5的情况，最大结果为2</em>3<br>考虑数字为6的情况，最大结果为3<em>3<br>考虑数字为7的情况，最大结果为3</em>2<em>2<br>考虑数字为8的情况，最大结果为3</em>3*2<br>所有大于3的数字一定可由2和3相加得到，归纳可证，需要将数字尽可能拆分为3相加</p>
<p>根据 n 除以 3 的余数进行分类讨论：</p>
<p>如果余数为 0，拆分为 n//3个3</p>
<p>如果余数为 1，拆分为 (n//3)-1 个 3和1个4</p>
<p>如果余数为 2，拆分为 n//3 个 3和1个2</p>
<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p>
<p>较为复杂，多复习</p>
<p>不断将位置i和赋值给i+k,直到回到i</p>
<p>从i+1开始重复上述过程</p>
<p>直到处理过的数字和数组长度相等</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组相关题目</title>
    <url>/2021/05/03/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>数组类相关题目</p>
<span id="more"></span>

<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p>
<p>二分之后，必有一边是有序的(因为全局只有一个间断点，该点只能出现于一侧)。检查target是否坐落于有序一侧，如果不位于有序一侧，则一定位于无序一侧。</p>
<p>target取位于的那一侧继续迭代</p>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">https://leetcode-cn.com/problems/first-missing-positive/</a></p>
<p>观察可知，题目所求正数不超过数组长度+1</p>
<p>遍历每一个位置，将该位置上的值x与位置x-1上的值y交换，重复交换直到x == y或 x &lt; 0 或 x &gt; 数组长度。</p>
<p>之后继续下一个位置</p>
<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>寻找左边界和有边界，二分条件大于小于情况照常处理，等于时，如果寻找左边界，则取左区间，反之右区间。</p>
<p>每次mid==target时记录最新的值</p>
<p>循环的s &gt; e 时跳出。</p>
<p>此时的最新mid值即为边界。</p>
<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>
<p>贪心算法，构建队列，遍历数字，当数字大于队尾，则增加该数字，否则，找到第一个大于该数字的元素，修改为该数字。</p>
<p>通过二分查找加速</p>
<p>sort search会返回最小的满足true条件的位置，否则返回len(list)，注意函数中大于等于条件。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">idx := sort.Search(<span class="built_in">len</span>(list), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> list[i] &gt;= n&#125;)</span><br><span class="line"><span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(list) &#123;</span><br><span class="line">    list[idx] = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>树相关知识点</title>
    <url>/2021/05/03/%E6%A0%91%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>树类题目相关知识点</p>
<span id="more"></span>

<h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><p>直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
<h1 id="完全二叉树和满二叉树的区别"><a href="#完全二叉树和满二叉树的区别" class="headerlink" title="完全二叉树和满二叉树的区别"></a>完全二叉树和满二叉树的区别</h1><p>完全二叉树: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边。</p>
<p>满二叉树: 除最后一层无任何子 节点 外，每一层上的所有结点都有两个子结点</p>
<h1 id="前中后层序遍历"><a href="#前中后层序遍历" class="headerlink" title="前中后层序遍历"></a>前中后层序遍历</h1><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<h1 id="求和路径"><a href="#求和路径" class="headerlink" title="求和路径"></a>求和路径</h1><p><a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">https://leetcode-cn.com/problems/paths-with-sum-lcci/</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">https://leetcode-cn.com/problems/path-sum-iii/</a></p>
<p>通过记录前缀和并搜索的方式快速求解</p>
<h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p>
<p>每一个节点可以延伸出26路支路代表26个字母的树。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>知识点速查</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>树相关题目</title>
    <url>/2021/05/03/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>树类相关题目</p>
<span id="more"></span>

<h1 id="检查子树"><a href="#检查子树" class="headerlink" title="检查子树"></a>检查子树</h1><p><a href="https://leetcode-cn.com/problems/check-subtree-lcci/">https://leetcode-cn.com/problems/check-subtree-lcci/</a></p>
<p>递归比较，以每一个节点为头，比较2树是否相同即可</p>
<h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
<p>经过某一结点的最长路径为 左子树高度+右子树高度</p>
<p>遍历每一个树中每一个节点，求得其左右子树高度并计算路径，取最大值作为树的直径</p>
<h1 id="完全二叉树的最后一层的最后一个节点"><a href="#完全二叉树的最后一层的最后一个节点" class="headerlink" title="完全二叉树的最后一层的最后一个节点"></a>完全二叉树的最后一层的最后一个节点</h1><p><a href="https://blog.csdn.net/fangjian1204/article/details/39179343">https://blog.csdn.net/fangjian1204/article/details/39179343</a></p>
<p>先计算树的高度，由于是完全二叉树，左节点遍历到底得到树高h。</p>
<p>之后进入算法</p>
<p>从根节点开始</p>
<p>若h==2，返回当前节点右，左中第一个非空的。</p>
<p>计算右子树高度，若高h，以右节点为根节点重新开始，否则以左节点为根节点重新开始。并令h-1</p>
<h1 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/submissions/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/submissions/</a></p>
<p>压栈法循环取出层</p>
<p>因为之字形打印，倒序遍历上一层，并根据需要按照从右到左或从左到右的顺序压节点</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>模型转换时打包归一化预处理操作</title>
    <url>/2021/12/09/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E6%89%93%E5%8C%85%E5%BD%92%E4%B8%80%E5%8C%96%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>在部署模型时，对于输入数据的预处理是一个非常耗时的操作，其实可以将预处理一同打包到模型中，在转换为ONNX或者Tensorrt模型后这些操作就可以随着模型一起被加速执行。</p>
<p>以最简单的归一化操作为例</p>
<p>归一化Module如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Normalize(torch.nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.register_buffer(&#39;mean&#39;, torch.tensor([0.485, 0.456, 0.406], dtype&#x3D;torch.float64).view(1, -1, 1, 1))</span><br><span class="line">        self.register_buffer(&#39;std&#39;, torch.tensor([0.229, 0.224, 0.225], dtype&#x3D;torch.float64).view(1, -1, 1, 1))</span><br><span class="line">        self.register_buffer(&#39;norm&#39;, torch.tensor([255.0], dtype&#x3D;torch.float64).view(1, 1, 1, 1))</span><br><span class="line"></span><br><span class="line">    def forward(self, images):</span><br><span class="line">        return (images &#x2F; self.norm - self.mean) &#x2F; self.std</span><br></pre></td></tr></table></figure>

<p>之后修改模型的inti和forward函数即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyModel(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(MyModel, self).__init__()</span><br><span class="line">        # ... other code</span><br><span class="line">        self.normalize &#x3D; Normalize()</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x &#x3D; self.normalize(x)</span><br><span class="line">        # ... other code</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>归一化</tag>
        <tag>预处理</tag>
        <tag>Normalize</tag>
        <tag>ONNX</tag>
        <tag>Tensorrt</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点扫盲</title>
    <url>/2020/03/02/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="linux用户登录流程"><a href="#linux用户登录流程" class="headerlink" title="linux用户登录流程"></a>linux用户登录流程</h1><ul>
<li>init 阶段， 读/etc/inittab -&gt; /etc/rc.local</li>
<li>getty 用于监听本地consloe, 打出username:, 获得用户输入之后调起/ets/login打出password:</li>
<li>读/etc/passwd /etc/shadow 检查用户密码</li>
<li>拉起shell</li>
<li>读/etc/passwd 获取用户目录等信息，读/etc/motd获取欢迎界面</li>
<li>读/etc/profile -&gt; /etc/bashrc -&gt; .profile 或 .login</li>
<li>读.bashrc, .bash_profile</li>
</ul>
<h1 id="locked-page-memory"><a href="#locked-page-memory" class="headerlink" title="locked page memory"></a>locked page memory</h1><h1 id="cgroup-使用"><a href="#cgroup-使用" class="headerlink" title="cgroup 使用"></a>cgroup 使用</h1><h1 id="数据库隔离机制"><a href="#数据库隔离机制" class="headerlink" title="数据库隔离机制"></a>数据库隔离机制</h1><h1 id="ssh-登录机制"><a href="#ssh-登录机制" class="headerlink" title="ssh 登录机制"></a>ssh 登录机制</h1><h2 id="ssh-与-tty-ptmx-pts"><a href="#ssh-与-tty-ptmx-pts" class="headerlink" title="ssh 与 tty ptmx pts"></a>ssh 与 tty ptmx pts</h2><p><a href="https://segmentfault.com/a/1190000009082089">https://segmentfault.com/a/1190000009082089</a></p>
<h2 id="ssh-与-tls"><a href="#ssh-与-tls" class="headerlink" title="ssh 与 tls"></a>ssh 与 tls</h2><ul>
<li>ssh验证双方，tls只验证服务端</li>
<li>ssh在应用层，tls在传输层</li>
<li>ssh同时完成验证和加密，tls可以不验证只加密</li>
</ul>
<h1 id="shm"><a href="#shm" class="headerlink" title="shm"></a>shm</h1><h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><h1 id="cuda-engine-context-stream"><a href="#cuda-engine-context-stream" class="headerlink" title="cuda engine context stream"></a>cuda engine context stream</h1><p>engine是trt中的概念</p>
<p>context 是一个执行上下文，保存了各种状态，可以用push和pop方法出入栈，每个进程执行时必须要有一个context，通常每一个thread会分配一个独立的context</p>
<h2 id="同一卡上能否同时存在两个context？"><a href="#同一卡上能否同时存在两个context？" class="headerlink" title="同一卡上能否同时存在两个context？"></a>同一卡上能否同时存在两个context？</h2><p>stream 代表了一系列gpu任务，包括内存拷贝，执行等，同一个context下可以有多个stream，stream之间可以并行运行，stream执行结束后可以触发回调</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="b-tree-为什么快"><a href="#b-tree-为什么快" class="headerlink" title="b+tree 为什么快"></a>b+tree 为什么快</h2><h2 id="索引可以加在text上吗"><a href="#索引可以加在text上吗" class="headerlink" title="索引可以加在text上吗"></a>索引可以加在text上吗</h2><h1 id="四次挥手的合并"><a href="#四次挥手的合并" class="headerlink" title="四次挥手的合并"></a>四次挥手的合并</h1><p>客户端主动发起fin，如果服务端不需要回复对应的ack会出现如下情况。<br>情况1：</p>
<ol>
<li>客户端发起fin，服务端未收到</li>
<li>客户端停止发送数据，并开始等待服务端剩余数据和fin</li>
<li>服务端不知道客户端已经发送fin，发送完当前数据后，开始等待客户端数据</li>
<li>服务端和客户端互相等待无法脱出。</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵相关题目</title>
    <url>/2021/05/03/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>矩阵类相关题目</p>
<span id="more"></span>

<h1 id="螺旋矩阵-回形打印二维数组"><a href="#螺旋矩阵-回形打印二维数组" class="headerlink" title="螺旋矩阵 回形打印二维数组"></a>螺旋矩阵 回形打印二维数组</h1><p><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/">https://leetcode-cn.com/problems/spiral-matrix/solution/</a></p>
<p>使用四个循环依次打印四条边即可，使用计数器记录已经访问过的元素数目。</p>
<p>在打印上边和右边之后以及打印四条边之后判断计数器即可。</p>
<p>如果记不住，每条边打印前都判断一次也可</p>
<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p>
<p>从左上角开始沿一条边逐个访问元素，</p>
<p>每个元素和其他四条边中相对起始位置相同的元素交换</p>
<p>他四条边中相对起始位置相同的元素坐标可以推算出来</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次libc损坏的惊险经历</title>
    <url>/2021/12/19/%E8%AE%B0%E4%B8%80%E6%AC%A1libc%E6%8D%9F%E5%9D%8F%E7%9A%84%E6%83%8A%E9%99%A9%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>最近看到知乎上，关于最让自己印象深刻的一次bug的经历，的讨论，不禁让我回想起了研一时，那一次libc依赖损坏的事故。</p>
<span id="more"></span>

<p>当时需要在断网服务器集群上部署一个caffe程序，负责部署的同学跟我说他的程序需要升级libc，我并未多想，给他的账号开通root权限后让他自行操作(我以为他会使用yum安装)。</p>
<p>许久之后，他突然找到我说，服务器崩溃了，ssh无法连接，我立刻新建了一个ssh测试了一下，果然出了错误，我的心一下子就揪了起来，因为此时我还无法确定ssh崩溃的原因是什么，如果只是配置文件的问题还好说，如果是系统问题那麻烦就大了。</p>
<p>当时我非常慌张，这台服务器上已经配置了许多服务，如果此时重装服务器，之前的努力将会前功尽弃，而且重装需要专人上门配置，如此一来工期就会大大拖延，我用最短的时间跟他确认了在崩溃之前进行的操作，在一大通对账之后，我惊讶的发现他自己编译出libc并直接使用make install安装到了系统里，由于一些现在已经不可考据的原因跟系统不兼容，大部分命令已经无法使用了。</p>
<p>当时的情况是原系统中/lib64/libc.so.6软链到/lib64/libc-2.12.so，被手动make install之后软链变成了指向/lib64/libc-2.23.so，之后大量的命令无法使用</p>
<p>报错类似于<code>error while loading shared libraries: __vdso_time: invalid mode for dlopen(): Invalid argument</code></p>
<p>万幸的是手上当时还有一个ssh连接没有关闭，我冷静下来，使用LD_PRELOAD=/lib64/libc-2.12.so [cmd]进行尝试，发现还可以恢复这部分命令。最后在小心翼翼的恢复了软链之后，又从集群中的其他机器上复制了根目录下的文件进行替换，才彻底解决了这次事件，之后我第一时间下掉了他的root权限，并告知他以后他的libc依赖只能自己指定环境变量来加载。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次rpc接口无返回调试经历</title>
    <url>/2022/03/18/%E8%AE%B0%E4%B8%80%E6%AC%A1rpc%E6%8E%A5%E5%8F%A3%E6%97%A0%E8%BF%94%E5%9B%9E%E8%B0%83%E8%AF%95%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h1 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h1><p>偶然发现一个线上服务不返回的badcase，在输入特定一张图片时，分析服务会直接断开连接而不返回任何数据，这种情况是非常罕见的，因为通常来说即便是内部服务报错的情况下，也会被框架捕获从而返回一组错误码，而不会直接断开连接不返回任何数据。</p>
<h1 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h1><p>考虑到这个现象可以被特定数据触发，且触发后业务依旧可以正常处理后续请求，因此认为是业务逻辑的问题，但是还不清楚业务逻辑是如何影响框架导致连接被关闭的。</p>
<h1 id="初步调试"><a href="#初步调试" class="headerlink" title="初步调试"></a>初步调试</h1><p>现象能稳定复现，应该是比较容易调试的，我首先将一台线上服务熔断，手动登录后打开日志调试。</p>
<p>请求后惊奇的发现业务逻辑<code>没有任何报错</code>，由于业务逻辑不是我写的，所以整个逻辑对我来说如同黑箱一样。</p>
<p>为了找到问题的原因，我将一张正常图片产生的日志和问题图片产生的日志都记录下来，并逐行对比，遗憾的是<code>没有发现任何不同</code>。</p>
<h1 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h1><p>到这一步已经是山穷水尽了，因为通过日志打点分析，整个业务逻辑是正常return的，现在只能将目光转向框架层，但是遗憾的是框架层同样是一个黑箱，并且通过分析框架层的日志，也没有发现任何异常。</p>
<p>结合连接直接断开的现象，我怀疑框架层中的worker在返回请求时崩溃，并且被自动重启了。而导致崩溃的原因，只能是在业务逻辑中返回的response结构体上。</p>
<p>大胆猜测，是返回值被设置了特殊值导致框架层崩溃的。</p>
<h1 id="再次调试"><a href="#再次调试" class="headerlink" title="再次调试"></a>再次调试</h1><p>将设置response的代码全部注释后，果然可以正常返回空结构体，确认了之前的猜测。</p>
<p>之后通过二分注释的方法，确认了问题出在一个float字段上，当float字段被设置为Nan时，会导致无返回的现象发生，至此问题确认。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>protobuf本身是支持nan作为值的，因此是框架层自己的兼容性问题，但是这种一言不合就暴毙的问题排查，着实令人头疼。</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>protobuf</tag>
        <tag>c++</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>链表相关题目</title>
    <url>/2021/05/03/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>链表类相关题目</p>
<span id="more"></span>

<h1 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/submissions/">https://leetcode-cn.com/problems/linked-list-cycle/submissions/</a></p>
<p>快慢指针法, 快指针一次2步，慢指针一次1步，如果指针之一发现nil尾节点，则返回无环。<br>如果指针重合，返回有环。</p>
<h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p>
<p>使用双指针，分别从a, b开始遍历，到达a的末尾后衔接b的头。b也同理。</p>
<p>注意完成跳转的轮次不能进行其他工作，否则会导致头节点被错过。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pointA == <span class="literal">nil</span> &#123;</span><br><span class="line">    pointA = headB</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pointA = pointA.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
