<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++字符串分割</title>
    <url>/2021/05/10/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<p>字符串分割方式汇总</p>
<span id="more"></span>

<h2 id="string-find"><a href="#string-find" class="headerlink" title="string.find"></a>string.find</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line">std::string delimiter = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">std::string token;</span><br><span class="line">std::vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">while</span> ((pos = s.<span class="built_in">find</span>(delimiter)) != std::string::npos) &#123;</span><br><span class="line">    token = s.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    v.<span class="built_in">push_back</span>(token);</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">0</span>, pos + delimiter.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line">v.<span class="built_in">push_back</span>(s);</span><br></pre></td></tr></table></figure>

<h2 id="boost-split"><a href="#boost-split" class="headerlink" title="boost::split()"></a>boost::split()</h2><p>注意split在处理多字符分隔符的时候会有一些更奇妙的行为。<br>此外要处理结果中的空字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;boost/algorithm/string.hpp&gt;</span></span></span><br><span class="line">std::string line = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line">boost::<span class="built_in">split</span>(v,line,boost::<span class="built_in">is_any_of</span>(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="strotk"><a href="#strotk" class="headerlink" title="strotk"></a>strotk</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line"><span class="type">char</span> *token = <span class="built_in">strtok</span>(str.<span class="built_in">data</span>(), <span class="string">&quot;,&quot;</span>);</span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line"><span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    token = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(token));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>c++/cpp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>C++异常捕获</title>
    <url>/2021/12/02/C++%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<p>有时我们无法确定一段代码会抛出何种异常，但是又希望能捕获这些异常</p>
<span id="more"></span>

<p>在不能确定异常类型时，首先应该尝试捕获std::exception, 通过what()方法可以得到一个较为详细的报错信息。</p>
<p>但有时，也可能会遇到一些不按套路出牌的代码，这时就需要使用<code>catch(...)</code>来进行捕获，通过<code>__cxa_exception_type</code>可以大致确定报错的类型，之后再修改代码进行进一步的处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// some thing</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception &amp;e) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* describe = e.<span class="built_in">what</span>();</span><br><span class="line">  <span class="comment">// some print describe</span></span><br><span class="line">&#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">  std::exception_ptr p = std::<span class="built_in">current_exception</span>();</span><br><span class="line">  std::string type_name = (p ? p.__cxa_exception_type()-&gt;<span class="built_in">name</span>() : <span class="string">&quot;null&quot;</span>);</span><br><span class="line">  <span class="comment">// some print type_name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>c++/cpp</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>C++重写和虚函数对比</title>
    <url>/2021/09/22/C++%E9%87%8D%E5%86%99%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>在子类中，可以声明一个和父类相同的函数，此时父类函数是否标记为virtual将会影响这一行为</p>
<span id="more"></span>

<p>当父类没有标记为virtual时，将子类转换为父类之后，执行的将会是父类方法</p>
<p>当父类标记为virtual时，将子类转换为父类之后，执行的将会是子类方法</p>
<p>核心：</p>
<ul>
<li>只有函数名和参数都相同才算相同的函数</li>
<li>只用在父子类中相同函数，且该函数在父类中标记了virtual，才能通过子类调用</li>
</ul>
<h2 id="指针-Base-basep-amp-sub-和引用-Base-amp-base-sub"><a href="#指针-Base-basep-amp-sub-和引用-Base-amp-base-sub" class="headerlink" title="指针(Base *basep = &amp;sub;)和引用(Base &amp;base = sub;)"></a>指针(Base *basep = &amp;sub;)和引用(Base &amp;base = sub;)</h2><table>
<thead>
<tr>
<th></th>
<th>无virtual</th>
<th>有virtual</th>
</tr>
</thead>
<tbody><tr>
<td>参数相同</td>
<td>子调用子方法<br>父调用父方法</td>
<td>子调用子方法<br><strong>父调用子方法</strong></td>
</tr>
<tr>
<td>参数不同</td>
<td>子调用子方法，无法调用父<br>父调用父方法，无法调用子</td>
<td>子调用子方法，无法调用父<br>父调用父方法，无法调用子</td>
</tr>
</tbody></table>
<h2 id="直接赋值-Base-base-sub"><a href="#直接赋值-Base-base-sub" class="headerlink" title="直接赋值(Base base = sub;)"></a>直接赋值(Base base = sub;)</h2><table>
<thead>
<tr>
<th></th>
<th>无virtual</th>
<th>有virtual</th>
</tr>
</thead>
<tbody><tr>
<td>参数相同</td>
<td>子调用子方法<br>父调用父方法</td>
<td>子调用子方法<br><strong>父调用子方法</strong></td>
</tr>
<tr>
<td>参数不同</td>
<td>子调用子方法，无法调用父<br>父调用父方法，无法调用子</td>
<td>子调用子方法，无法调用父<br>父调用父方法，无法调用子</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vexecute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base virtual execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hexecute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base hide execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vhexecute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Base hide execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Sub execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">vexecute</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Sub virtual execute&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">hexecute</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Sub hide execute &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">vhexecute</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Sub hide execute &quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">    Sub sub;</span><br><span class="line">    Base base = sub;</span><br><span class="line">    sub.<span class="built_in">execute</span>();      <span class="comment">// Sub execute</span></span><br><span class="line">    base.<span class="built_in">execute</span>();     <span class="comment">// Base execute</span></span><br><span class="line">    sub.<span class="built_in">vexecute</span>();     <span class="comment">// Sub virtual execute</span></span><br><span class="line">    base.<span class="built_in">vexecute</span>();    <span class="comment">// Base virtual execute</span></span><br><span class="line">    sub.<span class="built_in">hexecute</span>(<span class="number">0</span>);    <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// sub.hexecute();  no matching function for call to ‘Sub::hexecute()’</span></span><br><span class="line">    base.<span class="built_in">hexecute</span>();    <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// base.hexecute(0); no matching function for call to ‘Base::hexecute(int)’</span></span><br><span class="line">    sub.<span class="built_in">vhexecute</span>(<span class="number">0</span>);    <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// sub.vhexecute();  no matching function for call to ‘Sub::vhexecute()’</span></span><br><span class="line">    base.<span class="built_in">vhexecute</span>();    <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// base.vhexecute(0); no matching function for call to ‘Base::vhexecute(int)’</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">    Sub sub;</span><br><span class="line">    Base &amp;base = sub;</span><br><span class="line">    sub.<span class="built_in">execute</span>();      <span class="comment">// Sub execute</span></span><br><span class="line">    base.<span class="built_in">execute</span>();     <span class="comment">// Base execute</span></span><br><span class="line">    sub.<span class="built_in">vexecute</span>();     <span class="comment">// Sub virtual execute</span></span><br><span class="line">    base.<span class="built_in">vexecute</span>();    <span class="comment">// Sub virtual execute</span></span><br><span class="line">    sub.<span class="built_in">hexecute</span>(<span class="number">0</span>);    <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// sub.hexecute();  no matching function for call to ‘Sub::hexecute()’</span></span><br><span class="line">    base.<span class="built_in">hexecute</span>();    <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// base.hexecute(0); no matching function for call to ‘Base::hexecute(int)’</span></span><br><span class="line">    sub.<span class="built_in">vhexecute</span>(<span class="number">0</span>);    <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// sub.vhexecute();  no matching function for call to ‘Sub::vhexecute()’</span></span><br><span class="line">    base.<span class="built_in">vhexecute</span>();    <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// base.vhexecute(0); no matching function for call to ‘Base::vhexecute(int)’</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">    Sub *subp = <span class="keyword">new</span> <span class="built_in">Sub</span>();</span><br><span class="line">    Base *basep = subp;</span><br><span class="line">    subp-&gt;<span class="built_in">execute</span>();        <span class="comment">// Sub execute</span></span><br><span class="line">    basep-&gt;<span class="built_in">execute</span>();       <span class="comment">// Base execute</span></span><br><span class="line">    subp-&gt;<span class="built_in">vexecute</span>();       <span class="comment">// Sub virtual execute</span></span><br><span class="line">    basep-&gt;<span class="built_in">vexecute</span>();      <span class="comment">// Sub virtual execute</span></span><br><span class="line">    subp-&gt;<span class="built_in">hexecute</span>(<span class="number">0</span>);      <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// subp-&gt;hexecute();    no matching function for call to ‘Sub::hexecute()’</span></span><br><span class="line">    basep-&gt;<span class="built_in">hexecute</span>();      <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// basep-&gt;hexecute(0);  no matching function for call to ‘Base::hexecute(int)’</span></span><br><span class="line">    subp-&gt;<span class="built_in">vhexecute</span>(<span class="number">0</span>);     <span class="comment">// Sub hide execute 0</span></span><br><span class="line">    <span class="comment">// subp-&gt;vhexecute();   no matching function for call to ‘Sub::vhexecute()’</span></span><br><span class="line">    basep-&gt;<span class="built_in">vhexecute</span>();     <span class="comment">// Base hide execute</span></span><br><span class="line">    <span class="comment">// basep-&gt;vhexecute(0); no matching function for call to ‘Base::vhexecute(int)’</span></span><br><span class="line">    <span class="keyword">delete</span> subp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>c++/cpp</tag>
        <tag>overwrite</tag>
        <tag>overriding</tag>
        <tag>virtual function</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Actions 复用 Workflow</title>
    <url>/2024/04/09/Github-Actions-%E5%A4%8D%E7%94%A8workflow/</url>
    <content><![CDATA[<p>我们都知道在编写github actions时，可以使用其他预定义好的github action，类似如下写法.</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># .github/workflows/flow1.yml</span><br><span class="line">on:</span><br><span class="line">  workflow_call:</span><br><span class="line">    inputs:</span><br><span class="line">      source_branch:</span><br><span class="line">        description: &#x27;source code branch&#x27;</span><br><span class="line">        required: true</span><br><span class="line">        default: &#x27;main&#x27;</span><br><span class="line">        type: string</span><br><span class="line">  push:</span><br><span class="line">    branches: [ &quot;main&quot; ]</span><br><span class="line"># ...</span><br><span class="line">jobs:</span><br><span class="line">  fetch:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - uses: actions/checkout@v4</span><br><span class="line">      with:</span><br><span class="line">        ref: $&#123;&#123; github.ref &#125;&#125;</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>那么当我们写好了这样一个workflow之后，能否进一步在多个workflow中复用这个文件呢，实际上是可以的。</p>
<p>首先比编辑<code>.github/workflows/flow1.yml</code>，增加<code>workflow_call</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on:</span><br><span class="line">  workflow_call:</span><br><span class="line">    inputs:</span><br><span class="line">      param1:</span><br><span class="line">        required: true</span><br><span class="line">        type: string</span><br><span class="line">  push:</span><br><span class="line">    branches: [ &quot;main&quot; ]</span><br><span class="line"># ...</span><br><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">    - uses: actions/checkout@v4</span><br><span class="line">      with:</span><br><span class="line">        ref: $&#123;&#123; github.ref &#125;&#125;</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>之后在另一个workflow中就可以这样调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># .github/workflows/flow2.yml</span><br><span class="line"># ...</span><br><span class="line">jobs:</span><br><span class="line">  job1:</span><br><span class="line">    steps:</span><br><span class="line">        uses: actions/checkout@v4</span><br><span class="line">        # can do smthing else</span><br><span class="line">  job2:</span><br><span class="line">    needs: [job1]</span><br><span class="line">    uses: ./.github/workflows/flow1.yml</span><br><span class="line">    # uses: &lt;user_name&gt;/&lt;repo&gt;/workflows/flow1.yml@&lt;branch/commit&gt;</span><br><span class="line">        with:</span><br><span class="line">            ref: $&#123;&#123; github.ref &#125;&#125;</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"># ...</span><br></pre></td></tr></table></figure>

<p>这种用法有以下几点需要注意：</p>
<ol>
<li><code>./.github/workflows/flow1.yml</code> 只能作为一个job使用，而不能作为step使用，否则会得倒类似 <code>Can&#39;t find &#39;action.yml&#39; or &#39;Dockerfile&#39; under xxxx Did you forget to run actions/checkout before running your local action</code></li>
<li><code>uses</code>字段必须紧接着<code>job2</code>声明，否则会报错<code>The workflow is not valid</code></li>
<li>执行job2之前，必须先执行job1，将项目代码clone到当前目录，并设置job2和job1的依赖关系，否则找不到目标文件</li>
<li>调用本地文件时<code>uses</code>的值必须为<code>./.github/...</code>，而不能是<code>.github/...</code></li>
</ol>
]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>actions</tag>
        <tag>workflow</tag>
        <tag>jobs</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 输入输出 stdio</title>
    <url>/2021/06/14/Golang%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%20stdio/</url>
    <content><![CDATA[<p>Golang 的标准输入输出常见用法</p>
<span id="more"></span>

<h1 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Scanln 实际上需要知道一行中有多少被空格分隔的输入才能使用，直接读取一行作为字符串需要用到scanner或者reader</span></span><br><span class="line">	<span class="comment">// var str1, str2 string</span></span><br><span class="line">	<span class="comment">// fmt.Scanln(str1, str2) </span></span><br><span class="line">	<span class="comment">// fmt.Println(str1, str2);</span></span><br><span class="line">  <span class="comment">// 方式一：</span></span><br><span class="line">  scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">      fmt.Println(scanner.Text())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 方式二：</span></span><br><span class="line">  reader := bufio.NewReader(os.Stdin)</span><br><span class="line">  text, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  fmt.Println(text)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="空格分割"><a href="#空格分割" class="headerlink" title="空格分割"></a>空格分割</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 方式一：</span></span><br><span class="line">  scanner := bufio.NewScanner(bufio.NewReader(os.Stdin))</span><br><span class="line">  scanner.Split(bufio.ScanWords)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">      fmt.Println(scanner.Text())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str <span class="type">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> f <span class="type">float64</span> = <span class="number">100.12</span></span><br><span class="line">  <span class="comment">// 保留一位小数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.1f\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>stdio</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 调用 Linux Netlink 管理路由表</title>
    <url>/2020/07/07/Golang-%E8%B0%83%E7%94%A8-Linux-Netlink-%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E8%A1%A8/</url>
    <content><![CDATA[<p>通常我们使用route命令或者ip命令来管理linux路由表(routing table), 但是如何使用linux原生的接口来进行操作呢？</p>
<span id="more"></span>

<h2 id="NetLink"><a href="#NetLink" class="headerlink" title="NetLink"></a>NetLink</h2><p>netlink 是一种与内核交互的方式，首先创建一个netlink类型的socket，之后向这个socket发送指定格式的数据，就可以从该socket拿到内核的返回。<br>linux的route就是通过这种方式来进行管理的。<br>关于netlink的详细信息建议直接<code>man 7 netlink</code>，网上的信息通常都不够直观。下面节选部分文档</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NETLINK(7) </span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       netlink - communication between kernel and user space (AF_NETLINK)</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;asm/types.h&gt;</span><br><span class="line">       #include &lt;sys/socket.h&gt;</span><br><span class="line">       #include &lt;linux/netlink.h&gt;</span><br><span class="line"></span><br><span class="line">       netlink_socket = socket(AF_NETLINK, socket_type, netlink_family);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Netlink  is  used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for</span><br><span class="line">       kernel modules.  The internal kernel interface is not documented in this manual page.  There is also an obsolete netlink interface via netlink character devices; this  interface  is  not  docu‐</span><br><span class="line">       mented here and is provided only for backward compatibility.</span><br><span class="line"></span><br><span class="line">       Netlink is a datagram-oriented service.  Both SOCK_RAW and SOCK_DGRAM are valid values for socket_type.  However, the netlink protocol does not distinguish between datagram and raw sockets.</span><br><span class="line"></span><br><span class="line">       netlink_family selects the kernel module or netlink group to communicate with.  The currently assigned netlink families are:</span><br><span class="line"></span><br><span class="line">       NETLINK_ROUTE</span><br><span class="line">              Receives routing and link updates and may be used to modify the routing tables (both IPv4 and IPv6), IP addresses, link parameters, neighbor setups, queueing disciplines, traffic classes</span><br><span class="line">              and packet classifiers (see rtnetlink(7)).</span><br><span class="line"></span><br><span class="line">       NETLINK_W1 (Linux 2.6.13 to 2.16.17)</span><br><span class="line">              Messages from 1-wire subsystem.</span><br><span class="line"></span><br><span class="line">       NETLINK_USERSOCK</span><br><span class="line">              Reserved for user-mode socket protocols.</span><br><span class="line"></span><br><span class="line">       NETLINK_FIREWALL (up to and including Linux 3.4)</span><br><span class="line">              Transport IPv4 packets from netfilter to user space.  Used by ip_queue kernel module.  After a long period of being declared obsolete (in favor of the more advanced nfnetlink_queue  fea‐</span><br><span class="line">              ture), NETLINK_FIREWALL was removed in Linux 3.5.</span><br></pre></td></tr></table></figure>

<h2 id="golang-netlink-接口"><a href="#golang-netlink-接口" class="headerlink" title="golang netlink 接口"></a>golang netlink 接口</h2><h2 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h2><p>goalng的syscall库中包装了部分函数帮助我们通过netlink完成查询工作。方便起见我们使用最为通用的<code>syscall.NetlinkRIB</code>函数，该函数会一次将所有table查询出来，无法指定，但是不需要我们手动设置查询结构体，同时帮我们完成了数据接收工作，使用起来较为方便。<br><code>syscall.NetlinkRIB</code>的返回为[]byte，我们需要手动将该字节串转为结构体。在syscall中提供了<code>syscall.ParseNetlinkMessage</code>函数可以帮我们完成这一步操作。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">tab, err := syscall.NetlinkRIB(syscall.RTM_GETROUTE, syscall.AF_INET)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">msgs, err := syscall.ParseNetlinkMessage(tab)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>msgs</code>类型为<code>[]NetlinkMessage</code>每一个table中的路由都会被存储为一个<code>NetlinkMessage</code>结构体，接下来我们遍历<code>msgs</code>来取出所有table的路由。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, m := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.Header.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> syscall.NLMSG_DONE:</span><br><span class="line">			fmt.Println(<span class="string">&quot;recv done&quot;</span>)</span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">        <span class="keyword">case</span> syscall.RTM_NEWROUTE:</span><br><span class="line">            <span class="comment">// 解析数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>对于每一个<code>NetlinkMessage</code>结构，我们需要先判断其类型，如果为<code>NLMSG_DONE</code>则表示数据结束，有人可能觉得数组遍历完了就好，为什么非要把最后一个元素设置为<code>NLMSG_DONE</code>，这其实也是socket传输结束的标志，<code>NetlinkRIB</code>和<code>ParseNetlinkMessage</code>只是将他原样解析了而已。</p>
<p>第二个需要注意的点是，我们使用<code>syscall.RTM_GETROUTE</code>标志get的到的路由表，其头类型为<code>syscall.RTM_NEWROUTE</code>而不是<code>syscall.RTM_GETROUTE</code>，其原因我还没有仔细查过。</p>
<h2 id="路由-表属性-解析"><a href="#路由-表属性-解析" class="headerlink" title="路由 表属性 解析"></a>路由 表属性 解析</h2><p>当进入<code>case syscall.RTM_NEWROUTE:</code>分支后，我们就可以拿到一个路由表的具体数据了。首先需要使用unsafe指针将<code>NetlinkMessage</code>的data解析为<code>RtMsg</code>结构体。之后我们可以从<code>rtmsg</code>中解析出路由表的各项属性。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">rtmsg := (*syscall.RtMsg)(unsafe.Pointer(&amp;m.Data[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot;Scope &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Scope &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_UNIVERSE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_UNIVERSE &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_SITE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_SITE &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_LINK:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_LINK &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_HOST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_HOST &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_NOWHERE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_NOWHERE &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot; Protocol &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Protocol &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_UNSPEC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_UNSPEC&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_REDIRECT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_REDIRECT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_KERNEL:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_KERNEL&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_BOOT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_BOOT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_STATIC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_STATIC&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot; Type &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNSPEC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNSPEC&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNICAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNICAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_LOCAL:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_LOCAL&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_BROADCAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_BROADCAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_ANYCAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_ANYCAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_MULTICAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_MULTICAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_BLACKHOLE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_BLACKHOLE&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNREACHABLE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNREACHABLE&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_PROHIBIT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_PROHIBIT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_THROW:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_THROW&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_NAT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_NAT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_XRESOLVE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_XRESOLVE&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">&quot; Family &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Family &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.AF_INET:</span><br><span class="line">        fmt.Print(<span class="string">&quot;AF_INET&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.AF_INET6:</span><br><span class="line">        fmt.Print(<span class="string">&quot;AF_INET6&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由-解析"><a href="#路由-解析" class="headerlink" title="路由 解析"></a>路由 解析</h2><p>使用<code>syscall.ParseNetlinkRouteAttr</code>函数可以将<code>NetlinkMessage</code>结构体中的每一项路由属性解析出来。每一个<code>attr</code>既代表路由表中的一项路由</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">attrs, err := syscall.ParseNetlinkRouteAttr(&amp;m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, attr := <span class="keyword">range</span> attrs &#123;</span><br><span class="line">    <span class="keyword">switch</span> attr.Attr.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_DST:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_DST &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_SRC:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_SRC &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_GATEWAY:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_GATEWAY &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_PRIORITY:</span><br><span class="line">        priority := *(*<span class="type">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_PRIORITY &quot;</span>, priority, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_TABLE:</span><br><span class="line">        table := *(*<span class="type">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_TABLE &quot;</span>, strconv.Itoa(table), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_METRICS:</span><br><span class="line">        metrics := *(*<span class="type">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_METRICS &quot;</span>, metrics, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_IIF:</span><br><span class="line">        iif := *(*<span class="type">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_IIF &quot;</span>, iif, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_OIF:</span><br><span class="line">        oif := *(*<span class="type">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_OIF &quot;</span>, oif, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;============&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.studygolang.com/2017/07/linux-netlink-and-go-part-1-netlink/">LINUX，NETLINK 和 GO – 第 1 部分：NETLINK</a></li>
<li><a href="https://mdlayher.com/blog/linux-netlink-and-go-part-1-netlink/">Linux, Netlink, and Go - Part 1: netlink</a></li>
<li>[<a href="https://beej-zhcn.netdpi.net/]">https://beej-zhcn.netdpi.net/]</a>(Beej’s Guide to Network Programming)</li>
<li><a href="https://tools.ietf.org/html/rfc3549#section-2.3.2">RFC3549</a></li>
</ol>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>linux</tag>
        <tag>table</tag>
        <tag>route</tag>
        <tag>routing</tag>
        <tag>netlink</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU相关题目</title>
    <url>/2021/05/03/LRU%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>LRU(最近最少使用缓存)相关题目</p>
<span id="more"></span>

<h1 id="LRU-最近最少使用-缓存机制-MD"><a href="#LRU-最近最少使用-缓存机制-MD" class="headerlink" title="LRU (最近最少使用) 缓存机制.MD"></a>LRU (最近最少使用) 缓存机制.MD</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/submissions/">https://leetcode-cn.com/problems/lru-cache/submissions/</a></p>
<p>需要用到一个哈希表和一个双向链表。哈希表记录链表节点和键值</p>
<p>每次进行put或get时操作链表，将节点移动至队头。</p>
<p>使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>MCP streamable-http 通信过程</title>
    <url>/2025/05/22/MCP-streamable-http-%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>最近因为工作需要研究了一下MCP的streamable-http的通信流程, 具体来说整个连接过程涉及了两次POST和一次GET</p>
<span id="more"></span>

<ol>
<li>建立mcp session，这步主要作用是从response的header中获得session-id</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://localhost:8000/mcp&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;accept: application/json, text/event-stream&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;content-type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;method&quot;: &quot;initialize&quot;,</span></span><br><span class="line"><span class="string">  &quot;params&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;protocolVersion&quot;: &quot;2025-03-26&quot;,</span></span><br><span class="line"><span class="string">    &quot;capabilities&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;sampling&quot;: &#123;&#125;,</span></span><br><span class="line"><span class="string">      &quot;roots&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;listChanged&quot;: true</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;clientInfo&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;name&quot;: &quot;mcp-inspector&quot;,</span></span><br><span class="line"><span class="string">      &quot;version&quot;: &quot;0.12.0&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;jsonrpc&quot;: &quot;2.0&quot;,</span></span><br><span class="line"><span class="string">  &quot;id&quot;: 0</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>response body 是sse格式的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">event: message</span><br><span class="line">data: &#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:0,&quot;result&quot;:&#123;&quot;protocolVersion&quot;:&quot;2025-03-26&quot;,&quot;capabilities&quot;:&#123;&quot;experimental&quot;:&#123;&#125;,&quot;prompts&quot;:&#123;&quot;listChanged&quot;:false&#125;,&quot;resources&quot;:&#123;&quot;subscribe&quot;:false,&quot;listChanged&quot;:false&#125;,&quot;tools&quot;:&#123;&quot;listChanged&quot;:false&#125;&#125;,&quot;serverInfo&quot;:&#123;&quot;name&quot;:&quot;Creative Hub MCP Server&quot;,&quot;version&quot;:&quot;1.9.0&quot;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>response header 中 mcp-session-id 是重点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; date: Wed, 21 May 2025 16:58:40 GMT</span><br><span class="line">&lt; server: uvicorn</span><br><span class="line">&lt; cache-control: no-cache, no-transform</span><br><span class="line">&lt; connection: keep-alive</span><br><span class="line">&lt; content-type: text/event-stream</span><br><span class="line">&lt; mcp-session-id: 008aad264bd34776bb48e26b20d65eb4</span><br><span class="line">&lt; x-accel-buffering: no</span><br><span class="line">&lt; transfer-encoding: chunked</span><br><span class="line">&lt; </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用session初始化sse, 这一步会立刻返回</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://localhost:8000/mcp?transportType=streamable-http&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Accept: application/json, text/event-stream&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;mcp-session-id: 008aad264bd34776bb48e26b20d65eb4&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;method&quot;: &quot;notifications/initialized&quot;,</span></span><br><span class="line"><span class="string">  &quot;jsonrpc&quot;: &quot;2.0&quot;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>建立sse连接监听notification, 这里是一个GET请求，会变成SSE连接一直保持</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request GET <span class="string">&#x27;http://localhost:8000/mcp&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Accept: application/json, text/event-stream&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;mcp-session-id: 008aad264bd34776bb48e26b20d65eb4&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开始后续的请求，如tool-list等，tool-call中涉及的sse notification 如log或progress都会通过第三步中建立的sse连接发送到client, 最终结果则会返回到本次请求的response中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl --location --request POST <span class="string">&#x27;http://localhost:8000/mcp?transportType=streamable-http&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;accept: application/json, text/event-stream&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;content-type: application/json&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;mcp-session-id: 008aad264bd34776bb48e26b20d65eb4&#x27;</span> \</span><br><span class="line">--data-raw <span class="string">&#x27;&#123;&quot;method&quot;:&quot;tools/call&quot;,&quot;params&quot;:&#123;&quot;name&quot;:&quot;text_to_image&quot;,&quot;arguments&quot;:&#123;&quot;prompt&quot;:&quot;asd&quot;,&quot;negitive_prompt&quot;:&quot;asd&quot;,&quot;height&quot;:1024,&quot;width&quot;:1024&#125;,&quot;_meta&quot;:&#123;&quot;progressToken&quot;:2&#125;&#125;,&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;id&quot;:2&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mcp</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>mcp</tag>
        <tag>sse</tag>
        <tag>streamable-http</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS配置Nordic蓝牙BLE的Vscode开发环境</title>
    <url>/2025/01/15/MacOS%E9%85%8D%E7%BD%AENordic%E8%93%9D%E7%89%99BLE%E7%9A%84Vscode%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>本文将介绍如何在MacOS下配置Nordic蓝牙开发环境, 器材为nRF52832(开发板NRF52-DK, PCA10040)。</p>
<p>通常来说人们会在windows上进行蓝牙开发, 但实际上MacOS也同样可以, 并且配合vscode可比Keil舒服多了。</p>
<p>如果你对Makefile等工具较为熟悉, 甚至可以获得比IDE更便捷的开发体验。</p>
<span id="more"></span>

<h1 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h1><p>在所有步骤开始之前，首先创建一个文件夹作为你的项目目录</p>
<h2 id="通过Homebrew安装-ARM-交叉编译工具链-和-nordic-工具链-包含了JLINK"><a href="#通过Homebrew安装-ARM-交叉编译工具链-和-nordic-工具链-包含了JLINK" class="headerlink" title="通过Homebrew安装 ARM 交叉编译工具链 和 nordic 工具链(包含了JLINK)"></a>通过Homebrew安装 ARM 交叉编译工具链 和 nordic 工具链(包含了JLINK)</h2><p>我也尝试了使用conda配置GCC编译工具链, 但是目前conda上没有合适的arm gcc包, 因此还是使用Homebrew安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew install --cask gcc-arm-embedded nordic-nrf-command-line-tools </span><br></pre></td></tr></table></figure>

<p>安装过程中需要输入密码获取权限, 输入密码后等待安装完成</p>
<h2 id="安装-nordic-sdk"><a href="#安装-nordic-sdk" class="headerlink" title="安装 nordic sdk"></a>安装 nordic sdk</h2><p>目前nordic主要在推Mesh协议栈，但是作为一个例子，我们还是使用传统的nRF5 SDK。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir .nRF5_SDK &amp;&amp; cd .nRF5_SDK</span><br><span class="line">curl https://developer.nordicsemi.com/nRF5_SDK/nRF5_SDK_v17.x.x/nRF5_SDK_17.1.0_ddde560.zip -O</span><br><span class="line">unzip nRF5_SDK_17.1.0_ddde560.zip</span><br><span class="line">rm nRF5_SDK_17.1.0_ddde560.zip</span><br></pre></td></tr></table></figure>

<h2 id="在Nordic-SDK中配置GCC"><a href="#在Nordic-SDK中配置GCC" class="headerlink" title="在Nordic SDK中配置GCC"></a>在Nordic SDK中配置GCC</h2><p>默认的配置文件位于 <code>.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/components/toolchain/gcc/Makefile.posix</code></p>
<p>执行 <code>arm-none-eabi-gcc --version</code> 和 <code>which arm-none-eabi-gcc</code> 检查gcc版本和安装目录</p>
<p>之后替换原本文件中的内容，GNU_INSTALL_ROOT和GNU_VERSION需要根据实际情况修改，GNU_PREFIX通常不需要修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU_INSTALL_ROOT := /opt/homebrew/bin/</span><br><span class="line">GNU_VERSION := 14.2.1</span><br><span class="line">GNU_PREFIX := arm-none-eabi</span><br></pre></td></tr></table></figure>

<h2 id="编译demo"><a href="#编译demo" class="headerlink" title="编译demo"></a>编译demo</h2><p>选择一个复杂度适中的demo进行编译</p>
<p>使用扩展坞连接你的开发版，然后执行如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd .nRF5_SDK/nRF5_SDK_17.1.0_ddde560/examples/ble_peripheral/ble_app_blinky/pca10040/s132/armgcc</span><br><span class="line"># 编译</span><br><span class="line">make</span><br><span class="line"># 烧录协议栈</span><br><span class="line">make flash_softdevice</span><br><span class="line"># 烧录程序</span><br><span class="line">make flash</span><br></pre></td></tr></table></figure>

<h3 id="报错处理"><a href="#报错处理" class="headerlink" title="报错处理"></a>报错处理</h3><p>当使用新版GCC编译时，可能会出现以下错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">../../../../../../components/libraries/log/src/nrf_log_frontend.c: In function &#x27;nrf_log_module_name_get&#x27;:</span><br><span class="line">../../../../../../components/libraries/log/src/nrf_log_frontend.c:219:29: error: array subscript &#x27;nrf_log_module_const_data_t[0]&#x27; is partly outside array bounds of &#x27;nrf_log_module_const_data_t[0]&#x27; [-Werror=array-bounds=]</span><br><span class="line">  219 |         return p_module_data-&gt;p_module_name;</span><br><span class="line">      |                             ^~</span><br></pre></td></tr></table></figure>
<p>传统的解决办法可以将gcc版本降级, 但是想使用新版GCC, 则需要修改Makefile文件将 <code>-Werror=array-bounds</code> 添加到 <code>CFLAGS</code> 中</p>
<p>对于我们的demo，修改<code>.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/examples/ble_peripheral/ble_app_blinky/pca10040/s132/armgcc/Makefile</code>, 将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFLAGS += -Wall -Werror</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFLAGS += -Wall -Werror -Wno-array-bounds</span><br></pre></td></tr></table></figure>

<p>修改后便可以正常编译了</p>
<h2 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h2><p>uart工具较为常见, 本文不进行介绍, 主要介绍JLINK相关的工具</p>
<p>这些工具在homebrew安装nordic-nrf-command-line-tools时作为依赖已经添加到了系统中, 因此可以直接使用</p>
<h3 id="RTT-LOG"><a href="#RTT-LOG" class="headerlink" title="RTT LOG"></a>RTT LOG</h3><p>开启RTT Log需要修改sdk_config.h文件，将 <code>#define NRF_LOG_ENABLED 1</code> 修改为 <code>#define NRF_LOG_ENABLED 1</code></p>
<p>对于这个demo, 文件位置在<code>.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/examples/ble_peripheral/ble_app_blinky/pca10040/s132/config/sdk_config.h</code></p>
<p>将</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define NRF_LOG_BACKEND_RTT_ENABLED 0</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define NRF_LOG_BACKEND_RTT_ENABLED 1</span><br></pre></td></tr></table></figure>

<p>之后重新编译烧录编译即可开启RTT Log</p>
<p>查看RTT log时需要同时运行两个终端</p>
<p>在第一个终端中执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JLinkExe -device nRF52840_xxAA -if SWD -speed 4000 -autoconnect 1</span><br></pre></td></tr></table></figure>

<p>在第二个终端中执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JLinkRTTClient</span><br></pre></td></tr></table></figure>

<p>在和蓝牙设备互动之后便可以看到类似如下的输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SEGGER J-Link V8.12 - Real time terminal output</span><br><span class="line">SEGGER J-Link (unknown) V1.0, SN=682454502</span><br><span class="line">Process: JLinkExe</span><br><span class="line">&lt;info&gt; app_timer: RTC: initialized.</span><br><span class="line">&lt;info&gt; app: Blinky example started.</span><br><span class="line">&lt;info&gt; app: Connected</span><br><span class="line">&lt;info&gt; app: Received LED ON!</span><br><span class="line">&lt;info&gt; app: Disconnected</span><br><span class="line">&lt;info&gt; app: Connected</span><br><span class="line">&lt;info&gt; app: Disconnected</span><br><span class="line">&lt;info&gt; app: Connected</span><br><span class="line">&lt;info&gt; app: Disconnected</span><br><span class="line">&lt;info&gt; app: Connected</span><br><span class="line">&lt;info&gt; app: Received LED ON!</span><br></pre></td></tr></table></figure>

<h3 id="通过UI配置sdk-config"><a href="#通过UI配置sdk-config" class="headerlink" title="通过UI配置sdk_config"></a>通过UI配置sdk_config</h3><p>有些人可能习惯于使用UI配置sdk_config, 此时需要安装Java工具, 要求Java版本为8</p>
<p>为了防止和系统自带的Java冲突, 此处我使用了conda安装Java, conda的使用方法此处不过多介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conda install openjdk=8</span><br></pre></td></tr></table></figure>

<p>安装后执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make sdk_config</span><br></pre></td></tr></table></figure>

<p>即可启动UI配置工具</p>
<div style="width:50%;margin:auto"> <img src="/2025/01/15/MacOS%E9%85%8D%E7%BD%AENordic%E8%93%9D%E7%89%99BLE%E7%9A%84Vscode%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/sdk-config-ui.jpg" class="" title="sdk-config-ui 200"> </div>


<h2 id="Vscode-代码索引"><a href="#Vscode-代码索引" class="headerlink" title="Vscode 代码索引"></a>Vscode 代码索引</h2><p>完成上述配置后，我们可以进一步配置vscode使其可以正常索引代码</p>
<div style="width:50%;margin:auto"> <img src="/2025/01/15/MacOS%E9%85%8D%E7%BD%AENordic%E8%93%9D%E7%89%99BLE%E7%9A%84Vscode%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/vscode-demo.jpg" class="" title="vscode界面 200"> </div>

<p>在vscode中安装<a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++插件</a>, 并配置c_cpp_properties.json文件</p>
<p>在项目目录下创建<code>.vscode</code>文件夹, 并在其中创建或编辑<code>c_cpp_properties.json</code>文件为以下内容</p>
<p>注意<code>includePath</code>中最后一行<code>$&#123;workspaceFolder&#125;/.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/examples/ble_central/ble_app_blinky_c</code>是为了让vscode能够索引到demo的代码, 对于自己的项目需要替换为对应的项目目录</p>
<p>如果你用到了<code>.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/external</code>或<code>.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/integration</code>中的库, 则同样需要将这些目录添加到include Path中</p>
<p>此外</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;/Applications/ArmGNUToolchain/14.2.rel1/arm-none-eabi/arm-none-eabi/include/**&quot;,</span><br><span class="line">&quot;/Applications/ArmGNUToolchain/14.2.rel1/arm-none-eabi/lib/gcc/arm-none-eabi/14.2.1/include/**&quot;,</span><br></pre></td></tr></table></figure>

<p>这些路径是Homebrew安装的GCC的安装路径, 如果你使用的是其他版本的GCC, 则需要修改为对应的路径。</p>
<p>完整的c_cpp_properties.json文件如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mac&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/components/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/components/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/examples/ble_central/ble_app_blinky_c/pca10040/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/Applications/ArmGNUToolchain/14.2.rel1/arm-none-eabi/arm-none-eabi/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;/Applications/ArmGNUToolchain/14.2.rel1/arm-none-eabi/lib/gcc/arm-none-eabi/14.2.1/include/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/.nRF5_SDK/nRF5_SDK_17.1.0_ddde560/examples/ble_central/ble_app_blinky_c&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;NRF52840_XXAA&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__GNUC__&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;macFrameworkPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/opt/homebrew/bin/arm-none-eabi-gcc&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c99&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++98&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;macos-gcc-arm&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>macos</category>
        <category>ble</category>
      </categories>
      <tags>
        <tag>nordic</tag>
        <tag>ble</tag>
        <tag>nrf52840</tag>
        <tag>nrf52832</tag>
        <tag>vscode</tag>
        <tag>arm-gcc</tag>
        <tag>jlink</tag>
        <tag>macos</tag>
      </tags>
  </entry>
  <entry>
    <title>NFS挂载失效处理</title>
    <url>/2020/07/07/NFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E6%95%88%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在使用NFS的过程中，我们往往会遇到网络问题导致NFS断开，不幸的是，当NFS断开的时候，NFS会继续尝试重连而不会报错，此时如果有软件尝试读取NFS中的内容，就会卡在read函数中无法kill掉。由于文件系统的read不超时，所以它就会永远的卡在里面。同样的现象也会发生在我们尝试执行df命令或者ls NFS目录的时候。此时必须先解挂NFS目录，使程序退出read。</p>
<span id="more"></span>

<h2 id="查找NFS目录位置"><a href="#查找NFS目录位置" class="headerlink" title="查找NFS目录位置"></a>查找NFS目录位置</h2><p>由于NFS目录直接卡死，导致df等命令直接失效，我们只能曲线救国查询NFS目录位置。通常来说，下述两条命令都可以正确执行。</p>
<ol>
<li><code>nfsstat -m</code></li>
<li><code>mount</code></li>
</ol>
<h2 id="解挂"><a href="#解挂" class="headerlink" title="解挂"></a>解挂</h2><p>解挂可以尝试<code>umount -f /path</code>如果提示目录忙，可以继续尝<code>umount -l /path</code>。解挂后相关程序就可以正常退出，此时在重新挂载NFS启动即可。</p>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nvidia Triton 使用教程</title>
    <url>/2021/06/10/Nvidia%20Triton%20Server%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>近年来，在深度学习模型的部署中，涌现了许多新技术，从最早的tf/pytorch直接部署，到onnx，到trnsorrt(trt)，模型的运行效率越来越高。但即便是使用trt方式部署模型，也依旧无法避免巨大的工作量。在使用c++部署trt时，代码量较大，还需要预处理困难。而使用python部署trt，受限于python的GIL问题，需要同时部署多个模型，又失去了trt节省显存的优点。同时，不论使用何种方式，都无法避免面对组batch等问题，整个系统的工程实现会变得非常复杂。<br>在这样的情况下，triton应运而生一站式的帮助我们解决了几乎所有的工程问题，作为一款强大的模型执行引擎，triton支持几乎所有主流的网络模型，对于pytorch，tensorflow，onnx，trt都有良好的支持。</p>
<p>本文将从trt/onnx模型的部署介绍triton的部署流程。</p>
<span id="more"></span>

<h1 id="triton项目的组件"><a href="#triton项目的组件" class="headerlink" title="triton项目的组件"></a>triton项目的组件</h1><ol>
<li><p><a href="https://github.com/triton-inference-server/server">triton server</a><br>triton的服务端可以直接使用docker方式部署，从<a href="https://ngc.nvidia.com/catalog/containers/nvidia:tritonserver/tags">triton的镜像列表</a>中选择tag为xx.xx-py3的镜像即可。</p>
</li>
<li><p><a href="https://github.com/triton-inference-server/client">triton client</a><br>triton的客户端可以从pip直接安装，但为了测试方便，可以直接使用包含测试端的容器环境，tag为xx.xx-py3-sdk的镜像中包含了客户端。</p>
</li>
</ol>
<h1 id="triton-server"><a href="#triton-server" class="headerlink" title="triton server"></a>triton server</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>triton部署模型可以参考<a href="https://github.com/triton-inference-server/server/blob/main/docs/quickstart.md#create-a-model-repository">文档1</a>和<a href="https://github.com/triton-inference-server/server/blob/main/docs/model_repository.md">文档2</a>，但是对于onnx和trt模型，由于模型内已经包含了输入和输出的信息，因此triton可以自动生成配置文件，部署会变得非常简单。</p>
<p>按照triton的教程，我们创建三层目录结构，之后直接把onnx或trt模型拷贝进去即可。</p>
<p>onnx的默认模型名称为model.onnx，而trt的默认模型名称为model.plan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p model_repository/your_model_name/1</span><br><span class="line"><span class="comment"># onnx</span></span><br><span class="line"><span class="built_in">cp</span> your_model_name.onnx model_repository/your_model_name/1/model.onnx</span><br><span class="line"><span class="comment"># trt</span></span><br><span class="line"><span class="built_in">cp</span> your_model_name.trt model_repository/your_model_name/1/model.plan</span><br></pre></td></tr></table></figure>

<p>此时你的目录结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;model-repository-path&gt;/</span><br><span class="line">  &lt;your_model_name&gt;/</span><br><span class="line">    1/</span><br><span class="line">      model.plan</span><br></pre></td></tr></table></figure>

<p>准备好模型文件的目录结构之后，我们启动triton服务，并使用<code>--strict-model-config=false</code>要求他自动生成模型文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --gpus all \</span><br><span class="line">-p8000:8000 -p8001:8001 -p8002:8002 \</span><br><span class="line">-v model_repository:/models \</span><br><span class="line">nvcr.io/nvidia/tritonserver:21.05-py3 \</span><br><span class="line">tritonserver --strict-model-config=<span class="literal">false</span> --model-repository=/models</span><br></pre></td></tr></table></figure>

<p>如果模型正常启动，你将会看到类似下面的的输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----------------------+---------+--------+</span><br><span class="line">| Model                | Version | Status |</span><br><span class="line">+----------------------+---------+--------+</span><br><span class="line">| &lt;model_name&gt;         | &lt;v&gt;     | READY  |</span><br><span class="line">| ..                   | .       | ..     |</span><br><span class="line">| ..                   | .       | ..     |</span><br><span class="line">+----------------------+---------+--------+</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">I1002 21:58:57.891440 62 grpc_server.cc:3914] Started GRPCInferenceService at 0.0.0.0:8001</span><br><span class="line">I1002 21:58:57.893177 62 http_server.cc:2717] Started HTTPService at 0.0.0.0:8000</span><br><span class="line">I1002 21:58:57.935518 62 http_server.cc:2736] Started Metrics Service at 0.0.0.0:8002</span><br></pre></td></tr></table></figure>

<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>接下来我们需要修改triton为我们生成的配置文件，使用如下命令可以获得当前的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl localhost:8000/v2/models/&lt;your_model_name&gt;/config</span><br></pre></td></tr></table></figure>

<p>得到json输出之后，我们需要收到修改为pbconfig的格式。可以参考<a href="https://github.com/triton-inference-server/server/blob/main/docs/model_configuration.md">这篇教程</a>，基本格式如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">platform: &quot;your_model_name&quot;</span><br><span class="line">max_batch_size: 8</span><br><span class="line">input [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;input0&quot;</span><br><span class="line">    data_type: TYPE_FP32</span><br><span class="line">    dims: [ 16 ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">output [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;output0&quot;</span><br><span class="line">    data_type: TYPE_FP32</span><br><span class="line">    dims: [ 4 ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>修改之后，保存为<code>model_repository/your_model_name/config.pbtxt</code>，保存后你的模型目录结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;model-repository-path&gt;/</span><br><span class="line">  &lt;your_model_name&gt;/</span><br><span class="line">    config.pbtxt</span><br><span class="line">    1/</span><br><span class="line">      model.plan</span><br></pre></td></tr></table></figure>

<p>这时我们可以关闭triton，去掉<code>--strict-model-config=false</code>选项后重启服务，修改好的配置文件就会生效了。</p>
<h1 id="triton-client"><a href="#triton-client" class="headerlink" title="triton client"></a>triton client</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>此处以python client为例</p>
<p>triton python client的安装非常简单，使用如下方式即可，如果你只使用http或grpc方式调用，可以将<code>tritonclient[all]</code>替换为<code>tritonclient[http]</code>或<code>tritonclient[grpc]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install nvidia-pyindex</span><br><span class="line">pip install tritonclient[all]</span><br></pre></td></tr></table></figure>

<p>如果你安装完之后报错<code>ModuleNotFoundError: No module named &#39;tritonclient&#39;</code>不妨尝试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install nvidia-pyindex</span><br><span class="line">python -m pip install tritonclient[all]</span><br></pre></td></tr></table></figure>
<p>这样可以确保你的依赖被安装到你使用的python环境中。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>根据我的测试，grpc方式调用triton的性能远远高于http方式，在极端情况下甚至可以达到十倍的性能差距，因此如果没有特殊需要，我不建议使用http方式调用。</p>
<p>客户端示例可以看<a href="https://github.com/triton-inference-server/client/tree/main/src/python/examples">此处</a>，推荐从<code>simple_grpc_infer_client.py</code>这个例子入手</p>
<h2 id="shared-memory"><a href="#shared-memory" class="headerlink" title="shared memory"></a>shared memory</h2><p>对于本机内部调用，triton还支持使用shm方式进行数据共享，减小通信开销。更进一步的，你还可以使用cuda shm方式直接共享显存，在数据发送端就将显存设置好，直接调用triton进行推理。但需要注意的是cuda shm会消耗较多显存，需要用户自己去控制，否则会导致显存用尽，在我自己的测试中。</p>
<p>如果有这部分需要可以参考<a href="https://maple.link/2021/11/22/Tensorrt%20shared%20memory/">Triton shared memory</a></p>
<h2 id="异步模式-async-mode"><a href="#异步模式-async-mode" class="headerlink" title="异步模式(async mode)"></a>异步模式(async mode)</h2><p>triton client还支持异步调用，可以查看<code>simple_grpc_async_infer_client.py</code>。</p>
<h2 id="将triton客户端封装为协程"><a href="#将triton客户端封装为协程" class="headerlink" title="将triton客户端封装为协程"></a>将triton客户端封装为协程</h2><p>triton的客户端仅支持异步模式而不支持协程，需要我们手动进行封装</p>
<p>一次原始的异步调用形式如下，当执行结束，callback函数会被调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">triton_client.async_infer(</span><br><span class="line">        model_name=model_name,</span><br><span class="line">        inputs=inputs,</span><br><span class="line">        callback=callback,</span><br><span class="line">        outputs=outputs)</span><br></pre></td></tr></table></figure>

<p>因此我们需要在callback中通知协程。需要注意的是callback会在另个一个triton client的线程中被调用，因此需要使用<code>loop.call_soon_threadsafe</code>方法为future设置结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from functools import partial</span><br><span class="line"></span><br><span class="line">def callback(loop, future, result, error):</span><br><span class="line">    if error:</span><br><span class="line">        loop.call_soon_threadsafe(future.set_exception, error)</span><br><span class="line">    else:</span><br><span class="line">        loop.call_soon_threadsafe(future.set_result, result)</span><br><span class="line"></span><br><span class="line">def await_infer(triton_client, model_name, inputs, outputs)</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    future = loop.create_future()</span><br><span class="line"></span><br><span class="line">    triton_client.async_infer(</span><br><span class="line">        model_name=model_name,</span><br><span class="line">        inputs=inputs,</span><br><span class="line">        callback=partial(callback, loop, future),</span><br><span class="line">        outputs=outputs)</span><br><span class="line">    return future</span><br></pre></td></tr></table></figure>

<p>包装好后我们就可以使用<code>await</code>关键字去调用<code>await_infer</code>了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async_result = await await_infer(</span><br><span class="line">                triton_client = service.triton_client, </span><br><span class="line">                model_name = model_name, </span><br><span class="line">                inputs = inputs,</span><br><span class="line">                outputs = outputs</span><br><span class="line">            )</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>triton</tag>
      </tags>
  </entry>
  <entry>
    <title>ONNX 模型 转 TRT engine</title>
    <url>/2021/06/10/ONNX%E6%A8%A1%E5%9E%8B%E8%BD%ACTRT%20engine/</url>
    <content><![CDATA[<p>本文将介绍如何将ONNX文件转换为TRT engine文件</p>
<span id="more"></span>

<h2 id="准备转换环境"><a href="#准备转换环境" class="headerlink" title="准备转换环境"></a>准备转换环境</h2><p>强烈不推荐自己搭建，可以直接使用nvidia官方的trt环境（如nvcr.io/nvidia/tritonserver:21.05-py3），之后运行也可以直接在容器中运行。</p>
<h2 id="python方案"><a href="#python方案" class="headerlink" title="python方案"></a>python方案</h2><p>在进入容器后，可以使用如下的python脚本进行转换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding=utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import argparse</span><br><span class="line">import tensorrt as trt</span><br><span class="line"></span><br><span class="line">EXPLICIT_BATCH = 1 &lt;&lt; (int)(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH)</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    parser = argparse.ArgumentParser(description=&quot;PyTorch Object Detection Inference&quot;)</span><br><span class="line">    parser.add_argument(&quot;--onnx_path&quot;, default=&quot;&quot;, dest=&quot;onnx_path&quot;, help=&quot;path to onnx file&quot;, type=str)</span><br><span class="line">    parser.add_argument(&quot;--trt_path&quot;, default=&quot;&quot;, dest=&quot;trt_path&quot;, help=&quot;path to trt file&quot;, type=str)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    onnx_file_path = args.onnx_path</span><br><span class="line">    engine_file_path = args.trt_path</span><br><span class="line">    print(&#x27;get start&#x27;)</span><br><span class="line">    TRT_LOGGER = trt.Logger()</span><br><span class="line">    with trt.Builder(TRT_LOGGER) as builder, builder.create_network(EXPLICIT_BATCH) as network, trt.OnnxParser(network, TRT_LOGGER) as parser:</span><br><span class="line">        config = builder.create_builder_config()</span><br><span class="line">        #builder.max_workspace_size =( 1 &lt;&lt; 30 ) * 2</span><br><span class="line">        config.max_workspace_size =( 1 &lt;&lt; 20 ) * 3 * 1024 # 3GB，可以根据需求改的更大</span><br><span class="line">        builder.max_batch_size = 128</span><br><span class="line">        config.set_flag(trt.BuilderFlag.FP16)</span><br><span class="line">        #builder.fp16_mode = True</span><br><span class="line">        # Parse model file</span><br><span class="line">        if not os.path.exists(onnx_file_path):</span><br><span class="line">            print(&#x27;ONNX file &#123;&#125; not found, please run yolov3_to_onnx.py first to generate it.&#x27;.format(onnx_file_path))</span><br><span class="line">            exit(0)</span><br><span class="line">        print(&#x27;Loading ONNX file from path &#123;&#125;...&#x27;.format(onnx_file_path))</span><br><span class="line">        with open(onnx_file_path, &#x27;rb&#x27;) as model:</span><br><span class="line">            print(&#x27;Beginning ONNX file parsing&#x27;)</span><br><span class="line">            if not parser.parse(model.read()):</span><br><span class="line">                print (&#x27;ERROR: Failed to parse the ONNX file.&#x27;)</span><br><span class="line">                for error in range(parser.num_errors):</span><br><span class="line">                    print (parser.get_error(error))</span><br><span class="line">        print(f&quot;raw shape of &#123;network.get_input(0).name&#125; is: &quot;, network.get_input(0).shape)</span><br><span class="line">        # network.get_input(0).shape = [-1, 3, 32, -1] #dynamic model example</span><br><span class="line">        for i in range(1):</span><br><span class="line">            profile = builder.create_optimization_profile()</span><br><span class="line">            # 最小值 常规值 最大值</span><br><span class="line">            profile.set_shape(network.get_input(0).name, (1, 3, 32, 32), (16, 3, 32, 320), (128, 3, 32, 960))</span><br><span class="line">            config.add_optimization_profile(profile)</span><br><span class="line">        print(&#x27;Completed parsing of ONNX file&#x27;)</span><br><span class="line">        print(&#x27;Building an engine from file &#123;&#125;; this may take a while...&#x27;.format(onnx_file_path))</span><br><span class="line">        engine = builder.build_engine(network,config)</span><br><span class="line">        print(&quot;Completed creating Engine&quot;)</span><br><span class="line">        with open(engine_file_path, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(engine.serialize())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="官方工具转换"><a href="#官方工具转换" class="headerlink" title="官方工具转换"></a>官方工具转换</h2><p>推荐使用官方工具，简单快捷</p>
<ul>
<li><p>–workspace=4096 单位为MB</p>
</li>
<li><p>–explicitBatch 开启动态batch</p>
</li>
<li><p>–minShapes 最小输入 </p>
<p>格式为 节点名:<code>&lt;b&gt;x&lt;d1&gt;x&lt;d2&gt;x...x&lt;dn&gt;</code> </p>
<p>注意节点名的引号需要使用反斜杠转译，如网络输入节点是’data’，那么需要写成<code>\&#39;data\&#39;:1x2x3x4</code>这样的格式。</p>
</li>
<li><p>–optShapes 平均输入</p>
</li>
<li><p>–maxShapes 最大输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run --gpus all --<span class="built_in">rm</span> -v /models:/models nvcr.io/nvidia/tensorrt:21.04-py3 \</span><br><span class="line">/usr/src/tensorrt/bin/trtexec --explicitBatch --workspace=4096 \</span><br><span class="line">--minShapes=\&#x27;data\&#x27;:1x3x32x32 --optShapes=\&#x27;data\&#x27;:128x3x32x320 --maxShapes=\&#x27;data\&#x27;:256x3x32x960 --fp16 \</span><br><span class="line">--onnx=/models/model.onnx --saveEngine=/models/model.plan</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>tensorrt</tag>
        <tag>onnx</tag>
        <tag>trtexec</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用Pipe控制命令行输入输出</title>
    <url>/2021/07/13/Python%E4%BD%BF%E7%94%A8Pipe%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>在开发过程中，我们有时需要在python中调用诸如ffmpeg这样的命令。此时就不可避免的需要用到pipe。</p>
<span id="more"></span>

<p>当我们仅需要使用输入或输出时，可以直接指定stdin/stdout/stderr为Pipe，但是当我们需要同时使用输入输出时，直接使用pipe的读写时无法工作的。</p>
<p>此时只能使用<code>pipe.communicate</code>方法，通过这种一锤子买卖一次性把所有的输入设置完，并读取所有的输出。</p>
<p>下面的例子是一个使用pipe将音频文件的字节流送给ffmpeg处理，并且从ffmpeg读取处理结果的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># init command</span><br><span class="line"># set ffmpeg read write to pipe</span><br><span class="line">ffmpeg_command = [&quot;ffmpeg&quot;, &quot;-f&quot;, &quot;aac&quot;,&quot;-i&quot;, &quot;-&quot;, &quot;-f&quot;, &quot;wav&quot;, &quot;-&quot;]</span><br><span class="line"></span><br><span class="line"># excute ffmpeg command</span><br><span class="line">pipe = subprocess.Popen(ffmpeg_command,</span><br><span class="line">                    stdin=subprocess.PIPE,</span><br><span class="line">                    stdout=subprocess.PIPE,</span><br><span class="line">                    bufsize=1024*1024*128)</span><br><span class="line"></span><br><span class="line"># get you byte stream from anywhere</span><br><span class="line">with open(&quot;audio.aac&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"># only way you can read and write in same time</span><br><span class="line">output, stderr = pipe.communicate(data)</span><br><span class="line"></span><br><span class="line">with open(&quot;test.wav&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    data = output</span><br><span class="line">    print(len(data))</span><br><span class="line">    f.write(data)</span><br><span class="line">pipe.wait()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pipe</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis HGET Benchmark</title>
    <url>/2024/04/12/Redis-HGET-Benchmark/</url>
    <content><![CDATA[<p>使用redis-benchmark工具对redis集群进行压测</p>
<p>redis-benchmark工具对于redis cluster支持并是不特别好，需要使用<code>&#123;tag&#125;</code>来写入指定node，相关用法在这<a href="https://github.com/redis/redis/pull/5889">pr</a>中。</p>
<p>但是使用{tag}测试后不好删除数据，并且根据业务需要，关注的是单Hash单Node下的性能表现，所以最后测试时，直接连接了测试key所在的node，避免了事后清除数据的麻烦。 </p>
<p>根据测试结果，可以看出，使用Pipeline的情况下Redis吞吐量能提升一倍有余</p>
<p>在不使用pipeline的情况下猜测是网络开销占用了过多CPU，但具体是iowait还是其他因素造成仍需分析</p>
<p>此外AWS在Redis7/7.1上支持了(增强型IO多路复用)[<a href="https://docs.aws.amazon.com/zh_cn/AmazonElastiCache/latest/red-ug/supported-engine-versions.html#redis-version-7.0]%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%A4%A7%E7%A8%8B%E5%BA%A6%E4%B8%8A%E5%A2%9E%E5%BC%BA%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E6%80%A7%E8%83%BD%E3%80%82">https://docs.aws.amazon.com/zh_cn/AmazonElastiCache/latest/red-ug/supported-engine-versions.html#redis-version-7.0]可以很大程度上增强多客户端连接时的性能。</a></p>
<span id="more"></span>

<h1 id="AWS-Node-Type"><a href="#AWS-Node-Type" class="headerlink" title="AWS Node Type"></a>AWS Node Type</h1><table>
<thead>
<tr>
<th>缓存节点类型</th>
<th>vCPU</th>
<th>内存</th>
<th>网络性能</th>
</tr>
</thead>
<tbody><tr>
<td>cache.m6g.large</td>
<td>2</td>
<td>6.38 GiB</td>
<td>高达 10GB</td>
</tr>
</tbody></table>
<p>redis version: 6.2</p>
<h1 id="Benchmark-Result"><a href="#Benchmark-Result" class="headerlink" title="Benchmark Result"></a>Benchmark Result</h1><h2 id="1-with-pipeline"><a href="#1-with-pipeline" class="headerlink" title="1. with pipeline"></a>1. with pipeline</h2><p>command:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-benchmark -h &lt;host&gt; -p 6379 -l -q -P 16 --threads 6 hget benchmark_hash_key __rand_int__</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Engine CPU：57.5%</span><br><span class="line">RPM：23757040</span><br></pre></td></tr></table></figure>

<h2 id="1-without-pipeline"><a href="#1-without-pipeline" class="headerlink" title="1. without pipeline"></a>1. without pipeline</h2><p>command:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-benchmark -h &lt;host&gt; -p 6379 -l -q -c 80 --threads 10 hget benchmark_hash_key __rand_int__</span><br></pre></td></tr></table></figure>

<p>result:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Engine CPU：84%</span><br><span class="line">RPM：10815595</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>reids</tag>
        <tag>benchmark</tag>
        <tag>redis-benchmark</tag>
        <tag>hget</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis中的时间计算</title>
    <url>/2022/12/30/Redis%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>在使用Redis时, 通常会使用<code>EXPIRE</code>, <code>PEXPIRE</code>系列函数设置生存时间, 当需要获取超时时间时使用<code>TTL</code>, <code>PTTL</code>获取剩余的生存时间。</p>
<p>同样的, 还可以使用<code>EXPIREAT</code>, <code>PEXPIREAT</code>以unix timestamp格式设置超时时间点, 但需要注意的是, Redis 7.0 之前没有函数能获取设置timestamp, 只能使用<code>TTL</code>, <code>PTTL</code>获取剩余的生存时间。</p>
<p>在实际使用中, 经常需要比较新旧生存周期的大小来决定是否更新数据, 如果你很幸运的使用7.0及之后的版本, 可以使用<code>EXPIREAT</code>, <code>PEXPIREAT</code>配合<code>GT</code>参数来设置过期时间, 如果新的过期时间小于已有过期时间, 则会返回<code>0</code>。</p>
<p>那么老版本的Redis该如何实现这种功能呢？</p>
<span id="more"></span>

<p>在Redis中使用<code>TIME</code>命令可以获取当当前的timestamp, 加上<code>TTL</code>, <code>PTTL</code>获取的值之后就可以得到原本设置的过期时间。</p>
<p>需要注意的是<code>TIME</code>命令返回两个字符串(比如 “1672400893” 和 “528370” ), 第一个字符串中的数字代表以秒计时的unix timestamp, 第二个字符串中的数字代表当前这一秒中已经过去多少微秒。</p>
<p>为了完成数学计算, 需要使用<code>tonumber</code>函数将字符串转换为数字, 如果只需要秒及精度, 只使用第一个字符串的返回值即可, 如果需要毫秒级精度, 则需要将第一个数字乘1000, 将第二个数字除以1000, 并将两个数字相加。</p>
<p>以下LUA展示了如何实现带超时的SET命令毫秒时间戳的比较, 只有当新的超时时间戳大于已有的超时时间戳, 新的value才能成功设置, 返回服务器最终采用的时间戳, 客户端应该比较返回时间戳与传入时间戳是否相等, 若不等于则说明设置失败。</p>
<p>参数<br>KEYS[1]: SET 命令的 KEY<br>AEGV[1]: SET 命令的 VAL<br>AEGV[2]: 超时时间戳(ms)</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> expirePTTL = redis.call(<span class="string">&#x27;PTTL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="comment">-- 如果PTTL返回值&lt;0则说明key不存在或者没有设置过expire, 此时直接设置新值</span></span><br><span class="line"><span class="keyword">if</span> (expirePTTL &gt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> serverTime = redis.call(<span class="string">&#x27;TIME&#x27;</span>)</span><br><span class="line">  <span class="comment">-- 计算原始过期时间戳</span></span><br><span class="line">  <span class="keyword">local</span> expireTime = <span class="built_in">tonumber</span>(serverTime[<span class="number">1</span>]) * <span class="number">1000</span> + <span class="built_in">tonumber</span>(serverTime[<span class="number">2</span>] / <span class="number">1000</span>) + expirePTTL</span><br><span class="line">  <span class="comment">-- 如果原始过期时间戳大于传入时间戳则直接返回</span></span><br><span class="line">  <span class="comment">-- 此处没有使用大于等于保证了如果返回时间戳与传入时间戳相等, 那么传入值一定被设置过一次</span></span><br><span class="line">  <span class="keyword">if</span> (expireTime &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]))  <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> expireTime</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置值和过期时间</span></span><br><span class="line">redis.call(<span class="string">&#x27;SET&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line">redis.call(<span class="string">&#x27;PEXPIREAT&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">return</span> ARGV[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>unix time</tag>
        <tag>timestamp</tag>
        <tag>EXPIRE</tag>
        <tag>PEXPIRE</tag>
        <tag>TTL</tag>
        <tag>PTTL</tag>
        <tag>EXPIREAT</tag>
        <tag>PEXPIREAT</tag>
        <tag>EXPIRETIME</tag>
        <tag>PEXPIRETIME</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorrt Engine 输出模型输入输出信息</title>
    <url>/2021/09/08/Tensorrt%20Engine%20%E8%BE%93%E5%87%BA%E6%A8%A1%E5%9E%8B%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>调试plan文件的时候经常需要输出相关信息，在这里分享一个方便的程序脚本，可以输出每个输入输出节点的相关信息</p>
<span id="more"></span>

<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import tensorrt as trt</span><br><span class="line">import sys</span><br><span class="line">import numpy as np</span><br><span class="line">trt_logger = trt.Logger(trt.Logger.INFO)</span><br><span class="line">runtime = trt.Runtime(trt_logger)</span><br><span class="line">with open(sys.argv[1], &quot;rb&quot;) as f:</span><br><span class="line">    engine = runtime.deserialize_cuda_engine(f.read())</span><br><span class="line">print(&quot;Engine Info:&quot;)</span><br><span class="line">for i, binding in enumerate(engine):</span><br><span class="line">    shape = [engine.max_batch_size, *engine.get_binding_shape(binding)]</span><br><span class="line">    dtype = trt.nptype(engine.get_binding_dtype(binding))</span><br><span class="line">    volume = abs(trt.volume(engine.get_binding_shape(binding)))</span><br><span class="line">    if engine.binding_is_input(binding):</span><br><span class="line">        desc = &quot;input&quot; </span><br><span class="line">    else:</span><br><span class="line">        desc = &quot;output&quot;</span><br><span class="line">    print(f&quot;&#123;i&#125; type:    &#123;desc&#125;\n  binding: &#123;binding&#125; \n  data:    &#123;np.dtype(dtype).name&#125;\n  shape:   &#123;shape&#125; =&gt; &#123;volume&#125; \n&quot;)</span><br></pre></td></tr></table></figure>
<p>输入形式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[TensorRT] INFO: [MemUsageChange] Init CUDA: CPU +329, GPU +0, now: CPU 341, GPU 999 (MiB)</span><br><span class="line">[TensorRT] INFO: Loaded engine size: 4 MB</span><br><span class="line">[TensorRT] INFO: [MemUsageSnapshot] deserializeCudaEngine begin: CPU 346 MiB, GPU 999 MiB</span><br><span class="line">[TensorRT] INFO: [MemUsageChange] Init cuBLAS/cuBLASLt: CPU +491, GPU +210, now: CPU 842, GPU 1211 (MiB)</span><br><span class="line">[TensorRT] INFO: [MemUsageChange] Init cuDNN: CPU +287, GPU +200, now: CPU 1129, GPU 1411 (MiB)</span><br><span class="line">[TensorRT] INFO: [MemUsageChange] Init cuBLAS/cuBLASLt: CPU +0, GPU +0, now: CPU 1129, GPU 1393 (MiB)</span><br><span class="line">[TensorRT] INFO: [MemUsageSnapshot] deserializeCudaEngine end: CPU 1129 MiB, GPU 1393 MiB</span><br><span class="line">Engine Info:</span><br><span class="line">0 type:    input</span><br><span class="line">  binding: data </span><br><span class="line">  data:    float32</span><br><span class="line">  shape:   [1, 1, 3, 256, 256] =&gt; 36864 </span><br><span class="line"></span><br><span class="line">1 type:    output</span><br><span class="line">  binding: result </span><br><span class="line">  data:    float32</span><br><span class="line">  shape:   [1, 8, 8] =&gt; 8 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -itd --gpus all \</span><br><span class="line">  --<span class="built_in">rm</span> -v /home/user/trtdebug.py:/models/trtdebug.py \</span><br><span class="line">  --<span class="built_in">rm</span> -v /home/user/model.plan:/models/model.plan \</span><br><span class="line">  geminihub.oa.com:80/karizhang/nvcr.io/nvidia/tensorrt:21.08-py3 python /models/trtdebug.py /models/model.plan</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>tensorrt</tag>
      </tags>
  </entry>
  <entry>
    <title>Triton shared memory</title>
    <url>/2021/11/22/Triton%20shared%20memory/</url>
    <content><![CDATA[<p>在使用triton时，可以使用shared memory方式加速数据传输的过程</p>
<span id="more"></span>

<h1 id="shared-memory-与-cuda-shared-memory"><a href="#shared-memory-与-cuda-shared-memory" class="headerlink" title="shared memory 与 cuda shared memory"></a>shared memory 与 cuda shared memory</h1><ul>
<li>在<code>shared memory</code>模式下，triton会在数据存放于<code>/dev/shm</code>目录下，之后将文件路径通过rpc接口发送给triton server</li>
<li>在<code>cuda shared memory</code>模式下，triton会在指定显卡上申请一块显存区域，之后直接将数据存放于显存中并通过rpc通知triton server</li>
</ul>
<p>两种shm模式均会使用额外的显存或内存区域，并且依赖程序主动注销申请的空间，因此程序编写时需要特别注意资源的回收和释放，否则将会导致内存或显存泄露</p>
<p>考虑到一般情况下内存空间会远大于显存空间，在发生泄漏时内存空间也比显存空间更好回收，因此虽然cuda-shm模式的速度相比shm更快，但是我依旧更推荐使用shm模式。</p>
<h1 id="shm-memory-pool"><a href="#shm-memory-pool" class="headerlink" title="shm memory pool"></a>shm memory pool</h1><p>使用shm模式的最简单的方式是每次使用随机或顺序递增的文件名去申请内存，在使用结束后立刻释放，但是考虑到保持内存用量的稳定以及复用内存空间来进一步加速，可以使用shm内存池来更好的使用shm模式</p>
<p>内存池的代码如下，主要特性：</p>
<ol>
<li>根据用户提供的<code>shm_name_prefix, shm_key_prefix</code>创建指定数量的共享内存对象，如果使用该名称的对象已经存在则原有对象删除重新创建，这一步保证了过去泄露的内存空间能够被回收</li>
<li>将申请的所有内存空间注册到triton server</li>
<li>支持asyncio，使用await语句等待空闲内存对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tritonclient.grpc <span class="keyword">as</span> grpcclient</span><br><span class="line"><span class="keyword">import</span> tritonclient.utils.shared_memory <span class="keyword">as</span> shm</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Awaitable</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShmRegion</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, triton_client: grpcclient, shm_queue: Queue, max_data_size, shm_name, shm_key</span>):</span><br><span class="line">        self.name = shm_name</span><br><span class="line">        self.key = shm_key</span><br><span class="line">        self.shm_queue = shm_queue</span><br><span class="line">        self.size = max_data_size</span><br><span class="line">        self.triton_client: grpcclient = triton_client</span><br><span class="line">        <span class="comment"># 这里要注意，也许triton升级之后shm就不放这里了，这样清理过期资源不是长久之计</span></span><br><span class="line">        self.shm_path = Path(<span class="string">f&quot;/dev/shm/<span class="subst">&#123;self.key&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.shm_path.exists():</span><br><span class="line">            os.remove(self.shm_path)</span><br><span class="line">        self.triton_client.unregister_system_shared_memory(self.name)</span><br><span class="line">        self.handle = shm.create_shared_memory_region(self.name, self.key, max_data_size)</span><br><span class="line">        self.triton_client.register_system_shared_memory(self.name, self.key, max_data_size)</span><br><span class="line">        logging.info(<span class="string">f&quot;shm region <span class="subst">&#123;self.name&#125;</span> registered&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addToQueue</span>(<span class="params">self, shm_queue=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> shm_queue <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">assert</span> self.shm_queue <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.shm_queue <span class="keyword">is</span> shm_queue</span><br><span class="line">            self.shm_queue = shm_queue</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">assert</span> self.shm_queue <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span></span><br><span class="line">        self.shm_queue.put_nowait(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>): </span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, trace</span>):</span><br><span class="line">        self.addToQueue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        logging.info(<span class="string">f&quot;shm region <span class="subst">&#123;self.name&#125;</span> removed&quot;</span>)</span><br><span class="line">        self.triton_client.unregister_system_shared_memory(self.name)</span><br><span class="line">        shm.destroy_shared_memory_region(self.handle)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShmTritonClient</span>(<span class="title class_ inherited__">object</span>): </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, triton_client, max_queue_size, max_data_size, shm_name_prefix, shm_key_prefix</span>):</span><br><span class="line">        self.triton_client = triton_client</span><br><span class="line">        <span class="comment"># self.triton_client.unregister_system_shared_memory()</span></span><br><span class="line">        <span class="comment"># 这似乎是一个异步请求，执行后会导致后面的注册失效</span></span><br><span class="line">        <span class="comment"># 等到能拿到loop的时候再执行</span></span><br><span class="line">        <span class="comment"># self.shm_queue = Queue(maxsize=max_queue_size, loop=None)</span></span><br><span class="line">        self.shm_queue = <span class="literal">None</span></span><br><span class="line">        self.max_queue_size = max_queue_size</span><br><span class="line">        self.regions = []</span><br><span class="line">        self.registered_regions = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(max_queue_size):</span><br><span class="line">            region = ShmRegion(self.triton_client, self.shm_queue, max_data_size, <span class="string">f&quot;<span class="subst">&#123;shm_name_prefix&#125;</span>_<span class="subst">&#123;i&#125;</span>&quot;</span>, <span class="string">f&quot;<span class="subst">&#123;shm_key_prefix&#125;</span>_<span class="subst">&#123;i&#125;</span>&quot;</span>)</span><br><span class="line">            self.regions.append(region)</span><br><span class="line">            <span class="comment"># 等到能拿到loop的时候再执行</span></span><br><span class="line">            <span class="comment"># region.addToQueue()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRegion</span>(<span class="params">self</span>) -&gt; Awaitable[ShmRegion] :</span><br><span class="line">        <span class="string">&quot;&quot;&quot;每次调用时如果还有未被注册的region, 则注册一个, &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.shm_queue <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            loop = asyncio.get_running_loop()</span><br><span class="line">            self.shm_queue = Queue(maxsize=self.max_queue_size, loop=loop)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.regions) &gt; self.registered_regions:</span><br><span class="line">            self.regions[self.registered_regions].addToQueue(self.shm_queue)</span><br><span class="line">            self.registered_regions += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.shm_queue.get()</span><br></pre></td></tr></table></figure>

<p>使用例子如下：</p>
<ol>
<li>初始化</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tritonclient.grpc <span class="keyword">as</span> grpcclient</span><br><span class="line">triton_client = grpcclient.InferenceServerClient(url=<span class="string">&quot;localhost:8001&quot;</span>)</span><br><span class="line"><span class="comment"># 计算你的数据的最大内存使用，比如最大的batch=32，最大size=3*512*512</span></span><br><span class="line">max_data = np.zeros(shape=(<span class="number">32</span>, <span class="number">3</span>, <span class="number">512</span>, <span class="number">512</span>), dtype=np.float32)</span><br><span class="line">byte_size = max_data.size * max_data.itemsize</span><br><span class="line">shm_client = ShmTritonClient(triton_client, max_queue_size=<span class="number">16</span>, max_data_size=byte_size, shm_name_prefix=<span class="string">&quot;shm_data&quot;</span>, shm_key_prefix=<span class="string">&quot;/shm_data&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>调用</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tritonclient.utils <span class="keyword">as</span> utils</span><br><span class="line"><span class="keyword">import</span> tritonclient.utils.shared_memory <span class="keyword">as</span> shm</span><br><span class="line"><span class="keyword">from</span> await_infer <span class="keyword">import</span> await_infer</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">infer</span>(<span class="params">img, triton_client</span>):</span><br><span class="line">    input_byte_size = img.size * img.itemsize</span><br><span class="line">    <span class="comment"># 一次性获取2个region分别用于输入输出</span></span><br><span class="line">    <span class="keyword">with</span> (<span class="keyword">await</span> shm_client.getRegion()) <span class="keyword">as</span> inpRegion, \</span><br><span class="line">        (<span class="keyword">await</span> shm_client.getRegion()) <span class="keyword">as</span> outRegion:</span><br><span class="line">        shm.set_shared_memory_region(inpRegion.handle, [img])</span><br><span class="line">        inputs = [grpcclient.InferInput(<span class="string">&#x27;input&#x27;</span>, [*img.shape], <span class="string">&quot;FP32&quot;</span>)]</span><br><span class="line">        <span class="comment"># 输入为FP32的图片，很大，需要使用shm加速</span></span><br><span class="line">        inputs[<span class="number">0</span>].set_shared_memory(inpRegion.name, input_byte_size)</span><br><span class="line">        <span class="comment"># 假设网络有2个输出，第一个输出比较大使用shm模式，第二个输出很小，直接使用grpc完成传输</span></span><br><span class="line">        outputs = [grpcclient.InferRequestedOutput(name) <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">&#x27;shm_output&#x27;</span>， <span class="string">&#x27;plain_output&#x27;</span>]]</span><br><span class="line">        outputs[<span class="number">0</span>].set_shared_memory(outRegion.name, outRegion.size)</span><br><span class="line">        <span class="comment"># await_inferd的代码参考文章 &quot;Nvidia Triton 使用教程&quot;</span></span><br><span class="line">        <span class="comment"># https://maple.link/2021/06/10/Nvidia%20Triton%20Server%E7%9A%84%E4%BD%BF%E7%94%A8/</span></span><br><span class="line">        results = <span class="keyword">await</span> await_infer(</span><br><span class="line">                triton_client = triton_client, </span><br><span class="line">                model_name = <span class="string">&quot;model_name&quot;</span>, </span><br><span class="line">                inputs = inputs,</span><br><span class="line">                outputs = outputs</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        shm_output = results.get_output(<span class="string">&quot;shm_output&quot;</span>)</span><br><span class="line">        shm_output = shm.get_contents_as_numpy(</span><br><span class="line">            outRegion.handle, utils.triton_to_np_dtype(shm_output.datatype),</span><br><span class="line">            shm_output.shape)</span><br><span class="line">        plain_output = results.as_numpy(<span class="string">&#x27;plain_output&#x27;</span>)</span><br><span class="line">        <span class="comment"># copy前shm_output, plain_output都是只读的，无法编辑</span></span><br><span class="line">        shm_output = shm_output.copy()</span><br><span class="line">        plain_output = plain_output.copy()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shm_output, plain_output</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>tensorrt</tag>
        <tag>shared memory</tag>
      </tags>
  </entry>
  <entry>
    <title>XArm手势控制机械臂项目</title>
    <url>/2025/04/15/XArm%E6%89%8B%E5%8A%BF%E6%8E%A7%E5%88%B6%E6%9C%BA%E6%A2%B0%E8%87%82%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="演示视频"><a href="#演示视频" class="headerlink" title="演示视频"></a>演示视频</h2><div style="margin: auto; width: 80%; display: flex; flex-direction: column; text-align: center">
    <video controls="controls">
        <source src="https://github.com/casxt/blog-video/raw/main/xarm/XArm_display.mp4" type="video/mp4">
    </video>
    <em>视频1 远程控制机械臂抓取物品</em>
    <em>0秒~20秒: 未使用智能手套的控制效果</em>
    <em>20秒~57秒: 使用智能手套的增强控制效果</em>
</div>

<span id="more"></span>

<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>XArm是一个手势控制的机械臂项目，是本科时我和其他3位同学一起发起的项目，旨在打造能同步复现人手动作的远程机械臂系统。</p>
<p>项目核心功能：</p>
<ul>
<li>多维手部数据采集</li>
<li>无线控制系统</li>
<li>机械臂位姿解算与逆运动学</li>
</ul>
<p>通过图像识别与传感器手套采集手部运动数据，经算法分析后转换为机械臂运动指令，最终实现机械臂的无线控制。</p>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><p>XArm主要由4大模块构成：</p>
<ol>
<li>基于视觉的手势识别（LeapMotion）</li>
<li>无线九轴IMU手势识别手套（智能手套）</li>
<li>传感器数据聚合与运动指令解算（控制中心）</li>
<li>六轴无线机械臂（XArm）</li>
</ol>
<div style="width:80%;margin:auto;text-align: center"> <img src="/2025/04/15/XArm%E6%89%8B%E5%8A%BF%E6%8E%A7%E5%88%B6%E6%9C%BA%E6%A2%B0%E8%87%82%E9%A1%B9%E7%9B%AE/system_architecture.jpg" class="" title="system_architecture"> <em>图1 系统架构图</em> </div>

<h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>智能手套与XArm主控采用C语言开发，基于ESP32实现主控与无线通信。控制中心基于Python开发，负责位姿解算与逆运动学计算。视觉手势识别模块通过USB与控制中心连接。</p>
<p>系统硬件包含3大核心模块：</p>
<ol>
<li>智能手套：采集九轴姿态与手势数据。作为XArm的可选扩展模块，当手套离线时，控制中心将基于视觉数据进行手势解算。支持热插拔功能，可在机械臂运行时实时接入。</li>
<li>控制中心：全局控制系统，负责多源传感器数据融合、机械臂位姿解算。通过逆运动学将传感器数据转换为机械臂运动指令, 并通过无线连接远程控制机械臂。</li>
<li>XArm机械臂：六自由度机械臂搭载ESP32无线主控，采用单核实现状态上报、指令接收校验与执行功能。通过TDD（时间驱动）系统实现多任务调度，确保实时控制体验。</li>
</ol>
]]></content>
      <categories>
        <category>机器人</category>
      </categories>
      <tags>
        <tag>嵌入式开发</tag>
        <tag>运动控制</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>Yolo发展整理</title>
    <url>/2021/05/03/Yolo%E5%8F%91%E5%B1%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>因为算法面试，整理了一些yolo相关的点</p>
<span id="more"></span>

<h2 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h2><p>region proposals 而不是滑动窗口</p>
<p>输入尺寸固定</p>
<p>小目标检测不好</p>
<p>一个单元格只能预测两个框和一个类别</p>
<h2 id="yolo9000"><a href="#yolo9000" class="headerlink" title="yolo9000"></a>yolo9000</h2><p>替换全连接为卷积，没有了输入尺寸的限制</p>
<p>引入anchor box, 使用kmeans聚类，5 anchor</p>
<p>darknet-19</p>
<p>13 * 13 detection， 2种尺度13 * 13， 26 * 26</p>
<p>训练过程中遇到带标签的检测图像，就基于 YOLOv2 整个损失函数进行反向传播，遇到分类图像，只反向传播网络的分类损失。</p>
<h2 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h2><p>9 anchor</p>
<p>darknet-53</p>
<p>13 * 13， 26 * 26， 52*52， 3个detection</p>
<p>YOLOv3 为每个边界框都预测了一个分数 objectness score，打分依据是预测框与物体的重叠度。如果某个框的重叠度比其他框都高，它的分数就是 1</p>
]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>Yolo发展整理</tag>
      </tags>
  </entry>
  <entry>
    <title>acme使用AliyunDNS验证</title>
    <url>/2022/08/05/acme%E4%BD%BF%E7%94%A8AliyunDNS%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h2 id="安装acme"><a href="#安装acme" class="headerlink" title="安装acme"></a>安装acme</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">curl https://get.acme.sh | sh -s email=your@email.com</span><br></pre></td></tr></table></figure>

<h2 id="使用阿里云dns认证方式"><a href="#使用阿里云dns认证方式" class="headerlink" title="使用阿里云dns认证方式"></a>使用阿里云dns认证方式</h2><p>文档: <a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi">https://github.com/acmesh-official/acme.sh/wiki/dnsapi</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> Ali_Key=<span class="string">&quot;xxxxxxxxxxxxxxxx&quot;</span></span><br><span class="line"><span class="built_in">export</span> Ali_Secret=<span class="string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span></span><br><span class="line">acme.sh --issue --dns dns_ali -d your.domain.com</span><br></pre></td></tr></table></figure>

<h2 id="安装密钥"><a href="#安装密钥" class="headerlink" title="安装密钥"></a>安装密钥</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">acme.sh --install-cert -d your.domain.com --key-file /etc/nginx/your.domain.com.key --fullchain-file /etc/nginx/your.domain.com.pem --reloadcmd <span class="string">&quot;sudo systemctl restart nginx&quot;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>acme</tag>
        <tag>dns</tag>
        <tag>aliyun</tag>
      </tags>
  </entry>
  <entry>
    <title>DynamoDB Partiql 语法</title>
    <url>/2024/03/11/dynamodb%20partiql%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h2><p>在ddb中，推荐使用双引号标记表名，列名，使用单引号标记字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> &quot;TableName&quot;</span><br><span class="line"><span class="keyword">WHERE</span> primary_key <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>可以在语句中使用order by等语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &quot;column1&quot;, &quot;column2&quot;</span><br><span class="line"><span class="keyword">FROM</span> &quot;TableName&quot;</span><br><span class="line"><span class="keyword">WHERE</span> primary_key <span class="operator">=</span> <span class="string">&#x27;key1&#x27;</span> <span class="keyword">AND</span> range_key <span class="operator">=</span> <span class="number">123</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> range_key <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>
<p>也可以使用CAST等函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(column_name <span class="keyword">AS</span> <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">FROM</span> &quot;TableName&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>update时要注意column_name是否存在，由于ddb类似于nosql的特性，如果对原本不存在的column赋值会导致在原本数据中新增一个字段</p>
<p>（虽然一般不会造成额外影响，但还是需要尽量避免）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &quot;TableName&quot;</span><br><span class="line"><span class="keyword">SET</span> column_name <span class="operator">=</span> <span class="number">1710133352</span></span><br><span class="line"><span class="keyword">WHERE</span> primary_key <span class="operator">=</span> <span class="string">&#x27;key1&#x27;</span> <span class="keyword">AND</span> range_key <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>dynamodb</category>
      </categories>
      <tags>
        <tag>ddb</tag>
        <tag>partiql</tag>
      </tags>
  </entry>
  <entry>
    <title>hdfs命令行流式处理</title>
    <url>/2021/12/20/hdfs%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="文件流式处理"><a href="#文件流式处理" class="headerlink" title="文件流式处理"></a>文件流式处理</h1><p>在处理hdfs数据时，可能会遇到本地磁盘空间不足以存放数据的问题，这时我们可以使用linux的stdio对数据进行流式处理，以替换每行内容为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop -<span class="built_in">cat</span> hdfs://your_path/your_file |\</span><br><span class="line">sed  <span class="string">&quot;s/some_thing/some_other/g&quot;</span> |\</span><br><span class="line">hadoop -put - hdfs://your_path/your_processed_file</span><br></pre></td></tr></table></figure>

<p>这样利用pipe完成了对数据的处理，同时避免了数据在本地落盘。</p>
<h1 id="遍历文件夹处理"><a href="#遍历文件夹处理" class="headerlink" title="遍历文件夹处理"></a>遍历文件夹处理</h1><p>此外还可以搭配xargs遍历整个目录</p>
<ul>
<li><code>hadoop -ls -h hdfs://your_path</code> 列出整个目录</li>
<li><code>awk -F&#39; &#39; &#39;&#123;print $NF&#125;&#39;</code> 取出最后一列，也就是文件地址列</li>
<li><code>awk -F&#39;/&#39; &#39;&#123;print $NF&#125;&#39;</code> 将地址中的文件名取出</li>
<li><code>xargs -I &#123;&#125; bash -c ...</code> 将每个文件名依次作为参数处理</li>
<li><code>&quot;hadoop -cat  ...&quot;</code> 按照之前流式处理的方式处理每一个文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hadoop -<span class="built_in">ls</span> -h hdfs://your_path | awk -F<span class="string">&#x27; &#x27;</span> <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | awk -F<span class="string">&#x27;/&#x27;</span> <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> | xargs -I &#123;&#125; bash -c <span class="string">&quot;hadoop -cat hdfs://your_path/&#123;&#125; | sed &#x27;s/some_thing/some_other/g&#x27; | hadoop -put - hdfs://your_other_path/&#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>hdfs</category>
      </categories>
      <tags>
        <tag>hdfs</tag>
        <tag>stdin</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客配合Github Action完成自动CI/CD</title>
    <url>/2021/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E5%90%88Github-Action%E5%AE%8C%E6%88%90%E8%87%AA%E5%8A%A8CI-CD/</url>
    <content><![CDATA[<p>每次部署博客时都需要在本地完成编译和上传，维护工具链成为一件很繁琐的事情，有什么办法能够将这一步自动化，为将来随时随地写博客打下基础呢？</p>
<p>现在来一起学(白)习(嫖)Github Action吧！</p>
<p><small>PS.阅读本文，你需要提前了解一些sh和yaml相关的知识。</small></p>
<span id="more"></span>

<h2 id="CI实现"><a href="#CI实现" class="headerlink" title="CI实现"></a>CI实现</h2><p>为了从源码构建Hexo博客，我们需要进行如下几步：</p>
<ol>
<li>clone源码</li>
<li>clone主题(可选)</li>
<li>安装依赖</li>
<li>构建</li>
</ol>
<p>那么如果使用Github Action实现如上几步呢？</p>
<p>下面直接上配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Action 名称</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Auto</span> <span class="string">Deploy</span></span><br><span class="line"><span class="comment"># 触发条件</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># 代码变动时触发</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 保留此行代表运行手动触发</span></span><br><span class="line">  <span class="comment"># 详情轻参考 https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_dispatch</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="comment"># 主题代码</span></span><br><span class="line">  <span class="attr">THEME_REPO:</span> <span class="string">theme-next/hexo-theme-next</span></span><br><span class="line">  <span class="attr">THEME_BRANCH:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># 工作环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 设置时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">TimeZone</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">sudo</span> <span class="string">timedatectl</span> <span class="string">set-timezone</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">      <span class="comment"># clone代码到~/Blog目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">Blog</span></span><br><span class="line">      <span class="comment"># 配置Node</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2.1.5</span></span><br><span class="line">      <span class="comment"># 删除旧主题(可选)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clear</span> <span class="string">old</span> <span class="string">theme</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd Blog</span></span><br><span class="line"><span class="string">          rm -rf themes/next</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># 拉取新主题(可选)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">Blog/themes/next</span></span><br><span class="line">      <span class="comment"># 安装主题配置文件，安装依赖</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">deps</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd Blog</span></span><br><span class="line"><span class="string">          cp theme_config.yml themes/next/_config.yml</span></span><br><span class="line"><span class="string">          npm install</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># 构建, 产物在~/Blog/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd Blog</span></span><br><span class="line"><span class="string">          npm run build</span></span><br></pre></td></tr></table></figure>

<h2 id="CD实现"><a href="#CD实现" class="headerlink" title="CD实现"></a>CD实现</h2><p>部署方式因人而异，我选择了最方便的Github Pages方式部署。以这种方式部署时，构建好的项目需要被上传到pages项目中。</p>
<p>创建pages项目的教程请参考 <a href="https://pages.github.com/%E3%80%82">https://pages.github.com/。</a></p>
<p>创建完成后，我们需要在pages项目的Settings-&gt;Deploy keys中增加一个公钥。</p>
<p>在博客源码项目中的Settings-&gt;Secrets-&gt;Actions secrets中增加一个私钥。此处我命名为了MAPLE_BLOG，并在步骤Set up git中使用。</p>
<p>密钥对的生成可以使用ssh-keygen(linux/mac)或puttygen(win)，此处不再赘述。</p>
<p>之后在上述流程中增加如下几个env和steps。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ... 省略了一些东西</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="comment"># 增加如下几个env</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">Casxt</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="number">774714620</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">casxt/casxt.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">git@github.com:casxt/blog.github.io.git</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># ... 构建的steps</span></span><br><span class="line">      <span class="comment"># 增加如下step</span></span><br><span class="line">      <span class="comment"># clone pages 项目到~/public目录</span></span><br><span class="line">      <span class="comment"># 需要注意的是我们构建好的产物在~/Blog/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">blog</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;env.DEPLOY_REPO&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;env.DEPLOY_BRANCH&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">public</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 设置私钥，以便向pages项目推送代码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">git</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_KEY:</span> <span class="string">$&#123;&#123;secrets.MAPLE_BLOG&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">          echo &quot;$DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string">          git config --global user.name $GIT_USER</span></span><br><span class="line"><span class="string">          git config --global user.email $GIT_EMAIL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 拷贝产物，并push</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">git</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          cd Blog</span></span><br><span class="line"><span class="string">          cp -R public/* ../public/ </span></span><br><span class="line"><span class="string">          cd ../public/</span></span><br><span class="line"><span class="string">          git remote set-url origin $DEPLOY_GIT_REMOTE</span></span><br><span class="line"><span class="string">          git add .</span></span><br><span class="line"><span class="string">          git commit -m &quot;auto deploy&quot;</span></span><br><span class="line"><span class="string">          git push</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端技术</category>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
        <tag>Github Action</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hive中操作json以及对list的处理</title>
    <url>/2021/12/09/hive%E4%B8%AD%E6%93%8D%E4%BD%9Cjson%E4%BB%A5%E5%8F%8A%E5%AF%B9list%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在处理数据时，时常会遇到需要处理json数据的情况, 可以使用<code>get_json_object</code>, <code>regexp_replace</code>, <code>split</code>来组合对json数组进行处理</p>
<span id="more"></span>


<p>假设json数据为</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;text1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;text1&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们需要将data提取后转换为字符串形式”text1,text2”, 可以使用如下写法实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  concat_ws(<span class="string">&#x27;;&#x27;</span>, </span><br><span class="line">    split(</span><br><span class="line">      regexp_replace(</span><br><span class="line">        get_json_object(</span><br><span class="line">            <span class="string">&#x27;&#123;&quot;data&quot;: [&quot;text1&quot;, &quot;text2&quot;]&#125;&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;$.data&#x27;</span></span><br><span class="line">        ), </span><br><span class="line">        <span class="string">&#x27;[\\[\\]&quot;\\s]&#x27;</span>, <span class="string">&#x27;&#x27;</span></span><br><span class="line">      ), </span><br><span class="line">      <span class="string">&#x27;,&#x27;</span></span><br><span class="line">    )</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>首先使用<code>get_json_object</code>将json中需要的字段提取出来, 然后使用<code>regexp_replace</code>对输出的字符串进行处理, 正则<code>[\\[\\]&quot;\\s]</code>会将<code>[</code>, <code>]</code>, <code>&quot;</code>以及<code>空白符号删除</code>, 最后输出<code>text1,text2</code>, <code>split</code>函数会使用<code>,</code>作为分割符, 将字符串转换为array, 最后<code>concat_ws</code>通过<code>;</code>将array中的所有字符串拼接。</p>
<p>写正则表达式时，不同的系统可能会有不同的转义规则，需要特别注意<code>\</code>的数量。</p>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>get_json_object</tag>
        <tag>hive</tag>
        <tag>spark</tag>
        <tag>presto</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables基础概念</title>
    <url>/2020/03/02/iptables%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>iptables 是标准的linux防火墙命令行控制工具, 其底层调用netfilter来实现各种功能</p>
<p>iptables 中最重要的概念就是 table, chain 和 rule</p>
<span id="more"></span>
<h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>iptables 中包含多个 table, 每个 table 又包含多个 chain, table 是 chain 的集合, 通常可以将 table 视作 chain 按照目的进行的分类</p>
<p>从数据进入网卡到流出网卡的过程中, iptables 会按照一定顺序调用各个 table 的 chain, 我们可以在某个 table 中添加 chain 或 rule 来在某个特定的时间点处理数据。</p>
<p>iptables 中包含了 raw, filter, nat, mangle, security 五个 table, 其中最常用的就是 nat 和 filter。</p>
<p>nat 中包含了会在数据<strong>收发阶段</strong>被调用的 chain, 因此可以用来对数据进行预处理和后处理。</p>
<p>filter 中包含了会在<strong>收发阶段</strong>和<strong>转发阶段</strong>被调用的 chain, 因此通常用来实现防火墙, 对数据的原目的地址端口协议等进行检查。</p>
<h1 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h1><p>chain 是规则(rule)的集合, 每个 table 中会包含数量不定的 chain, 不同 table 中的 chain 可能具有相同的名字 </p>
<p>例如 nat 中包含了 PREROUTING, POSTROUTING, OUTPUT 三个 chain, filter 中包含了 INPUT, OUTPUT, FORWARD 三个 chain</p>
<p>在 iptables 默认的5个 table 中, 每个 table 都包含了数量不一的 chain, 这些 chain 会在数据处理的各个节点被调用, 我们通过在这些默认的 chain 中添加 rule 就可以实现对数据包的捕获和处理。</p>
<h1 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h1><p>rule 是处理数据的具体规则, 数据收发过程中, iptables 会按照一定顺序调用各个 table 的 chain, 我们在这些 chain 中添加规则就可以随心所欲的处理数据。</p>
<p>通常来说, 一个 rule 功能包括:</p>
<ol>
<li>接受或拒绝一个包</li>
<li>将一个包送到某个 chain 里继续处理</li>
<li>改写包</li>
</ol>
<h1 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h1><p>按照下图所示, 我们只关注 filter 和 nat</p>
<p>对于收到的目的地址为本机的数据包, 依次经过 filter 和 nat 的5个 chain:</p>
<ol>
<li>nat: PEROUTING</li>
<li>filter: INPUT</li>
<li>nat: OUTPUT</li>
<li>filter: OUTPUT</li>
<li>nat: POSTOUTING</li>
</ol>
<p>对于收到的目的地址不为本机的数据包, 依次经过 filter 和 nat 的3个 chain:</p>
<ol>
<li>nat: PEROUTING</li>
<li>filter: FORWARD</li>
<li>nat: POSTOUTING</li>
</ol>
<blockquote>
<div style="width:50%;margin:auto"> <img src="/2020/03/02/iptables%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/iptables.jpg" class="" title="iptables 200"> </div>
<small>https://www.it.uu.se/edu/course/homepage/sakdat/vt09/pm/programme/iptables.pdfhexo</small>
</blockquote>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>table</tag>
        <tag>iptables</tag>
        <tag>chain</tag>
        <tag>rule</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>leveldb静态编译及snappy支持</title>
    <url>/2021/11/17/leveldb%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%8F%8Asnappy%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>由于服务器依赖比较老旧，因此需要重新安装各种依赖</p>
<span id="more"></span>
<h2 id="leveldb依赖安装"><a href="#leveldb依赖安装" class="headerlink" title="leveldb依赖安装"></a>leveldb依赖安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install cmake gcc g++</span><br></pre></td></tr></table></figure>
<p>如果cmake无法安装到3.9以上的版本，可以从<a href="https://cmake.org/download/">官网</a>下载，然后直接解压到项目目录下，之后直接使用绝对路径或相对路径调用cmake，gcc和g++推荐使用7.5</p>
<h2 id="snappy编译"><a href="#snappy编译" class="headerlink" title="snappy编译"></a>snappy编译</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/google/snappy.git</span><br><span class="line">cd snappy</span><br><span class="line">git submodule update --init</span><br><span class="line">git checkout 1.1.9</span><br><span class="line">mkdir build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ../</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<h2 id="leveldb编译"><a href="#leveldb编译" class="headerlink" title="leveldb编译"></a>leveldb编译</h2><p>使用<code>--recurse-submodules</code>下载subgit中的内容，使用<code>git tag</code>查看tag，选择最新的release，最后使用<code>git checkout</code>切换到最新的release版本上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone --recurse-submodules https://github.com/google/leveldb.git</span><br><span class="line">cd leveldb</span><br><span class="line">git tag</span><br><span class="line">git checkout 1.23</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p build &amp;&amp; cd build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br></pre></td></tr></table></figure>
<p>执行测试检查编译是否成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./db_bench</span><br></pre></td></tr></table></figure>

<h3 id="snappy支持"><a href="#snappy支持" class="headerlink" title="snappy支持"></a>snappy支持</h3><p>修改<code>leveldb/CMakeLists.txt</code>, 在<code>check_library_exists(snappy snappy_compress &quot;&quot; HAVE_SNAPPY)</code>语句前后添加依赖</p>
<p>其中<code>/home/someone/project/snappy</code>和<code>/home/someone/project/snappy/build</code>需要替换成自己的snappy源码目录和build目录<br>添加后形式如下：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 之前添加依赖</span></span><br><span class="line"><span class="keyword">link_directories</span>(<span class="string">&quot;/home/someone/project/snappy/build&quot;</span>)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="string">&quot;/home/someone/project/snappy&quot;</span> <span class="string">&quot;/home/someone/project/snappy/build&quot;</span>)</span><br><span class="line">check_library_exists(snappy snappy_compress <span class="string">&quot;&quot;</span> HAVE_SNAPPY)</span><br><span class="line"><span class="comment"># 之后强制开启HAVE_SNAPPY</span></span><br><span class="line"><span class="keyword">set</span>(HAVE_SNAPPY <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>
<p>重新编译和测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release .. &amp;&amp; cmake --build .</span><br><span class="line">./db_bench</span><br></pre></td></tr></table></figure>

<h3 id="静态编译leveldb"><a href="#静态编译leveldb" class="headerlink" title="静态编译leveldb"></a>静态编译leveldb</h3><p>因为服务器环境问题，需要静态编译leveldb, 尤其是静态编译libgcc和libg++</p>
<p>在<code>check_library_exists(snappy snappy_compress &quot;&quot; HAVE_SNAPPY)</code>语句前后添加<code>link_libraries</code>标签配置所有的目标静态链接gcc和g++</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_libraries(-static-libgcc -static-libstdc++)</span><br></pre></td></tr></table></figure>
<p>执行<code>ldd db_bench</code>可以看到已经不再依赖gcc和g++了</p>
<p>执行<code>strings /lib64/libstdc++.so.6 | grep GLIBCXX</code>可以查看目前支持的版本</p>
<h3 id="可能会遇到如下报错："><a href="#可能会遇到如下报错：" class="headerlink" title="可能会遇到如下报错："></a>可能会遇到如下报错：</h3><ol>
<li><p>找不到成员</p>
<p> 这种情况是由于gcc、g++版本太低导致的，需要升级版本</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">leveldb/third_party/googletest/googletest/include/gtest/gtest-matchers.h:414:12: error: ‘is_trivially_copy_constructible’ is not a member of ‘std’</span><br><span class="line">            std::is_trivially_copy_constructible&lt;M&gt;::value &amp;&amp;</span><br><span class="line">            ^</span><br></pre></td></tr></table></figure>
<p> 使用如下命令检查版本</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br><span class="line">g++ -v</span><br></pre></td></tr></table></figure></li>
<li><p>/bin/c++ /bin/cc缺失</p>
<p> 这种情况是软链缺失导致的，报错如下</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMake Error at CMakeLists.txt:7 (project):</span><br><span class="line">  The CMAKE_CXX_COMPILER:</span><br><span class="line"></span><br><span class="line">    /bin/c++</span><br><span class="line"></span><br><span class="line">  is not a full path to an existing compiler tool.</span><br><span class="line"></span><br><span class="line">  Tell CMake where to find the compiler by setting either the environment</span><br><span class="line">  variable &quot;CXX&quot; or the CMake cache entry CMAKE_CXX_COMPILER to the full path</span><br><span class="line">  to the compiler, or to the compiler name if it is in the PATH.</span><br></pre></td></tr></table></figure>
<p> 此时需要手动恢复软链，使用<code>which gcc</code>和<code>which g++</code>确定安装位置，然后使用ln设置软链</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /usr/local/bin/g++ /bin/c++</span><br><span class="line"><span class="built_in">ln</span> -s gcc /bin/cc</span><br></pre></td></tr></table></figure></li>
<li><p>/lib64/libstdc++.so.6: version `GLIBCXX_3.4.22’ not found</p>
</li>
</ol>
<p>  建议使用静态链接</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>编写一个简单的测试demo, 放在与leveldb根目录同级的目录下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;leveldb/db.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    leveldb::DB *db;</span><br><span class="line">    leveldb::Options options;</span><br><span class="line">    options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open</span></span><br><span class="line">    leveldb::Status status = leveldb::DB::<span class="built_in">Open</span>(options, <span class="string">&quot;testdb&quot;</span>, &amp;db);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line"></span><br><span class="line">    string key = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">    string value = <span class="string">&quot;shane&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;write:&quot;</span> <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span> <span class="string">&quot;=&gt;&quot;</span> <span class="string">&quot;(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    status = db-&gt;<span class="built_in">Put</span>(leveldb::<span class="built_in">WriteOptions</span>(), key, value);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;value);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;read:&quot;</span> <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span> <span class="string">&quot;=&gt;&quot;</span> <span class="string">&quot;(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete</span></span><br><span class="line">    status = db-&gt;<span class="built_in">Delete</span>(leveldb::<span class="built_in">WriteOptions</span>(), key);</span><br><span class="line">    <span class="built_in">assert</span>(status.<span class="built_in">ok</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;delete:&quot;</span> <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span>  &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    status = db-&gt;<span class="built_in">Get</span>(leveldb::<span class="built_in">ReadOptions</span>(), key, &amp;value);</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read error: &quot;</span> &lt;&lt; status.<span class="built_in">ToString</span>() &lt;&lt; <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span>  &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;read:&quot;</span> <span class="string">&quot;(&quot;</span>&lt;&lt; key &lt;&lt; <span class="string">&quot;)&quot;</span> <span class="string">&quot;=&gt;&quot;</span> <span class="string">&quot;(&quot;</span> &lt;&lt; value &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//close</span></span><br><span class="line">    <span class="keyword">delete</span> db;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行命令, 编译leveldb需要使用<code>-Ileveldb/include</code>引入头文件，<code>-Lleveldb/build</code>设置链库地址, <code>-lleveldb -lpthread</code> 指定要链接的库, <code>-o leveldbtest</code> 指定输出名字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ leveldbtest.cc -Ileveldb/include -Lleveldb/build -lleveldb -lpthread -o leveldbtest</span><br><span class="line">./leveldbtest </span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">write:(name)=&gt;(shane)</span><br><span class="line">read:(name)=&gt;(shane)</span><br><span class="line">delete:(name)OK</span><br><span class="line">read error: NotFound: (name)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>kv</category>
      </categories>
      <tags>
        <tag>leveldb</tag>
        <tag>gcc</tag>
        <tag>g++</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib 多图组合显示</title>
    <url>/2020/05/28/matplotlib%E5%A4%9A%E5%9B%BE%E7%BB%84%E5%90%88%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, dpi=<span class="number">150</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].imshow(im1)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].imshow(im2)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].imshow(im3)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].imshow(im4)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>只有一行时使用一维坐标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, dpi=<span class="number">150</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(im1)</span><br><span class="line">axes[<span class="number">1</span>].imshow(im2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>ORDER BY 与 SORT BY</title>
    <url>/2022/02/28/order-by%E4%B8%8Esort-by/</url>
    <content><![CDATA[<p>一次写sql的时候，脑子发晕，把<code>order by</code>写成了<code>sort by</code></p>
<p>在spark生态中</p>
<ul>
<li><p><code>ORDER BY</code>代表每个分片内部进行排序，使用后，会发现全部数据呈现局部有序性，详情可参考<a href="https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-sortby.html">文档</a></p>
</li>
<li><p><code>SORT BY</code>代表整体排序，它保证最后返回的数据是全部有序的，详情可参考<a href="https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-orderby.html">文档</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>get_json_object</tag>
        <tag>hive</tag>
        <tag>spark</tag>
        <tag>presto</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf repeated 字段操作总结</title>
    <url>/2021/12/27/protobuf-repeated-%E5%AD%97%E6%AE%B5%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="基本类型复制"><a href="#基本类型复制" class="headerlink" title="基本类型复制"></a>基本类型复制</h1><p>有时会遇到源proto和目标proto具有相同成员的情况, 如果该成员仅仅是定义相同，是不能直接使用CopyFrom方法的，此时需要手动对结构体成员依次进行赋值。<br>以下文件模拟了两个不同proto文件中同时定义了相同的结构体Feature</p>
<figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">ProtoSrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Feature</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">repeated</span> <span class="type">float</span> data = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">optional</span> Feature feature = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">ProtoDst</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Feature</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">repeated</span> <span class="type">float</span> data = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">optional</span> Feature feature = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> src = <span class="built_in">ProtoSrc</span>();</span><br><span class="line"><span class="keyword">auto</span> dst = <span class="built_in">ProtoDst</span>();</span><br><span class="line"><span class="keyword">auto</span> srcFeature = src.<span class="built_in">feature</span>();</span><br><span class="line"><span class="keyword">auto</span> &amp;dstFeature = *dst.<span class="built_in">mutable_feature</span>();</span><br><span class="line"><span class="comment">// 👇错误操作，会有类似报错: Tried to merge messages of different types (merge protosrc.Feature to protodst.Feature)</span></span><br><span class="line"><span class="comment">// dstFeature.CopyFrom(srcFeature);</span></span><br><span class="line"><span class="comment">// 👇正确操作</span></span><br><span class="line">dstFeature.<span class="built_in">mutable_data</span>()-&gt;<span class="built_in">CopyFrom</span>(srcFeature.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure>

<h1 id="复杂类型复制"><a href="#复杂类型复制" class="headerlink" title="复杂类型复制"></a>复杂类型复制</h1><p>以下文件模拟了两个不同proto文件中同时定义了相同的结构体Result</p>
<figure class="highlight proto"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">ProtoSrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Result</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">optional</span> <span class="type">float</span> data = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">message </span><span class="title class_">ProtoDst</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">message </span><span class="title class_">Result</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">optional</span> <span class="type">float</span> data = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">repeated</span> Result results = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> src = <span class="built_in">ProtoSrc</span>();</span><br><span class="line"><span class="keyword">auto</span> dst = <span class="built_in">ProtoDst</span>();</span><br><span class="line"><span class="keyword">auto</span> &amp;dstRes = *(dst.<span class="built_in">mutable_results</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;srcRes : *(src.<span class="built_in">mutable_results</span>()))&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;temp = *(dstRes.<span class="built_in">Add</span>());</span><br><span class="line">    temp.<span class="built_in">set_data</span>(srcRes.<span class="built_in">data</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
        <tag>c++</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>python import 机制</title>
    <url>/2021/08/11/python-import-%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>python中的各种import方式</p>
<span id="more"></span>

<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>目录结构默认如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/project</span><br><span class="line">├── /animal</span><br><span class="line">│   ├── cat.py</span><br><span class="line">│   ├── dog.py</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── main.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>animal/__init__.py</code>中内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;animal imported&quot;)</span><br><span class="line">from .cat import Cat</span><br><span class="line">from .dog import Dog</span><br></pre></td></tr></table></figure>

<p><code>animal/cat.py</code>中内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;Cat imported&quot;)</span><br><span class="line">class Cat(object):</span><br><span class="line">    def __init__(self) -&gt; None:</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<p>其他文件同理</p>
<h2 id="在main中进行import"><a href="#在main中进行import" class="headerlink" title="在main中进行import"></a>在main中进行import</h2><p>import时一定会执行文件夹下的<code>__init__.py</code></p>
<p><code>main.py</code>中为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import animal</span><br><span class="line"># 或</span><br><span class="line">from animal import Cat</span><br><span class="line"># 或</span><br><span class="line">from animal.cat import Cat</span><br><span class="line"># 或</span><br><span class="line">import animal.cat</span><br></pre></td></tr></table></figure>

<p>在<code>/root/project</code>下执行<code>python main.py</code></p>
<p>此时import执行步骤为<br><code>animal/__init__.py</code> -&gt; <code>animal/cat.py</code><br>输出为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animal imported</span><br><span class="line">Cat imported</span><br><span class="line">Dog imported</span><br></pre></td></tr></table></figure>


<h2 id="在子目录中执行-init-py"><a href="#在子目录中执行-init-py" class="headerlink" title="在子目录中执行__init__.py"></a>在子目录中执行__init__.py</h2><p>在<code>/root/project/animal</code>下执行<code>python __init__.py</code></p>
<p>会发生报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animal imported</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;__init__.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    from .cat import Cat</span><br><span class="line">ImportError: attempted relative import with no known parent package</span><br></pre></td></tr></table></figure>


<h2 id="在子目录中直接运行文件"><a href="#在子目录中直接运行文件" class="headerlink" title="在子目录中直接运行文件"></a>在子目录中直接运行文件</h2><p>有时需要在子目录中执行方便的脚本，但是这时就会遇到报错</p>
<p>此时可以通过修改sys.path来自定义搜索范围</p>
<p>首先尝试修改<code>animal/__init__.py</code>中内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from pathlib import Path</span><br><span class="line">package_root = Path(__file__).absolute().parent.parent</span><br><span class="line">print(f&quot;animal imported, add &#123;package_root&#125; to sys.path&quot;)</span><br><span class="line">sys.path.insert(0, str(package_root))</span><br><span class="line">from animal.cat import Cat</span><br><span class="line">from animal.dog import Dog</span><br></pre></td></tr></table></figure>

<p>在<code>/root/project/animal</code>下执行<code>python __init__.py</code></p>
<p>此时输出为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">animal imported, add /root/project/python_pkg_test to sys.path</span><br><span class="line">animal imported, add /root/project/python_pkg_test to sys.path</span><br><span class="line">Cat imported</span><br><span class="line">Dog imported</span><br></pre></td></tr></table></figure>

<p>可以发现print被执行了两遍，实际上所有语句都被执行了两遍，此时打印sys.path会发现存在两个<code>/root/project</code></p>
<p>所以不能直接这样设置, 首先恢复<code>animal/__init__.py</code></p>
<p>新建<code>animal/__init__.py</code>, 其中内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line">from pathlib import Path</span><br><span class="line">package_root = Path(__file__).absolute().parent.parent</span><br><span class="line">print(f&quot;add &#123;package_root&#125; to sys.path&quot;)</span><br><span class="line">sys.path.insert(0, str(package_root))</span><br><span class="line">print(len(sys.path))</span><br></pre></td></tr></table></figure>
<p>在<code>/root/project/animal</code>下执行<code>python mian.py</code></p>
<p>此时输出为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add /root/project to sys.path</span><br><span class="line">[&#x27;/root/project&#x27;, &#x27;/root/project/animal&#x27;, ...]</span><br><span class="line">animal imported</span><br><span class="line">Cat imported</span><br><span class="line">Dog imported</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>import</tag>
        <tag>from</tag>
        <tag>sys.path</tag>
      </tags>
  </entry>
  <entry>
    <title>python 删除超大目录</title>
    <url>/2021/08/11/python-%E5%88%A0%E9%99%A4%E8%B6%85%E5%A4%A7%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>通常，使用shutil.rmtree就可以轻易的删除目录，但是量变产生质变，当目录中的文件数量达到数百万时，我们需要更加快速和平稳的方式</p>
<p>优化的核心思想就是要尽可能减少一切不必要的io</p>
<span id="more"></span>

<h2 id="通常的删除过程"><a href="#通常的删除过程" class="headerlink" title="通常的删除过程"></a>通常的删除过程</h2><ol>
<li>读取目录数据，获得全部的文件</li>
<li>遍历文件，依次获得文件的创建日期等信息(sata)</li>
<li>删除满足条件的文件</li>
</ol>
<p>这样的流程看似没有问题，但是实际上在第一步就会由于读目录给系统造成极大的压力，百万级的目录光是统计一遍就会花费大量的时间。此外在第二部，连续的sata查询也会带来极大的压力。</p>
<p>此外python常用的接口包含了过多不必要的io开销，这些不必要的sata查询会导致io的次数增加数倍，让本来就很慢的过程雪上加霜。</p>
<p>例如：</p>
<ul>
<li>os.listdir：一次性读取，大目录下增加磁盘压力，并且会执行很久</li>
<li>os.walk：间隙读取，但是存在额外的sata读取开销</li>
</ul>
<p>参考：<a href="https://pythonrepo.com/repo/benhoyt-scandir-python-files">https://pythonrepo.com/repo/benhoyt-scandir-python-files</a></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>读取目录数据，获得一个文件</li>
<li>获得文件的创建日期等信息(sata)</li>
<li>删除满足条件的文件</li>
<li>休眠一小段时间</li>
<li>回到第一步</li>
</ol>
<p>这样的流程有相比之前要更加平稳，读取目录和获得sata为一个一个读取，而且可以根据自己的需要灵活的休眠，面对海量文件不会把硬盘打满，给其他程序留一些io资源。</p>
<p>为了达成间断读取的目标，我们需要使用os.scandir这个接口，相比于os.walk，他会直接返回dirent的信息，而不会再去查询sata</p>
<p>以下的代码，实现了对超时文件和目录的删除，但是并没有实现休眠。</p>
<p>关于sata在不同平台上的差异，请参考：<a href="https://docs.python.org/3/library/stat.html">https://docs.python.org/3/library/stat.html</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line">logger = logging.info</span><br><span class="line"><span class="comment"># logger = print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean_by_ttl</span>(<span class="params">path, ttl, dry_run</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    path: 待扫描的目录</span></span><br><span class="line"><span class="string">    ttl: 文件生存时间(time to live)</span></span><br><span class="line"><span class="string">    dry_run: 是否真正进行删除操作</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    logger(<span class="string">f&quot;cleaner: path <span class="subst">&#123;path&#125;</span>, ttl: <span class="subst">&#123;ttl&#125;</span>, dry_run: <span class="subst">&#123;dry_run&#125;</span>&quot;</span>)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    now = time.time()</span><br><span class="line">    <span class="comment"># 待处理列表</span></span><br><span class="line">    process_dir = [path]</span><br><span class="line">    delete_dir = []</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(process_dir) &gt; <span class="number">0</span>:</span><br><span class="line">        logger(<span class="string">f&quot;cleaner: enter dir <span class="subst">&#123;process_dir[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">with</span> os.scandir(process_dir[<span class="number">0</span>]) <span class="keyword">as</span> it:</span><br><span class="line">            file_num = <span class="number">0</span></span><br><span class="line">            delete_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> entry <span class="keyword">in</span> it:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 统计目录下所有文件及子目录数量</span></span><br><span class="line">                file_num += <span class="number">1</span></span><br><span class="line">                life_time = now - entry.stat().st_ctime</span><br><span class="line">                <span class="keyword">if</span> life_time &lt; ttl:</span><br><span class="line">                    logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) skip <span class="subst">&#123;entry.path&#125;</span>, life_time: <span class="subst">&#123;life_time&#125;</span>&quot;</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 统计目录下过期文件及过期子目录数量</span></span><br><span class="line">                    delete_num += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> entry.is_file():</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">not</span> dry_run:</span><br><span class="line">                            logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) delete file <span class="subst">&#123;entry.path&#125;</span>, life_time: <span class="subst">&#123;life_time&#125;</span>&quot;</span>)</span><br><span class="line">                            os.remove(entry.path)</span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) mock delete file <span class="subst">&#123;entry.path&#125;</span>, life_time: <span class="subst">&#123;life_time&#125;</span>&quot;</span>)</span><br><span class="line">                    <span class="keyword">elif</span> entry.is_dir():</span><br><span class="line">                        logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) discover ttl dir <span class="subst">&#123;entry.path&#125;</span>, life_time: <span class="subst">&#123;life_time&#125;</span>&quot;</span>)</span><br><span class="line">                        <span class="comment"># 过期子目录夹放进处理列表继续处理</span></span><br><span class="line">                        process_dir.append(entry.path)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 目录过期，且其下所有文件及子目录均过期，且不是根目录，放进删除列表</span></span><br><span class="line">            <span class="keyword">if</span> process_dir[<span class="number">0</span>] != path:</span><br><span class="line">                <span class="keyword">if</span> file_num == delete_num:</span><br><span class="line">                    logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) determin delete dir <span class="subst">&#123;process_dir[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">                    delete_dir.append(process_dir[<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 由于向文件里写文件时会修改文件夹的ctime，所以实际上走不到这个分支</span></span><br><span class="line">                    logger(<span class="string">f&quot;cleaner: (<span class="subst">&#123;count&#125;</span>) ttl dir <span class="subst">&#123;entry.path&#125;</span> has unttl file, file_num: <span class="subst">&#123;file_num&#125;</span>, delete_num: <span class="subst">&#123;delete_num&#125;</span>&quot;</span>)</span><br><span class="line">            process_dir = process_dir[<span class="number">1</span>:]</span><br><span class="line">    <span class="comment"># 从最内层文件夹开始删除文件夹，因为文件夹内所有项目均过期，此时应该已经成为空文件夹</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> <span class="built_in">reversed</span>(delete_dir):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dry_run:</span><br><span class="line">                logger(<span class="string">f&quot;cleaner: delete dir <span class="subst">&#123;<span class="built_in">dir</span>&#125;</span>&quot;</span>)</span><br><span class="line">                os.rmdir(<span class="built_in">dir</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                logger(<span class="string">f&quot;cleaner: mock delete dir <span class="subst">&#123;<span class="built_in">dir</span>&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger(<span class="string">f&quot;cleaner: err=<span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">            logger(traceback.format_exc())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sata</tag>
        <tag>超大目录</tag>
        <tag>os.listdir</tag>
        <tag>os.walk</tag>
        <tag>os.scandir</tag>
        <tag>dirent</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch GCN 实现以及使用</title>
    <url>/2020/03/05/pytorch-GCN-%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>从最为广泛和简单的理解来看, 在图上利用多个个节点数据进行计算的操作都可以称之为图网络</p>
<span id="more"></span>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>一张图由数个节点组成, 各个节点之间存在单向或双向的边。图只在概念上存在，实际上一张图由节点和邻接矩阵共同表示。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>图中的一个概念上的点, 每个点都携带着一定量的数据。例如以下数据结构, 其中每一行代表一个点, 每一行中的数字代表该点所携带的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4点, 每点包含一个5维的数据</span></span><br><span class="line">[<span class="number">0.4252</span>, <span class="number">0.2733</span>, <span class="number">0.5442</span>, <span class="number">0.7236</span>, <span class="number">0.0515</span>]</span><br><span class="line">[<span class="number">0.5121</span>, <span class="number">0.2056</span>, <span class="number">0.8560</span>, <span class="number">0.3010</span>, <span class="number">0.3110</span>]</span><br><span class="line">[<span class="number">0.0684</span>, <span class="number">0.5282</span>, <span class="number">0.8454</span>, <span class="number">0.0913</span>, <span class="number">0.9803</span>]</span><br><span class="line">[<span class="number">0.4211</span>, <span class="number">0.5779</span>, <span class="number">0.2952</span>, <span class="number">0.3368</span>, <span class="number">0.8389</span>]</span><br></pre></td></tr></table></figure>

<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵是一个 n * n 的矩阵, n 表示节点数目, 每一行都表示一个节点和其他节点是否相连。 对于一个无向图, 他的邻接矩阵总是对称的。例如以下数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4点邻接矩阵</span></span><br><span class="line">[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]</span><br></pre></td></tr></table></figure>

<p>我们观察第一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br></pre></td></tr></table></figure>

<p>表示节点0, 和节点0/2相连。</p>
<h1 id="GCN-定义"><a href="#GCN-定义" class="headerlink" title="GCN 定义"></a>GCN 定义</h1><h1 id="如何实现一个GCN模块"><a href="#如何实现一个GCN模块" class="headerlink" title="如何实现一个GCN模块"></a>如何实现一个GCN模块</h1><p>注意网络输入尺寸为<code>b*(n+c)*n</code>, 前<code>n</code>个channel构成的<code>b*n*n</code>表示邻接矩阵。后<code>b*c*n</code>表示节点数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch import nn</span><br><span class="line">class GraphConvolution(nn.Module):</span><br><span class="line"></span><br><span class="line">    def __init__(self, node_num, input_feature_num, output_feature_num, add_bias=True, dtype=torch.float,</span><br><span class="line">                 batch_normal=True):</span><br><span class="line">        super().__init__()</span><br><span class="line">        # shapes</span><br><span class="line">        self.graph_num = node_num</span><br><span class="line">        self.input_feature_num = input_feature_num</span><br><span class="line">        self.output_feature_num = output_feature_num</span><br><span class="line">        self.add_bias = add_bias</span><br><span class="line">        self.batch_normal = batch_normal</span><br><span class="line"></span><br><span class="line">        # params</span><br><span class="line">        self.weight = nn.Parameter(torch.empty(self.output_feature_num, input_feature_num, dtype=dtype))</span><br><span class="line">        self.bias = nn.Parameter(torch.empty(self.output_feature_num, self.graph_num, dtype=dtype))</span><br><span class="line">        if batch_normal:</span><br><span class="line">            self.norm = nn.InstanceNorm1d(node_num)</span><br><span class="line">            </span><br><span class="line">    def set_trainable(self, train=True):</span><br><span class="line">        for param in self.parameters():</span><br><span class="line">            param.requires_grad = train</span><br><span class="line"></span><br><span class="line">    def forward(self, inp: torch.Tensor):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        @param inp : adjacent: (batch, graph_num, graph_num) cat node_feature: (batch, graph_num, in_feature_num) -&gt; (batch, graph_num, graph_num + in_feature_num)</span><br><span class="line">        @return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        b, c, n = inp.shape</span><br><span class="line">        adjacent, node_feature = inp[:, 0:n, :], inp[:, n:, :]</span><br><span class="line">        x = torch.matmul(self.weight, node_feature)</span><br><span class="line">        x = torch.matmul(x, adjacent)</span><br><span class="line">        if self.add_bias:</span><br><span class="line">            x = x + self.bias</span><br><span class="line">        if self.batch_normal:</span><br><span class="line">            x = self.norm(x)</span><br><span class="line"></span><br><span class="line">        return torch.cat((adjacent, x), dim=1)</span><br></pre></td></tr></table></figure>

<h1 id="残差GCN"><a href="#残差GCN" class="headerlink" title="残差GCN"></a>残差GCN</h1><h1 id="GCN存在的问题"><a href="#GCN存在的问题" class="headerlink" title="GCN存在的问题"></a>GCN存在的问题</h1><h1 id="训练中需要注意的"><a href="#训练中需要注意的" class="headerlink" title="训练中需要注意的"></a>训练中需要注意的</h1><ol>
<li>在训练GCN时必须谨慎使用Norm方法, 否则很可能造成网络不收敛</li>
<li>GCN梯度退化较为严重, 尽量使用残差结构</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>gcn</tag>
        <tag>rsenet</tag>
        <tag>残差</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch 矩阵操作</title>
    <url>/2020/03/05/pytorch-%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="矩阵分片取坐标时超出矩阵范围"><a href="#矩阵分片取坐标时超出矩阵范围" class="headerlink" title="矩阵分片取坐标时超出矩阵范围"></a>矩阵分片取坐标时超出矩阵范围</h1><h2 id="分片出现小于0的坐标会导致赋值无效"><a href="#分片出现小于0的坐标会导致赋值无效" class="headerlink" title="分片出现小于0的坐标会导致赋值无效"></a>分片出现小于0的坐标会导致赋值无效</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y, x = 1, 1</span><br><span class="line">nearby_mask = torch.zeros((6, 6))</span><br><span class="line">nearby_mask[y - 2:y + 2, x - 2:x + 2] = 1</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">[[0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.]]</span><br></pre></td></tr></table></figure>

<h2 id="分片出现大于矩阵尺度的坐标会导致部分赋值"><a href="#分片出现大于矩阵尺度的坐标会导致部分赋值" class="headerlink" title="分片出现大于矩阵尺度的坐标会导致部分赋值"></a>分片出现大于矩阵尺度的坐标会导致部分赋值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y, x = 5, 2</span><br><span class="line">nearby_mask = torch.zeros((6, 6))</span><br><span class="line">nearby_mask[y - 2:y + 2, x - 2:x + 2] = 1</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">[[0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.]]</span><br></pre></td></tr></table></figure>

<h2 id="建议写法"><a href="#建议写法" class="headerlink" title="建议写法"></a>建议写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nearby_mask[max(0, y - 2):y + 2, max(0, x - 2):x + 2] = 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>terraform使用jsonencod输出json字符串</title>
    <url>/2022/09/08/terraform%E4%BD%BF%E7%94%A8jsonencod%E8%BE%93%E5%87%BAjson%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>在terraform中，常见的输出json字符串或创建json文件的手段是使用流式标记, 如下代码所示:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resource <span class="string">&quot;user&quot;</span> <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">&quot;service&quot;</span> <span class="string">&quot;portal&quot;</span> &#123;</span><br><span class="line">  permission = &lt;&lt;<span class="variable constant_">DATA</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;$&#123;user.admin.name&#125;&quot;</span></span><br><span class="line">    <span class="string">&quot;permission&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable constant_">DATA</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样的写法不仅繁琐，也容易出错，由于字符串中夹杂大量的变量引用，<code>DATA</code>标记中间的内容很难提供语法检查<br>常见的错误包括：</p>
<ul>
<li>最后一个元素不能带逗号</li>
<li>引号及括号没有闭合</li>
<li>夹杂中文字符</li>
</ul>
<p>并且这些错误属于json语法问题，在<code>terraform plan</code>甚至<code>apply</code>期间是无法发现的，等到resource部署之后才被发现，可能会造成无法挽回的结果。</p>
<blockquote>
<p>上述代码的json中便缺失一个逗号，读者是否有看出来呢？</p>
</blockquote>
<p>为了解决这些问题，建议大家使用<code>jsonencode</code>函数代替直接编写字符串，得益于tf在语法上的良好兼容，从json迁移到<code>jsonencode</code>并不需要多少工作。</p>
<p>例如上述代码使用jsonencode可以简单的写成如下形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resource <span class="string">&quot;user&quot;</span> <span class="string">&quot;admin&quot;</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resource <span class="string">&quot;service&quot;</span> <span class="string">&quot;portal&quot;</span> &#123;</span><br><span class="line">  permission = <span class="title function_">jsonencode</span>(&#123;</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;$&#123;user.admin.name&#125;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;permission&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到几乎就是简单的使用jsonencode讲原来的内容包了起来。</p>
<p>更进一步的，可以整理成如下形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resource <span class="string">&quot;service&quot;</span> <span class="string">&quot;portal&quot;</span> &#123;</span><br><span class="line">  permission = <span class="title function_">jsonencode</span>(&#123;</span><br><span class="line">    <span class="attr">user</span>: user.<span class="property">admin</span>.<span class="property">name</span>,</span><br><span class="line">    <span class="attr">permission</span>: <span class="string">&quot;*&quot;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resource <span class="string">&quot;service&quot;</span> <span class="string">&quot;portal&quot;</span> &#123;</span><br><span class="line">  permission = <span class="title function_">jsonencode</span>(&#123;</span><br><span class="line">    user = user.<span class="property">admin</span>.<span class="property">name</span></span><br><span class="line">    permission = <span class="string">&quot;*&quot;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于tf语法对逗号非常宽容，因此不论写不写逗号都不会影响输出的json，同时就算有语法错误，在plan阶段也可以轻易发现，还能少写很多引号。</p>
<p>因此推荐大家在输出json时都使用这种方法。</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>terraform</tag>
        <tag>tf</tag>
        <tag>iac</tag>
        <tag>Infrastructure as Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireguard 配置部署及技术讲解</title>
    <url>/2020/03/02/wireguard%E9%83%A8%E7%BD%B2%E5%8F%8A%E6%8A%80%E6%9C%AF%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.wireguard.com/">wiregurad</a>目前已经正式合入linux kernal, 日后的应用范围也一定会越来越广, 本文将会介绍如何使用wireguard创建自己的虚拟局域网, 并完成网关设置</p>
<span id="more"></span>

<h1 id="Wireguard-安装"><a href="#Wireguard-安装" class="headerlink" title="Wireguard 安装"></a>Wireguard 安装</h1><p>对于Ubuntu ≥ 19.10以上的用户, 直接安装即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt install wireguard</span></span><br></pre></td></tr></table></figure>
<p>对于19.04及以下用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo add-apt-repository ppa:wireguard/wireguard</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install wireguard</span></span><br></pre></td></tr></table></figure>

<h1 id="Wireguard-组网设置"><a href="#Wireguard-组网设置" class="headerlink" title="Wireguard 组网设置"></a>Wireguard 组网设置</h1><p>早期的教程中经常使用名为 <code>wg-quick</code> 的命令, 我个人非常不建议使用该工具, 而且官网也移除了关于此命令的相关描述, 因此接下来的操作都讲直接使用 <code>wg</code> 和 <code>ip</code> 命令完成。</p>
<p>wireguard必须在要组网的<strong>所有设备</strong>上都进行以下操作</p>
<h1 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h1><p>首先我们需要添加一块网卡, 并将其命名为 <code>wg0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ip <span class="built_in">link</span> add dev wg0 <span class="built_in">type</span> wireguard</span></span><br></pre></td></tr></table></figure>

<h1 id="设置ip"><a href="#设置ip" class="headerlink" title="设置ip"></a>设置ip</h1><p>添加网卡后为这张网卡配置ip, wireguard无法使用dhcp等功能，我们必须手动为其配置ip, 并且每个设备的ip都不能重复。</p>
<p>注意此处的子网掩码。这里指定的掩码将会在之后被用于设置ip route, 通常wg会自动设置, 但我们也可以手动设置, 这在之后会进行讲解。</p>
<p>因为我需要让所有设备都连接到一台公网设备, 所以我给我的公网设备分配了<code>192.168.100.1</code>的ip。其他设备依次使用<code>192.168.100.(2/3/4)</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ip address add dev wg0 192.168.100.1/24</span></span><br></pre></td></tr></table></figure>

<h1 id="生成连接密钥"><a href="#生成连接密钥" class="headerlink" title="生成连接密钥"></a>生成连接密钥</h1><p>密钥是wg连中最为重要的一环。在两个节点之间, 数据的的接受和发送都需要单独的密钥对。</p>
<p>以A, B两设备为例。A需要持有A的私钥和B的公钥。B需要持有B的私钥和A的公钥。 B向A发送数据需要使用A的公钥。A接受B的数据需要使用A的私钥。</p>
<p>因此两个节点互联共需要2对共4个密钥。注意三个节点互联需要3对共6个密钥而不是4对共8个。因为节点的公钥可以给多个其他节点使用，不需要生成新的密钥对。</p>
<h2 id="生成一对密钥"><a href="#生成一对密钥" class="headerlink" title="生成一对密钥"></a>生成一对密钥</h2><h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">wg genkey</span></span><br><span class="line">6EQR4ABmq4otoOhSYVCJP4BBWKgLzIlTJ4QSPQZAR3s=</span><br></pre></td></tr></table></figure>
<h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><p>生成公钥需要使用之前的私钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> 6EQR4ABmq4otoOhSYVCJP4BBWKgLzIlTJ4QSPQZAR3s= | wg pubkey</span></span><br><span class="line">eCffMZ/2nN8nPDPap5lW4K4gDRw+UANqIQIvBebvTS4=</span><br></pre></td></tr></table></figure>

<h1 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h1><p>以下以一个公网设备A和一个私网(家宽)设备B为例</p>
<h2 id="有公网ip的设备-A"><a href="#有公网ip的设备-A" class="headerlink" title="有公网ip的设备 A"></a>有公网ip的设备 A</h2><p>对于有公网ip的设备, 我们不需要指定 peer 的地址(因为存在NAT指定了也没用), 我们只需要配置私钥和连接端口即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># file: A.conf</span><br><span class="line">[Interface]</span><br><span class="line"># Interface on A</span><br><span class="line">PrivateKey = &lt;A的私钥&gt;</span><br><span class="line">ListenPort = 10240</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line"># A to B</span><br><span class="line">PublicKey = &lt;B的公钥&gt;</span><br><span class="line">AllowedIPs = 192.168.100.2/32</span><br><span class="line">PersistentKeepalive = 10</span><br></pre></td></tr></table></figure>

<h2 id="无公网ip设备-B"><a href="#无公网ip设备-B" class="headerlink" title="无公网ip设备 B"></a>无公网ip设备 B</h2><p>对于有无公网ip的设备, 需要使用<code>Endpoint</code>指定 peer A 的地址, 这样才能在 A, B 之间建立起链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># file: B.conf</span><br><span class="line">[Interface]</span><br><span class="line"># Interface on B</span><br><span class="line">PrivateKey = &lt;B的私钥&gt;</span><br><span class="line">ListenPort = 51820</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line"># B to A</span><br><span class="line">PublicKey = &lt;A的公钥&gt;</span><br><span class="line">Endpoint = &lt;A的公网ip:10240&gt;</span><br><span class="line">AllowedIPs = 192.168.100.0/24</span><br><span class="line">PersistentKeepalive = 10</span><br></pre></td></tr></table></figure>

<h2 id="AllowedIPs"><a href="#AllowedIPs" class="headerlink" title="AllowedIPs"></a>AllowedIPs</h2><p>需要注意两份配置的 AllowedIPs 不同, 对于A来说, peer B 的地址必须为<code>192.168.100.2/32</code>, 而对于B来说, 局域网中的所有 peer 都需要通过A来访问, 所以 AllowedIPs 被设置为 <code>192.168.100.0/24</code>。 </p>
<p>AllowedIPs类似于一个白名单机制, 只有目的地址在AllowedIPs中的包才允许发往该 peer。</p>
<h2 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo wg setconf wg0 xxxx.conf</span></span><br></pre></td></tr></table></figure>

<h1 id="启用网卡"><a href="#启用网卡" class="headerlink" title="启用网卡"></a>启用网卡</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> up dev wg0</span></span><br></pre></td></tr></table></figure>

<h1 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h1><p>创建网卡之后, 我们还需要设置路由, 告诉系统使用wg0网卡处理发往192.168.100.0/24地址的数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ip route add 192.168.100.0/24 dev wg0</span></span><br></pre></td></tr></table></figure>

<p>或者使用完整写法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ip route add 192.168.100.0/24 dev wg0 proto kernel scope <span class="built_in">link</span> src 192.168.100.x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">192.168.100.x 指本机ip</span></span><br></pre></td></tr></table></figure>

<p>如果设置的时候提示 <code>RTNETLINK answers: File exists</code> 则表示wg已经自动设置过路由。可以使用以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo ip route</span> </span><br><span class="line">default via 192.168.1.1 dev enp6s0 proto dhcp src 192.168.1.4 metric 100</span><br><span class="line">192.168.100.0/24 dev wg0 proto kernel scope link src 192.168.100.2</span><br></pre></td></tr></table></figure>

<h1 id="查看连接状态"><a href="#查看连接状态" class="headerlink" title="查看连接状态"></a>查看连接状态</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo wg</span></span><br><span class="line">interface: wg0</span><br><span class="line">  public key: SaarEV3HLvcAaaLhorieaaalNMhCaaaxqVmIpmKwjWY=</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 10240</span><br><span class="line"></span><br><span class="line">peer: taaSMAMx4fMaaXfd1g4Z/c+AaapQRapYnStJ/wVFNjk=</span><br><span class="line">  endpoint: 111.20.8.222:51820</span><br><span class="line">  allowed ips: 192.168.100.2/32</span><br><span class="line">  latest handshake: 1 minute, 48 seconds ago</span><br><span class="line">  transfer: 256.64 KiB received, 200.38 KiB sent</span><br><span class="line">  persistent keepalive: every 10 seconds</span><br></pre></td></tr></table></figure>

<h1 id="网关设置"><a href="#网关设置" class="headerlink" title="网关设置"></a>网关设置</h1><p>请查看iptables forward 及 nat 相关讲解</p>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>route</tag>
        <tag>wireguard</tag>
        <tag>network</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>word文档参考文献按引用顺序自动调整编号</title>
    <url>/2022/05/09/word%E6%96%87%E6%A1%A3%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE%E6%8C%89%E5%BC%95%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E7%BC%96%E5%8F%B7/</url>
    <content><![CDATA[<p>最近在写毕业论文，因为不断的修改添加了大量了引用，导致编号非常混乱，显得非常不美观，</p>
<p>又恰逢女朋友学校强制要求引用目录按照引用顺序排序，因此不得已开发了一个程序来对引用进行自动编号，</p>
<p>开发过程一波三折，难度也比一开始的设想大了很多，</p>
<p>因为需要处理书签引用和纯手写的引用，本来是想使用PyDocX的，测试后发现PyDocX读取书签引用有问题，</p>
<p>最后只能手写个简单的代码解析docx，虽然很麻烦但是总算是搞定了。</p>
<p>项目地址：<a href="https://github.com/Casxt/SortReference">https://github.com/Casxt/SortReference</a></p>
<span id="more"></span>

<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://raw.githubusercontent.com/Casxt/SortReference/main/img/demo.jpg" alt="demo" title="demo"></p>
<h2 id="支持的场景"><a href="#支持的场景" class="headerlink" title="支持的场景"></a>支持的场景</h2><p>请确保文件中中有且只有<code>[n]</code>这一种引用格式，<code>[1-3]</code>或 <code>[1,2,3]</code>等形式需要统一改写成<code>[1][2][3]</code>。</p>
<p>请确保word中所有形如<code>[n]</code>的字符串均代表引用。</p>
<p>否则这些字符也会被计入引用而被错误的改写，如果有的话可以先把不代表引用的字符替换为其他格式比如<code>&lt;n&gt;</code>等到程序处理完后再改写回来。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先确保已经安装python3.6或更高版本。</p>
<ol>
<li><p>使用 pip 安装依赖</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install sort_reference</span><br></pre></td></tr></table></figure></li>
<li><p>指定输入输出文件</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m sort_reference [input] [output] </span><br></pre></td></tr></table></figure>
<p> 如：<code>python -m sort_reference testcase/paper.docx testcase/processed_paper.docx</code></p>
</li>
<li><p>手动处理引用目录顺序</p>
<p> 最后的引用目录重新编号后会如效果图的右图所示，因为word文档结构太复杂了，没法自动对引用目录排序，所以执行完后需要手动调整一下目录顺序。</p>
</li>
</ol>
<p><strong>如果有报错请看github主页里的报错处理方案，大部分时候简单修改一下文档就能解决掉</strong></p>
]]></content>
      <categories>
        <category>word</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>一个新奇的国产web引擎————YC编译器</title>
    <url>/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    <content><![CDATA[<p>最近在网上听说了一个国产的“浏览器”叫做YC浏览器，说是已经开发了好几年了，能把c++像js一样跑。</p>
<p>这种话一听就不靠谱嘛，微软这么大家业也不搞浏览器了。</p>
<p>抱着好奇心我打开了他们的官网：<a href="http://www.ycbro.com/">http://www.ycbro.com/</a>, 一看果然是编译器嘛不是什么浏览器 (然而编译器也没比浏览器简单多少…)。</p>
<p>反正软件也不大，抱着试试玩的心态，我也下了一个看看。</p>
<span id="more"></span>

<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>安装完成后看到两个快捷方式， “YC服务器 D__ycc” 和 “YC编译器 D__ycc”。</p>
<p>打开YC服务器可以看到一个非常复古的界面</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/1.jpg" class="" title="yc服务器界面 200"> </div>

<p>界面上的按钮我都点了一下，没啥用。</p>
<p>经过一番操作呢，我在他们安装目录下发现了一些模板的ysp文件，估计是文件名改了之后没有调整界面上的链接, 直接在浏览器输入路径, 这次成功的打开了<code>http://127.0.0.1/daoshi_info.ysp</code></p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/2.jpg" class="" title="导师信息界面 200"> </div>

<p>提示要安装access, 我比较偷懒就不安了。</p>
<h1 id="上传功能"><a href="#上传功能" class="headerlink" title="上传功能"></a>上传功能</h1><p>经过一番搜索我终于找到了一个功能还比较齐全的页面，也不需要数据库<code>http://127.0.0.1/upload.ysp</code>，有趣的是第一次访问还报错了404，过了一会再次访问就成功了，不禁让人想到这页面可能是动态编译的。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/3.jpg" class="" title="上传界面 200"> </div>

<p>随手上传了两个文件，页面功能还算正常，不过这些都是传统的js功能，并没有什么意思</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/4.jpg" class="" title="上传界面上传后 200"> </div>


<h1 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h1><p>yc还贴心的为我们提供了开发ide，虽然界面略显过时，但是也能看出开发者确实是在自己一点点打磨的，不然直接依托vscode搞一个ide会更香。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/6.jpg" class="" title="ide 200"> </div>

<p>这个ide甚至可以编辑二进制文件，难道这些开发者喜欢手写机器码吗</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/7.jpg" class="" title="二进制编辑 200"> </div>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>打开yc源码目录，可以看到很多ysp文件和cpp文件，一入眼就是一堆avx，略显硬核</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/5.jpg" class="" title="源码 200"> </div>

<p>我打开了<code>sea.ysp</code>, 映入眼帘的是一堆c风格的代码，不过按照ysp的介绍应该是支持cpp的。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/8.jpg" class="" title="sea.ysp 200"> </div>

<p>可以看出在ysp中prinft类似于php中的echo，用于在页面上输出元素。</p>
<p>顺便该页面的输出效果如下</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/9.jpg" class="" title="sea.ysp页面 200"> </div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>yc可以说是当代浮躁的代码界的一股清流，制作者不为外界所扰，潜心制作了一款cpp版php，虽然在当前的技术环境下很难说ycc能有多大的空间去施展拳脚，但至少从这个项目中可以看出老一辈程序员深厚的编程功底和耐得住寂寞的开发精神。</p>
]]></content>
      <categories>
        <category>大开眼界</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>php</tag>
        <tag>yc</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>一次线上数据库结构修改</title>
    <url>/2022/08/02/%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>由于早期数据库设计不合理，需要修改线上数据库表结构，比较麻烦的是新设计将原来的一个表拆成了两个表，并且允许了表之间存在一对多关系。</p>
<span id="more"></span>

<p>为了保证安全的线上变更，设计了如下变更步骤</p>
<h2 id="引入新表"><a href="#引入新表" class="headerlink" title="引入新表"></a>引入新表</h2><p>第一步也是最简单的一步，创建新表结构，此时不会产生任何影响。</p>
<h2 id="并行逻辑执行"><a href="#并行逻辑执行" class="headerlink" title="并行逻辑执行"></a>并行逻辑执行</h2><p>按照新表执行逻辑，将所有涉及旧表的逻辑重写，注意此时并不删除或修改旧逻辑，新老逻辑同时执行，但是忽略新逻辑的报错和结果，只返回旧逻辑结果</p>
<h2 id="数据库双写"><a href="#数据库双写" class="headerlink" title="数据库双写"></a>数据库双写</h2><p>所有数据的读写操作，尤其是写入操作，同时写入新库和旧库</p>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><p>历史数据通过离线系统，逐渐迁移到新表</p>
<h2 id="并行逻辑切换校验"><a href="#并行逻辑切换校验" class="headerlink" title="并行逻辑切换校验"></a>并行逻辑切换校验</h2><p>返回新逻辑结果，检查是否正确，通过测试后可以删除旧逻辑</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>schema</tag>
        <tag>mysql</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划相关题目</title>
    <url>/2021/05/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>动态规划类题目笔记</p>
<span id="more"></span>

<h1 id="买卖K次股票"><a href="#买卖K次股票" class="headerlink" title="买卖K次股票"></a>买卖K次股票</h1><p>假设当前天数为i，股价为p。</p>
<p>若此前一直不进行买卖，其最优利润为<code>dp[0] = 0</code>。</p>
<p>若此前只做过1次买入操作，且最优利润为<code>dp[1]</code>，考虑到今天的股价p。<br>则前i天只做过1次买入操作的最优利润为<code>max(dp[1], dp[0]-p)</code>。<code>dp[0]-p</code>表示如果以此前的最优无操作利润，在今天买入可获得的利润。</p>
<p>若此前只做过1次买入1次卖出操作，且最优利润为<code>dp[2]</code>，考虑到今天的股价p。<br>则前i天只做过1次买入1次卖出操作的最优利润为<code>max(dp[2], dp[1]+p)</code>。<code>dp[1]+p</code>表示如果以此前的最优1次买入的最优利润在今天卖出可获得的总利润。<code>dp[1]+p</code>更大则表示考虑到今天的价格，在今天卖出更合适。</p>
<p>若此前只做过2次买入1次卖出操作，且最优利润为<code>dp[3]</code>，考虑到今天的股价p。<br>则前i天只做过2次买入1次卖出操作的最优利润为<code>max(dp[3], dp[2]-p)</code>。<code>dp[2]-p</code>表示如果以此前的最优1次买入1次卖出可得利润的基础上，如果在今天买入可获得的利润。<code>dp[2]-p</code>更大则表示考虑到之前的买卖价格和今天的价格，在今天进行第2次买入要比在之前买入更合适。</p>
<p>若此前只做过2次买入2次卖出操作，且最优利润为<code>dp[4]</code>，考虑到今天的股价p。<br>则前i天只做过2次买入1次卖出操作的最优利润为<code>max(dp[4], dp[3]+p)</code>。<code>dp[3]+p</code>表示如果以此前的最优2次买入1次卖出的最优利润，在今天卖出可获得的总利润。<code>dp[3]+p</code>更大则表示考虑到今天的价格，在今天卖出更合适。</p>
<p>… …</p>
<h1 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h1><p><a href="https://leetcode-cn.com/problems/burst-balloons/">https://leetcode-cn.com/problems/burst-balloons/</a></p>
<p>使用逆向思维，从戳气球变为安置气球，对于区间[i,j]，遍历[i+1,j-1], 假设每一个位置k为第一插入气球，然后其值加上[i,k]和[k,j]的最优结果。</p>
<p>所有的k中，值最大的即为[i,j]中的最优结果。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>在RedisCluster中Debug lua 脚本.md</title>
    <url>/2022/12/30/%E5%9C%A8RedisCluster%E4%B8%ADDebug-lua-%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>在使用单实例Redis时, 我们可以使用<code>./redis-cli -h redis_ip -p redis 6379 --ldb --eval script.lua somekey , arg1 arg2</code>命令轻松的进入debug模式调试lua脚本<br>在正常情况下, 进入debug模式后可以使用一系列命令来执行控制脚本的执行, 使用help命令应该可以看到如下界面</p>
<span id="more"></span>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lua debugger&gt; <span class="built_in">help</span></span><br><span class="line">Redis Lua debugger <span class="built_in">help</span>:</span><br><span class="line">[h]elp               Show this <span class="built_in">help</span>.</span><br><span class="line">[s]tep               Run current line and stop again.</span><br><span class="line">[n]ext               Alias <span class="keyword">for</span> step.</span><br><span class="line">[c]<span class="built_in">continue</span>          Run till next breakpoint.</span><br><span class="line">[l]list              List <span class="built_in">source</span> code around current line.</span><br><span class="line">[l]list [line]       List <span class="built_in">source</span> code around [line].</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>但是如果你使用的是redis cluster, 当你执行debug后, 大概率会看到如下内容</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Lua debugging session started, please use:</span><br><span class="line">quit    -- End the session.</span><br><span class="line">restart -- Restart the script <span class="keyword">in</span> debug mode again.</span><br><span class="line"><span class="built_in">help</span>    -- Show Lua script debugging commands.</span><br><span class="line"></span><br><span class="line">MOVED 6918 127.0.0.1:6001</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通常你还会看到lua脚本的输出，但是却无法设置任何debug或者断点</p>
<p>即使你输入help, 也只是会看到如下报错, 这种情况下所有的debug命令都无法使用</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lua debugger&gt; <span class="built_in">help</span></span><br><span class="line">ERR unknown <span class="built_in">command</span> `<span class="built_in">help</span>`, with args beginning with: </span><br></pre></td></tr></table></figure>



<p>造成这种现象的原因是你登陆的节点不包含key所属的slot,</p>
<p>解决方法也很简单, 根据consloe输出的<code>MOVED 6918 127.0.0.1:6001</code>指令, 使用redis-cli直接连接对应的redis node就可以顺利进入debug模式。<br>如果丢失了一开始的输出, 可以在界面中执行get操作, 就可以再次看到<code>MOVED</code>关键字。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">lua debugger&gt; get somekey</span><br><span class="line">MOVED 6918 127.0.0.1:6001</span><br></pre></td></tr></table></figure>

<p>重新连接后即可看到正常输出</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Lua debugging session started, please use:</span><br><span class="line">quit    -- End the session.</span><br><span class="line">restart -- Restart the script <span class="keyword">in</span> debug mode again.</span><br><span class="line"><span class="built_in">help</span>    -- Show Lua script debugging commands.</span><br><span class="line"></span><br><span class="line">* Stopped at 1, stop reason = step over</span><br><span class="line">-&gt; 1   <span class="built_in">local</span> expirePTTL = redis.call(<span class="string">&#x27;PTTL&#x27;</span>, KEYS[1])</span><br><span class="line">lua debugger&gt; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>unix time</tag>
        <tag>timestamp</tag>
        <tag>debug</tag>
        <tag>lua</tag>
        <tag>script</tag>
        <tag>redis-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>堆相关知识点</title>
    <url>/2021/05/03/%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>堆类题目堆相关知识点</p>
<span id="more"></span>

<h1 id="golang-最小堆实现"><a href="#golang-最小堆实现" class="headerlink" title="golang 最小堆实现"></a>golang 最小堆实现</h1><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/submissions/">https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/submissions/</a></p>
<p>参考 <a href="https://ieevee.com/tech/2018/01/29/go-heap.html#2-containerheap%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95">https://ieevee.com/tech/2018/01/29/go-heap.html#2-containerheap%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95</a></p>
<p>container/heap</p>
<p>4.1 heap.Init</p>
<p>4.2 heap.Push</p>
<p>4.3 heap.Pop</p>
<p>4.4 heap.Fix</p>
<p>4.5 heap.Remove</p>
<p>实现</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> KthLargest <span class="keyword">struct</span> &#123;</span><br><span class="line">    sort.IntSlice</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IntSlice类型替我们实现了</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func (h KthLargest) Len() int           &#123; return len(h) &#125;</span></span><br><span class="line"><span class="comment">func (h KthLargest) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125;</span></span><br><span class="line"><span class="comment">func (h KthLargest) Swap(i, j int)      &#123; h[i], h[j] = h[j], h[i] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// add x as element Len()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span></span> Push(v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    kl.IntSlice = <span class="built_in">append</span>(kl.IntSlice, v.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// !!注意此处Pop的实现，由于golang heap库在调用heap.Pop方法时，先把元素和最后一个节点的值交换，然后弹出，然后调用 down。因此我们自己实现的方法接收到Pop时，需要被pop的元素实际已经被放置到队尾了</span></span><br><span class="line"><span class="comment">// remove and return element Len() - 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">    a := kl.IntSlice</span><br><span class="line">    v := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    kl.IntSlice = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// heap.Push(kl, val)</span></span><br><span class="line"><span class="comment">// val = heap.Pop(kl)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>知识点速查</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>堆相关题目</title>
    <url>/2021/05/03/%E5%A0%86%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>堆类相关题目</p>
<span id="more"></span>

<h1 id="连续中值"><a href="#连续中值" class="headerlink" title="连续中值"></a>连续中值</h1><p>将半段数字放于一个小根堆，后半段放入大根堆</p>
<p>取小根堆和大根堆的堆顶即可推导出中位数</p>
<p>实际操作时，ruo</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>子序列相关题目</title>
    <url>/2021/05/03/%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>子序列类相关题目</p>
<span id="more"></span>

<h1 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
<p>若nums的前n-1个元素的最大子序列和为M</p>
<p>nums的第N个元素为X</p>
<p>则nums的前n个元素的最大子序列和为max(M+X, X)</p>
<p>以此进行动态规划。</p>
<h1 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h1><p>模拟出入栈即可<br>字符串操作</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">paths := strings.Split(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">s := <span class="string">&quot;/&quot;</span> + strings.Join(stack, <span class="string">&quot;/&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相关题目</title>
    <url>/2021/05/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>字符串类相关题目</p>
<span id="more"></span>

<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
<p>动态规划</p>
<p>已知以位置i-1结束的最长不重复串长为x, 若i处字符到其上一次出现的位置长为n</p>
<p>若 n &gt; x, 则 以位置i结束的最长不重复串长为x+1</p>
<p>若 n &lt;= x, 则 以位置i结束的最长不重复串长为n</p>
<h1 id="验证IP地址"><a href="#验证IP地址" class="headerlink" title="验证IP地址"></a>验证IP地址</h1><p><a href="https://leetcode-cn.com/problems/validate-ip-address/">https://leetcode-cn.com/problems/validate-ip-address/</a></p>
<p>10进制字符串转int<br>n, err := strconv.ParseInt(s, 10, 32)</p>
<p>16进制字符串转int<br>n, err := strconv.ParseInt(s, 16, 32)</p>
<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><p><a href="https://leetcode-cn.com/problems/group-anagrams/">https://leetcode-cn.com/problems/group-anagrams/</a></p>
<p>字符串排序hash</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">code</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    s := []<span class="type">byte</span>(str)</span><br><span class="line">    sort.Slice(s, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;)</span><br><span class="line">    sortedStr := <span class="type">string</span>(s)</span><br><span class="line">    <span class="keyword">return</span> sortedStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">https://leetcode-cn.com/problems/minimum-window-substring/</a></p>
<p>双指针法，不匹配时右移右指针，匹配时记录最短串，并右移左指针。</p>
<p>直到右指针达到末尾并且不匹配</p>
<h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h1><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p>
<p>使用双指针标记窗口，移动窗口依次比较。</p>
<p>使用26长数组代替字典。</p>
<p>进阶：</p>
<p>每次移入元素使得字典某字母数量匹配目标数量，使match++</p>
<p>每次移出元素使得字典某字母数量从匹配目标数量变为不匹配，使match–</p>
<p>当match等于元素种类时，记录当前窗口起始位置</p>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p>
<p>递归遍历</p>
<p>每层选择一个位置i</p>
<p>如果i到达序列尾部，则记录结果，否则</p>
<p>依次将i 与 j([i, len])位置处的数据交换。</p>
<p>如果位置j处的数据在此层之前([i, j-1])出现过，则跳过到下一位置</p>
<p>交换数据后进行递归，从位置i+1开始</p>
<p>递归结束后再次交换，恢复序列，并循环下一j。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>手动挂载Nvidia显卡到docker容器中</title>
    <url>/2020/03/29/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDNvidia%E6%98%BE%E5%8D%A1%E5%88%B0docker%E5%AE%B9%E5%99%A8%E4%B8%AD/</url>
    <content><![CDATA[<p>在docker使用显卡往往需要nvidia的nvidia-container驱动，本文将叫你如何使用原生docker挂载显卡。<br>虽然在最新版的docker中已经内置了nvidia驱动，但是对于podman等其他容器管理来说，这套方法依旧是有意义的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run -it --<span class="built_in">rm</span> \</span><br><span class="line">--device /dev/nvidia-uvm:/dev/nvidia-uvm:rwm \</span><br><span class="line">--device /dev/nvidia-uvm-tools:/dev/nvidia-uvm-tools:rwm \</span><br><span class="line">--device /dev/nvidia0:/dev/nvidia0:rwm \</span><br><span class="line">--device /dev/nvidiactl:/dev/nvidiactl:rwm \</span><br><span class="line">-v /usr/bin/nvidia-smi:/usr/bin/nvidia-smi:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:ro \</span><br><span class="line">ubuntu nvidia-smi</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h1><p>需要映射到容器中的控制设备包括</p>
<ul>
<li>/dev/nvidia-uvm</li>
<li>/dev/nvidia-uvm-tools</li>
<li>/dev/nvidiactl</li>
</ul>
<p>需要映射到容器中的显卡</p>
<ul>
<li>/dev/nvidia0</li>
<li>/dev/nvidia1</li>
</ul>
<p>可以根据需要自行增减数量，显卡编号从0开始，自动增加，nvidia0/nvidia1/nvidia2等等</p>
<h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><p>需要将nvidia驱动映射入容器</p>
<ul>
<li>/usr/bin/nvidia-smi</li>
<li>/usr/lib/x86_64-linux-gnu</li>
</ul>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>对于我们一开始的命令，其输出是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sun Mar 29 06:58:45 2020</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 440.33.01    Driver Version: 440.33.01    CUDA Version: 10.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage/Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|===============================+======================+======================|</span><br><span class="line">|   0  GeForce RTX 208...  Off  | 00000000:AF:00.0 Off |                  N/A |</span><br><span class="line">|  0%   25C    P8    15W / 260W |      0MiB / 11019MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|=============================================================================|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>device</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>数学相关题目</title>
    <url>/2021/05/03/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>数学类相关题目</p>
<span id="more"></span>

<h1 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h1><p><a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p>
<p>考虑数字为4的情况，最大结果为2<em>2<br>考虑数字为5的情况，最大结果为2</em>3<br>考虑数字为6的情况，最大结果为3<em>3<br>考虑数字为7的情况，最大结果为3</em>2<em>2<br>考虑数字为8的情况，最大结果为3</em>3*2<br>所有大于3的数字一定可由2和3相加得到，归纳可证，需要将数字尽可能拆分为3相加</p>
<p>根据 n 除以 3 的余数进行分类讨论：</p>
<p>如果余数为 0，拆分为 n//3个3</p>
<p>如果余数为 1，拆分为 (n//3)-1 个 3和1个4</p>
<p>如果余数为 2，拆分为 n//3 个 3和1个2</p>
<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p>
<p>较为复杂，多复习</p>
<p>不断将位置i和赋值给i+k,直到回到i</p>
<p>从i+1开始重复上述过程</p>
<p>直到处理过的数字和数组长度相等</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组相关题目</title>
    <url>/2021/05/03/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>数组类相关题目</p>
<span id="more"></span>

<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p>
<p>二分之后，必有一边是有序的(因为全局只有一个间断点，该点只能出现于一侧)。检查target是否坐落于有序一侧，如果不位于有序一侧，则一定位于无序一侧。</p>
<p>target取位于的那一侧继续迭代</p>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">https://leetcode-cn.com/problems/first-missing-positive/</a></p>
<p>观察可知，题目所求正数不超过数组长度+1</p>
<p>遍历每一个位置，将该位置上的值x与位置x-1上的值y交换，重复交换直到x == y或 x &lt; 0 或 x &gt; 数组长度。</p>
<p>之后继续下一个位置</p>
<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>寻找左边界和有边界，二分条件大于小于情况照常处理，等于时，如果寻找左边界，则取左区间，反之右区间。</p>
<p>每次mid==target时记录最新的值</p>
<p>循环的s &gt; e 时跳出。</p>
<p>此时的最新mid值即为边界。</p>
<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>
<p>贪心算法，构建队列，遍历数字，当数字大于队尾，则增加该数字，否则，找到第一个大于该数字的元素，修改为该数字。</p>
<p>通过二分查找加速</p>
<p>sort search会返回最小的满足true条件的位置，否则返回len(list)，注意函数中大于等于条件。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">idx := sort.Search(<span class="built_in">len</span>(list), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;<span class="keyword">return</span> list[i] &gt;= n&#125;)</span><br><span class="line"><span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(list) &#123;</span><br><span class="line">    list[idx] = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>树相关知识点</title>
    <url>/2021/05/03/%E6%A0%91%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>树类题目相关知识点</p>
<span id="more"></span>

<h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><p>直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
<h1 id="完全二叉树和满二叉树的区别"><a href="#完全二叉树和满二叉树的区别" class="headerlink" title="完全二叉树和满二叉树的区别"></a>完全二叉树和满二叉树的区别</h1><p>完全二叉树: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边。</p>
<p>满二叉树: 除最后一层无任何子 节点 外，每一层上的所有结点都有两个子结点</p>
<h1 id="前中后层序遍历"><a href="#前中后层序遍历" class="headerlink" title="前中后层序遍历"></a>前中后层序遍历</h1><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<h1 id="求和路径"><a href="#求和路径" class="headerlink" title="求和路径"></a>求和路径</h1><p><a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">https://leetcode-cn.com/problems/paths-with-sum-lcci/</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">https://leetcode-cn.com/problems/path-sum-iii/</a></p>
<p>通过记录前缀和并搜索的方式快速求解</p>
<h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p>
<p>每一个节点可以延伸出26路支路代表26个字母的树。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>知识点速查</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>树相关题目</title>
    <url>/2021/05/03/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>树类相关题目</p>
<span id="more"></span>

<h1 id="检查子树"><a href="#检查子树" class="headerlink" title="检查子树"></a>检查子树</h1><p><a href="https://leetcode-cn.com/problems/check-subtree-lcci/">https://leetcode-cn.com/problems/check-subtree-lcci/</a></p>
<p>递归比较，以每一个节点为头，比较2树是否相同即可</p>
<h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
<p>经过某一结点的最长路径为 左子树高度+右子树高度</p>
<p>遍历每一个树中每一个节点，求得其左右子树高度并计算路径，取最大值作为树的直径</p>
<h1 id="完全二叉树的最后一层的最后一个节点"><a href="#完全二叉树的最后一层的最后一个节点" class="headerlink" title="完全二叉树的最后一层的最后一个节点"></a>完全二叉树的最后一层的最后一个节点</h1><p><a href="https://blog.csdn.net/fangjian1204/article/details/39179343">https://blog.csdn.net/fangjian1204/article/details/39179343</a></p>
<p>先计算树的高度，由于是完全二叉树，左节点遍历到底得到树高h。</p>
<p>之后进入算法</p>
<p>从根节点开始</p>
<p>若h==2，返回当前节点右，左中第一个非空的。</p>
<p>计算右子树高度，若高h，以右节点为根节点重新开始，否则以左节点为根节点重新开始。并令h-1</p>
<h1 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/submissions/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/submissions/</a></p>
<p>压栈法循环取出层</p>
<p>因为之字形打印，倒序遍历上一层，并根据需要按照从右到左或从左到右的顺序压节点</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>模型转换时打包归一化预处理操作</title>
    <url>/2021/12/09/%E6%A8%A1%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%97%B6%E6%89%93%E5%8C%85%E5%BD%92%E4%B8%80%E5%8C%96%E9%A2%84%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>在部署模型时，对于输入数据的预处理是一个非常耗时的操作，其实可以将预处理一同打包到模型中，在转换为ONNX或者Tensorrt模型后这些操作就可以随着模型一起被加速执行。</p>
<p>以最简单的归一化操作为例</p>
<p>归一化Module如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Normalize(torch.nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.register_buffer(&#x27;mean&#x27;, torch.tensor([0.485, 0.456, 0.406], dtype=torch.float64).view(1, -1, 1, 1))</span><br><span class="line">        self.register_buffer(&#x27;std&#x27;, torch.tensor([0.229, 0.224, 0.225], dtype=torch.float64).view(1, -1, 1, 1))</span><br><span class="line">        self.register_buffer(&#x27;norm&#x27;, torch.tensor([255.0], dtype=torch.float64).view(1, 1, 1, 1))</span><br><span class="line"></span><br><span class="line">    def forward(self, images):</span><br><span class="line">        return (images / self.norm - self.mean) / self.std</span><br></pre></td></tr></table></figure>

<p>之后修改模型的inti和forward函数即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MyModel(nn.Module):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(MyModel, self).__init__()</span><br><span class="line">        # ... other code</span><br><span class="line">        self.normalize = Normalize()</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        x = self.normalize(x)</span><br><span class="line">        # ... other code</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>归一化</tag>
        <tag>预处理</tag>
        <tag>Normalize</tag>
        <tag>ONNX</tag>
        <tag>Tensorrt</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器Fetch图片触发CORS</title>
    <url>/2025/03/31/%E6%B5%8F%E8%A7%88%E5%99%A8Fetch%E5%9B%BE%E7%89%87%E8%A7%A6%E5%8F%91CORS/</url>
    <content><![CDATA[<p>最近推进项目POC时, 前端开发报过来一个很奇怪的跨域问题, 在调用接口时经常发生CORS报错, 但是后端已经为所有的域名/方法/header配置了CORS, 理论上不应该发生问题。</p>
<span id="more"></span>

<h1 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h1><p>该问题会发生在一个需要上传的文件的接口, 用户可以从预上传的图片列表中选择其一作为参数调用接口, 而当选择某些图片时便会发生CORS报错（会导致报错的图片会随时间变化并不固定）。</p>
<p>当用户disable cache后所有的图片都不会报错, 并且在此后的一段时间也不会报错, 经过较长时间后, 且没有disbale cache, 某些图片又会开始报错。</p>
<p>在报错时, 可以看到前端发起了一次网络请求尝试下载图片, 但该请求被cache并发生报错。问题在于后端一直使用CORS, 即便是cache也会将CORS header一起缓存, 没有道理缓存到没有CORS的图片。</p>
<h1 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h1><p>在后端已经通过fast api配置了CORS, 经过自己检查没有发现任何问题</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">app.add_middleware(</span><br><span class="line">    CORSMiddleware,</span><br><span class="line">    allow_origins=[</span><br><span class="line">        <span class="string">&quot;http://localhost:3000&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://127.0.0.1:3000&quot;</span>,</span><br><span class="line">        <span class="comment"># ...</span></span><br><span class="line">    ],  <span class="comment"># 允许所有来源</span></span><br><span class="line">    allow_credentials=<span class="literal">True</span>,  <span class="comment"># 允许携带凭证</span></span><br><span class="line">    allow_methods=[<span class="string">&quot;*&quot;</span>],  <span class="comment"># 允许所有HTTP方法</span></span><br><span class="line">    allow_headers=[<span class="string">&quot;*&quot;</span>],  <span class="comment"># 允许所有HTTP头</span></span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="前端报错逻辑"><a href="#前端报错逻辑" class="headerlink" title="前端报错逻辑"></a>前端报错逻辑</h1><p>前端的报错逻辑非常简单, 尝试下载图片时报错</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imgResponse = <span class="keyword">await</span> <span class="title function_">fetch</span>(selectedImageUrl);</span><br></pre></td></tr></table></figure>

<h1 id="调查思路"><a href="#调查思路" class="headerlink" title="调查思路"></a>调查思路</h1><p>pass</p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>经过一系列debug, 终于找到问题的原因。</p>
<p>首先需要知道, 浏览器的img标签并不检查跨域, 因此img标签加载图片时, 请求header中只有refer而没有origin。</p>
<p>而根据规范, 只有在origin header存在时才会设置CORS header。</p>
<p>至此我们知道报错发生的过程如下：</p>
<ol>
<li>浏览器通过img标签依次加载列表中的图片以便用户选择</li>
<li>某些图片的缓存过期, 浏览器得到没有CORS的response, 并缓存</li>
<li>用户选择图片, 前端代码尝试fetch图片, 命中缓存</li>
<li>缓存response没有CORS, 报错</li>
</ol>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="1-为-标签添加-crossOrigin-属性"><a href="#1-为-标签添加-crossOrigin-属性" class="headerlink" title="1. 为  标签添加 crossOrigin 属性"></a>1. 为 <img> 标签添加 crossOrigin 属性</h2>  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;your-image-url&quot;</span> <span class="attr">crossOrigin</span>=<span class="string">&quot;anonymous&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-在-fetch-请求中禁用缓存"><a href="#2-在-fetch-请求中禁用缓存" class="headerlink" title="2. 在 fetch 请求中禁用缓存"></a>2. 在 fetch 请求中禁用缓存</h2>  <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imgResponse = <span class="keyword">await</span> <span class="title function_">fetch</span>(selectedImageUrl, &#123;</span><br><span class="line">  <span class="attr">cache</span>: <span class="string">&#x27;no-cache&#x27;</span> <span class="comment">// 或 &#x27;reload&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因为只是POC, 最后选用方案2解决</p>
<h2 id="no-cache-vs-reload"><a href="#no-cache-vs-reload" class="headerlink" title="no-cache vs reload"></a>no-cache vs reload</h2><p>no-cache: 若服务器返回 304 Not Modified（资源未变化），则使用缓存。</p>
<p>reload: 浏览器完全跳过缓存检查，直接向服务器请求最新资源</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">是否验证缓存</th>
<th align="center">是否可能复用缓存</th>
<th align="center">网络请求次数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">no-cache</td>
<td align="center">✓</td>
<td align="center">✓ (304 响应时)</td>
<td align="center">至少 1 次</td>
</tr>
<tr>
<td align="center">reload</td>
<td align="center">✗</td>
<td align="center">✗</td>
<td align="center">强制 1 次</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
        <tag>CORS</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>知识点扫盲</title>
    <url>/2020/03/02/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%AB%E7%9B%B2/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="linux用户登录流程"><a href="#linux用户登录流程" class="headerlink" title="linux用户登录流程"></a>linux用户登录流程</h1><ul>
<li>init 阶段， 读/etc/inittab -&gt; /etc/rc.local</li>
<li>getty 用于监听本地consloe, 打出username:, 获得用户输入之后调起/ets/login打出password:</li>
<li>读/etc/passwd /etc/shadow 检查用户密码</li>
<li>拉起shell</li>
<li>读/etc/passwd 获取用户目录等信息，读/etc/motd获取欢迎界面</li>
<li>读/etc/profile -&gt; /etc/bashrc -&gt; .profile 或 .login</li>
<li>读.bashrc, .bash_profile</li>
</ul>
<h1 id="locked-page-memory"><a href="#locked-page-memory" class="headerlink" title="locked page memory"></a>locked page memory</h1><h1 id="cgroup-使用"><a href="#cgroup-使用" class="headerlink" title="cgroup 使用"></a>cgroup 使用</h1><h1 id="数据库隔离机制"><a href="#数据库隔离机制" class="headerlink" title="数据库隔离机制"></a>数据库隔离机制</h1><h1 id="ssh-登录机制"><a href="#ssh-登录机制" class="headerlink" title="ssh 登录机制"></a>ssh 登录机制</h1><h2 id="ssh-与-tty-ptmx-pts"><a href="#ssh-与-tty-ptmx-pts" class="headerlink" title="ssh 与 tty ptmx pts"></a>ssh 与 tty ptmx pts</h2><p><a href="https://segmentfault.com/a/1190000009082089">https://segmentfault.com/a/1190000009082089</a></p>
<h2 id="ssh-与-tls"><a href="#ssh-与-tls" class="headerlink" title="ssh 与 tls"></a>ssh 与 tls</h2><ul>
<li>ssh验证双方，tls只验证服务端</li>
<li>ssh在应用层，tls在传输层</li>
<li>ssh同时完成验证和加密，tls可以不验证只加密</li>
</ul>
<h1 id="shm"><a href="#shm" class="headerlink" title="shm"></a>shm</h1><h1 id="GPU"><a href="#GPU" class="headerlink" title="GPU"></a>GPU</h1><h1 id="cuda-engine-context-stream"><a href="#cuda-engine-context-stream" class="headerlink" title="cuda engine context stream"></a>cuda engine context stream</h1><p>engine是trt中的概念</p>
<p>context 是一个执行上下文，保存了各种状态，可以用push和pop方法出入栈，每个进程执行时必须要有一个context，通常每一个thread会分配一个独立的context</p>
<h2 id="同一卡上能否同时存在两个context？"><a href="#同一卡上能否同时存在两个context？" class="headerlink" title="同一卡上能否同时存在两个context？"></a>同一卡上能否同时存在两个context？</h2><p>stream 代表了一系列gpu任务，包括内存拷贝，执行等，同一个context下可以有多个stream，stream之间可以并行运行，stream执行结束后可以触发回调</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="b-tree-为什么快"><a href="#b-tree-为什么快" class="headerlink" title="b+tree 为什么快"></a>b+tree 为什么快</h2><h2 id="索引可以加在text上吗"><a href="#索引可以加在text上吗" class="headerlink" title="索引可以加在text上吗"></a>索引可以加在text上吗</h2><h1 id="四次挥手的合并"><a href="#四次挥手的合并" class="headerlink" title="四次挥手的合并"></a>四次挥手的合并</h1><p>客户端主动发起fin，如果服务端不需要回复对应的ack会出现如下情况。<br>情况1：</p>
<ol>
<li>客户端发起fin，服务端未收到</li>
<li>客户端停止发送数据，并开始等待服务端剩余数据和fin</li>
<li>服务端不知道客户端已经发送fin，发送完当前数据后，开始等待客户端数据</li>
<li>服务端和客户端互相等待无法脱出。</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵相关题目</title>
    <url>/2021/05/03/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>矩阵类相关题目</p>
<span id="more"></span>

<h1 id="螺旋矩阵-回形打印二维数组"><a href="#螺旋矩阵-回形打印二维数组" class="headerlink" title="螺旋矩阵 回形打印二维数组"></a>螺旋矩阵 回形打印二维数组</h1><p><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/">https://leetcode-cn.com/problems/spiral-matrix/solution/</a></p>
<p>使用四个循环依次打印四条边即可，使用计数器记录已经访问过的元素数目。</p>
<p>在打印上边和右边之后以及打印四条边之后判断计数器即可。</p>
<p>如果记不住，每条边打印前都判断一次也可</p>
<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p>
<p>从左上角开始沿一条边逐个访问元素，</p>
<p>每个元素和其他四条边中相对起始位置相同的元素交换</p>
<p>他四条边中相对起始位置相同的元素坐标可以推算出来</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>线上Cache系统设计</title>
    <url>/2024/04/21/%E7%BA%BF%E4%B8%8ACache%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>缓存一直是线上系统不可或缺的部分，本文总结了缓存系统中需要关注的一些问题</p>
<span id="more"></span>

<h1 id="缓存系统的挑战"><a href="#缓存系统的挑战" class="headerlink" title="缓存系统的挑战"></a>缓存系统的挑战</h1><ul>
<li>缓存击穿 Cache Breakdown: 热点数据突然过期<ul>
<li>Data sharing</li>
<li>Async Refresh / Pre Fetch</li>
<li>Request aggregation</li>
</ul>
</li>
<li>缓存雪崩 Cache Avalanche: 所有的缓存数据同时失效</li>
<li>缓存穿透 Cache Penetration: 查询不存在的数据<ul>
<li>Content filter</li>
<li>Error cacheing</li>
</ul>
</li>
<li>内存管理<ul>
<li>堆外内存 vs 堆内内存</li>
</ul>
</li>
<li>淘汰策略<ul>
<li>Memory Limit</li>
<li>Time Limit</li>
</ul>
</li>
<li>数据管理<ul>
<li>Marshal vs Raw Object (marshal cost vs GC cost)</li>
<li>Lock vs Bucket Lock vs Object Lock</li>
</ul>
</li>
</ul>
<h2 id="Data-sharing"><a href="#Data-sharing" class="headerlink" title="Data sharing"></a>Data sharing</h2><p>通过网络或其它中间件在不同节点间共享缓存数据，可以在单node数据过期时快速通过其他拥有更新数据的节点快速恢复，避免回源降低延迟</p>
<h2 id="Async-Refresh-Pre-Fetch"><a href="#Async-Refresh-Pre-Fetch" class="headerlink" title="Async Refresh / Pre Fetch"></a>Async Refresh / Pre Fetch</h2><p>通过给数据设置软过期时间，在真正过期之前就异步刷新数据，避免用户等待回源。</p>
<p>同时通过提前刷新，在源服务报错时留出重试和恢复的时间</p>
<h2 id="Request-aggregation"><a href="#Request-aggregation" class="headerlink" title="Request aggregation"></a>Request aggregation</h2><p>在多个client请求相同的需要回源的数据时，只进行一次回源，避免多次请求</p>
<h2 id="Content-filter"><a href="#Content-filter" class="headerlink" title="Content filter"></a>Content filter</h2><p>通过布隆过滤器等手段，阻止对不存在资源的请求，避免大量回源压垮服务</p>
<h2 id="Error-cacheing"><a href="#Error-cacheing" class="headerlink" title="Error cacheing"></a>Error cacheing</h2><p>在回源报错的情况下，适当缓存源错误并返回给用户，避免错误情况下持续回源压垮后端服务。</p>
<p>目前开源cache组件支持error cache的很少，但实际上这是一个非常实用的服务，当缓存中数据不存在或过期的请求，如果回源报错（4XX，5XX），可以短暂缓存源报错，缓存时间可以是正常缓存时间的十分之一或更短，能够有效避免对源服务的恶意攻击。</p>
<h2 id="堆外内存-vs-堆内内存"><a href="#堆外内存-vs-堆内内存" class="headerlink" title="堆外内存 vs 堆内内存"></a>堆外内存 vs 堆内内存</h2><p>常见的缓存服务的内存申请基本上可以分为堆内和堆外两大方向，对于有GC语言来说，堆外内存可以减少GC消耗，代价就是cache需要自己管理内存。<br>而堆内则有实现简单可靠的有点，并且可以配合对象缓存进一步避免序列化开销。</p>
<p>堆外内存的另一个缺点是无法按需分配，往往需要提前分配几百M到几G的内存空间，并且难以缩扩容，会造成一定的资源浪费。</p>
<h2 id="Marshal-vs-Raw-Object"><a href="#Marshal-vs-Raw-Object" class="headerlink" title="Marshal vs Raw Object"></a>Marshal vs Raw Object</h2><p>对于缓存数据的存储，同样存在两大方向，分别是序列化后存储和直接缓存数据对象。</p>
<p>通常使用堆外缓存方案的cache需要使用序列化方案，一方面堆外内存不容易直接映射为语言呢的对象，另一方面序列化后只需要管理字节数组，内存管理的难度大幅下降。</p>
<p>而使用堆内内存的cache系统则可以直接缓存对象，可以避免序列化开销（有时序列化开销占比会非常大），如果cache对象不需要修改，甚至可以避免拷贝开销，同时节省内存和cpu</p>
<h2 id="Lock-vs-Bucket-Lock-vs-Object-Lock"><a href="#Lock-vs-Bucket-Lock-vs-Object-Lock" class="headerlink" title="Lock vs Bucket Lock vs Object Lock"></a>Lock vs Bucket Lock vs Object Lock</h2><p>通常的cache系统可以抽象为一个map，同map一样会面临并发读写的难题</p>
<p>而解决方案也可以照搬map的Bucket Lock 或 Object Lock。</p>
<h1 id="单节点缓存系统的工作流程"><a href="#单节点缓存系统的工作流程" class="headerlink" title="单节点缓存系统的工作流程"></a>单节点缓存系统的工作流程</h1><div style="width:100%;margin:auto"> <img src="/2024/04/21/%E7%BA%BF%E4%B8%8ACache%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/cache-state-transition.jpg" class="" title="cache-state-transition 200"> </div>

<p>如上图展示的，在一个缓存系统中，cache可能出现的所有状态<br>大体上，cache状态可以分为三大部分，对应超时数据，异常数据和正常数据<br>当cache刚建立时，会从init状态迁移到数据超时状态，此时数据需要在阻塞模式下同步更新，更新期间所有发来的请求都会被阻塞</p>
<p>同步更新状态的转移有2种可能，</p>
<ol>
<li>同步更新中如果updatefn返回error，则cache状态会转移到异常重试冷却状态，在这个状态下，cache仍然会缓存之前updatefn返回的error response，并通过用户请求触发异步更新，更新的最小间隔是200ms（或者其他用户设定的间隔），如果更新失败，则缓存最新的error response，如果成功则迁移到正常数据的状态流中。</li>
</ol>
<p>此外，由于更新是通过用户请求触发的，如果在得到异常数据后很久没有没有请求，还会再次回到同步更新状态。</p>
<ol start="2">
<li>在得到正常数据后，cache在SoftLime时间内只返回数据而不进行更新，当缓存时间超过SoftLime而不超过HardLimt时，cache在用户请求时会触发异步更新，而如果超过了HardLimt则会进行同步更新。在缓存了正常数据的状态下，如果updatefn返回了error，cache会继续保存之前的成功的返回值而不会保存失败返回，同时也不会更新update time，在下一次用户请求时会再次触发异步更新，但是如果update持续失败，缓存时间超过了HardLim回到同步更新状态，此时更新失败会导致回到异常数据状态</li>
</ol>
<h1 id="多节点共享数据的缓存更新流程-通过redis共享数据"><a href="#多节点共享数据的缓存更新流程-通过redis共享数据" class="headerlink" title="多节点共享数据的缓存更新流程(通过redis共享数据)"></a>多节点共享数据的缓存更新流程(通过redis共享数据)</h1><div style="width:50%;margin:auto"> <img src="/2024/04/21/%E7%BA%BF%E4%B8%8ACache%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/cache-data-sharing.jpg" class="" title="cache-data-sharing 200"> </div>

<p>Shared object cache 通过redis在cache之间共享数据，可以在单node数据过期时快速通过其他拥有更新数据的节点快速恢复，避免回源降低延迟，作为一个可选的中间件，引入data sharing后的更新流程比起单机版的cache会更复杂一点，</p>
<p>为了避免引入redis导致cache data的ttl混乱，redis中除了数据外，还记录了updatetime和编码类型</p>
<p>在真正执行用户的update function之前，会先检查reids中是否有可用数据</p>
<p>redis中，每个cache item 的 HASHS Struct 如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">data</span>: &lt;data&gt;</span><br><span class="line">    <span class="attr">marshal</span>: &lt;marshalType&gt;</span><br><span class="line">    <span class="attr">update</span>: &lt;updateAtMs&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了保证缓存更新的原子性，在更新数据时通过如下lua比较尝试写入的数据是否新于已有数据，并返回最新数据的时间戳，通过返回的时间戳，调用方也可以知道自己写入是否成功</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> expirePTTL = redis.call(<span class="string">&#x27;PTTL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> (expirePTTL &gt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">local</span> serverTime = redis.call(<span class="string">&#x27;TIME&#x27;</span>)</span><br><span class="line">   <span class="keyword">local</span> expireTime = <span class="built_in">tonumber</span>(serverTime[<span class="number">1</span>]) * <span class="number">1000</span> + <span class="built_in">tonumber</span>(serverTime[<span class="number">2</span>] / <span class="number">1000</span>) + expirePTTL</span><br><span class="line">   <span class="keyword">if</span> (expireTime &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>]))  <span class="keyword">then</span></span><br><span class="line">       <span class="keyword">return</span> expireTime</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&#x27;HSET&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], ARGV[<span class="number">3</span>], ARGV[<span class="number">4</span>], ARGV[<span class="number">5</span>], ARGV[<span class="number">6</span>], ARGV[<span class="number">7</span>])</span><br><span class="line">redis.call(<span class="string">&#x27;PEXPIREAT&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> ARGV[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>为了准确控制过期时间没有使用传统的TTL设置生存周期，而是使用用PEXPIREAT设置毫秒即的过期时间戳，这样即使指令的发送和执行上有一些延迟，最终的数据TTL还是严格和cache instance 一致的<br>并且在update时，会检查当前数据的过期时间戳和已经存在的数据的过期时间戳谁更大，只有最新的数据才能留存在redis中。<br>这里有一个限制，在redis7之前，设置超时时间戳可以使用PEXPIREAT，但是设置后就无法再次获取时间戳了，只能使用PTTL获取剩余的毫秒级TTL，在redis7之后新增了PEXPIRETIME指令可以获取原始的时间戳。</p>
<h1 id="Steam-Cache"><a href="#Steam-Cache" class="headerlink" title="Steam Cache"></a>Steam Cache</h1><div style="width:50%;margin:auto"> <img src="/2024/04/21/%E7%BA%BF%E4%B8%8ACache%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/stream-cache.jpg" class="" title="stream-cache 200"> </div>

<p>出了常见的object cache，对于流数据的缓存也是比较常见的一个场景</p>
<p>Stream cache对外的表现是一个滑动窗，在第一次缓存建立后，会主动向更新和更老的feed，尽享填满自己缓存窗口从而满足用户请求</p>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次libc损坏的惊险经历</title>
    <url>/2021/12/19/%E8%AE%B0%E4%B8%80%E6%AC%A1libc%E6%8D%9F%E5%9D%8F%E7%9A%84%E6%83%8A%E9%99%A9%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<p>最近看到知乎上，关于最让自己印象深刻的一次bug的经历，的讨论，不禁让我回想起了研一时，那一次libc依赖损坏的事故。</p>
<span id="more"></span>

<p>当时需要在断网服务器集群上部署一个caffe程序，负责部署的同学跟我说他的程序需要升级libc，我并未多想，给他的账号开通root权限后让他自行操作(我以为他会使用yum安装)。</p>
<p>许久之后，他突然找到我说，服务器崩溃了，ssh无法连接，我立刻新建了一个ssh测试了一下，果然出了错误，我的心一下子就揪了起来，因为此时我还无法确定ssh崩溃的原因是什么，如果只是配置文件的问题还好说，如果是系统问题那麻烦就大了。</p>
<p>当时我非常慌张，这台服务器上已经配置了许多服务，如果此时重装服务器，之前的努力将会前功尽弃，而且重装需要专人上门配置，如此一来工期就会大大拖延，我用最短的时间跟他确认了在崩溃之前进行的操作，在一大通对账之后，我惊讶的发现他自己编译出libc并直接使用make install安装到了系统里，由于一些现在已经不可考据的原因跟系统不兼容，大部分命令已经无法使用了。</p>
<p>当时的情况是原系统中/lib64/libc.so.6软链到/lib64/libc-2.12.so，被手动make install之后软链变成了指向/lib64/libc-2.23.so，之后大量的命令无法使用</p>
<p>报错类似于<code>error while loading shared libraries: __vdso_time: invalid mode for dlopen(): Invalid argument</code></p>
<p>万幸的是手上当时还有一个ssh连接没有关闭，我冷静下来，使用LD_PRELOAD=/lib64/libc-2.12.so [cmd]进行尝试，发现还可以恢复这部分命令。最后在小心翼翼的恢复了软链之后，又从集群中的其他机器上复制了根目录下的文件进行替换，才彻底解决了这次事件，之后我第一时间下掉了他的root权限，并告知他以后他的libc依赖只能自己指定环境变量来加载。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次rpc接口无返回调试经历</title>
    <url>/2022/03/18/%E8%AE%B0%E4%B8%80%E6%AC%A1rpc%E6%8E%A5%E5%8F%A3%E6%97%A0%E8%BF%94%E5%9B%9E%E8%B0%83%E8%AF%95%E7%BB%8F%E5%8E%86/</url>
    <content><![CDATA[<h1 id="现象描述"><a href="#现象描述" class="headerlink" title="现象描述"></a>现象描述</h1><p>偶然发现一个线上服务不返回的badcase，在输入特定一张图片时，分析服务会直接断开连接而不返回任何数据，这种情况是非常罕见的，因为通常来说即便是内部服务报错的情况下，也会被框架捕获从而返回一组错误码，而不会直接断开连接不返回任何数据。</p>
<h1 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h1><p>考虑到这个现象可以被特定数据触发，且触发后业务依旧可以正常处理后续请求，因此认为是业务逻辑的问题，但是还不清楚业务逻辑是如何影响框架导致连接被关闭的。</p>
<h1 id="初步调试"><a href="#初步调试" class="headerlink" title="初步调试"></a>初步调试</h1><p>现象能稳定复现，应该是比较容易调试的，我首先将一台线上服务熔断，手动登录后打开日志调试。</p>
<p>请求后惊奇的发现业务逻辑<code>没有任何报错</code>，由于业务逻辑不是我写的，所以整个逻辑对我来说如同黑箱一样。</p>
<p>为了找到问题的原因，我将一张正常图片产生的日志和问题图片产生的日志都记录下来，并逐行对比，遗憾的是<code>没有发现任何不同</code>。</p>
<h1 id="再次分析"><a href="#再次分析" class="headerlink" title="再次分析"></a>再次分析</h1><p>到这一步已经是山穷水尽了，因为通过日志打点分析，整个业务逻辑是正常return的，现在只能将目光转向框架层，但是遗憾的是框架层同样是一个黑箱，并且通过分析框架层的日志，也没有发现任何异常。</p>
<p>结合连接直接断开的现象，我怀疑框架层中的worker在返回请求时崩溃，并且被自动重启了。而导致崩溃的原因，只能是在业务逻辑中返回的response结构体上。</p>
<p>大胆猜测，是返回值被设置了特殊值导致框架层崩溃的。</p>
<h1 id="再次调试"><a href="#再次调试" class="headerlink" title="再次调试"></a>再次调试</h1><p>将设置response的代码全部注释后，果然可以正常返回空结构体，确认了之前的猜测。</p>
<p>之后通过二分注释的方法，确认了问题出在一个float字段上，当float字段被设置为Nan时，会导致无返回的现象发生，至此问题确认。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>protobuf本身是支持nan作为值的，因此是框架层自己的兼容性问题，但是这种一言不合就暴毙的问题排查，着实令人头疼。</p>
]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>protobuf</tag>
        <tag>c++</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>谨慎使用CREATE-SELECT语句复制表数据</title>
    <url>/2022/08/03/%E8%B0%A8%E6%85%8E%E4%BD%BF%E7%94%A8CREATE-SELECT%E8%AF%AD%E5%8F%A5%E5%A4%8D%E5%88%B6%E8%A1%A8%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>在复制表时，可以使用CREATE-SELECT来同时复制表结构和数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">FROM</span> old_table;</span><br></pre></td></tr></table></figure>
<p>但这样做实际上是有问题的</p>
<p>原因在于，CREATE-SELECT在创建新表时仅复制了字段类型，但是不会设置主键子增等属性。</p>
<p>因此，在复制表时，最好还是使用CREATE-LIKE和INSERT来复制</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">LIKE</span> old_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> new_table <span class="keyword">SELECT</span>  <span class="operator">*</span> <span class="keyword">FROM</span> old_table;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>backend</category>
      </categories>
      <tags>
        <tag>schema</tag>
        <tag>mysql</tag>
        <tag>database</tag>
      </tags>
  </entry>
  <entry>
    <title>通过 Github Actions 部署 Github Pages</title>
    <url>/2024/04/09/%E9%80%9A%E8%BF%87Github-Actions%E9%83%A8%E7%BD%B2Github-Pages/</url>
    <content><![CDATA[<p>在项目的 settings 中 github pages 可以通过根目录或docs目录部署。但是这种方式不够灵活，对于一些前段项目，需要不停的通过CI生成站点文件，提交到git中再部署，git中存储了许多构建产物，显得冗余臃肿。</p>
<p>实际上，github也支持通过actions来部署pages，不需要将站点文件储存在git中。</p>
<span id="more"></span>

<p>要通过actions部署pages，需要如下步骤：</p>
<ol>
<li>在workflow中构建站点文件，并保存到一个目录中</li>
<li>调用tar命令将构建好的站点目录打包为tar包，注意此时只打包不要做压缩</li>
<li>调用<code>actions/upload-artifact</code>action将打包好的tar包上传到artifact，注意name参数必须为<code>github-pages</code>，path 参数为你tar包的路径</li>
<li>调用<code>actions/deploy-pages</code>即可将tar包中的内容作为站点内容部署</li>
</ol>
<p>在<a href="https://github.com/Casxt/BangumiTracker">Bangumi Tracker</a>项目中就使用了这个构建方式。<br>网站链接为<a href="https://bangumi.maple.link./">https://bangumi.maple.link。</a></p>
<p>以下workflow展示了安装npm和yarn依赖，构建站点，tar打包，上传的过程。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">CI/CD</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">&quot;main&quot;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages</span></span><br><span class="line"><span class="attr">permissions:</span></span><br><span class="line">  <span class="attr">contents:</span> <span class="string">read</span></span><br><span class="line">  <span class="attr">pages:</span> <span class="string">write</span></span><br><span class="line">  <span class="attr">id-token:</span> <span class="string">write</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.</span></span><br><span class="line"><span class="comment"># However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.</span></span><br><span class="line"><span class="attr">concurrency:</span></span><br><span class="line">  <span class="attr">group:</span> <span class="string">&quot;pages&quot;</span></span><br><span class="line">  <span class="attr">cancel-in-progress:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pages-ci-cd:</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">github-pages</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.deployment.outputs.page_url</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">inputs.source_branch</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Node.js</span> <span class="number">20.</span><span class="string">x</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="number">20</span></span><br><span class="line">        <span class="attr">cache:</span> <span class="string">&#x27;npm&#x27;</span></span><br><span class="line">        <span class="attr">cache-dependency-path:</span> <span class="string">app/yarn.lock</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">install</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">borales/actions-yarn@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">dir:</span> <span class="string">&#x27;app&#x27;</span></span><br><span class="line">        <span class="attr">cmd:</span> <span class="string">install</span> <span class="comment"># will run `yarn install` command</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Generate</span> <span class="string">Protobuf</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">./generate_proto_ts.sh</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        cd app</span></span><br><span class="line"><span class="string">        yarn build</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Archive</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">shell:</span> <span class="string">sh</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        echo ::group::Archive artifact</span></span><br><span class="line"><span class="string">        tar \</span></span><br><span class="line"><span class="string">          --dereference --hard-dereference \</span></span><br><span class="line"><span class="string">          --directory &quot;app/build&quot; \</span></span><br><span class="line"><span class="string">          -cvf &quot;artifact.tar&quot; \</span></span><br><span class="line"><span class="string">          --exclude=.git \</span></span><br><span class="line"><span class="string">          --exclude=.github \</span></span><br><span class="line"><span class="string">          .</span></span><br><span class="line"><span class="string">        echo ::endgroup::</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">artifact</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">upload-artifact</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">github-pages</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">artifact.tar</span></span><br><span class="line">        <span class="attr">retention-days:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">if-no-files-found:</span> <span class="string">error</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">GitHub</span> <span class="string">Pages</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">deployment</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/deploy-pages@v4</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>github</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>actions</tag>
        <tag>pages</tag>
      </tags>
  </entry>
  <entry>
    <title>配置一个Jetbrain风格的MacOS Terminal</title>
    <url>/2022/07/27/%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAJetbrain%E9%A3%8E%E6%A0%BC%E7%9A%84MacOS-Terminal/</url>
    <content><![CDATA[<div style="width:50%;margin:auto"> <img src="/2022/07/27/%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAJetbrain%E9%A3%8E%E6%A0%BC%E7%9A%84MacOS-Terminal/final_effect_cli.webp" class="" title="terminal效果 200"> </div>
<span id="more"></span>

<h2 id="1-获取Jetbrain终端配色"><a href="#1-获取Jetbrain终端配色" class="headerlink" title="1. 获取Jetbrain终端配色"></a>1. 获取Jetbrain终端配色</h2><p>方便起见我使用<code>macos-terminal-themes</code>的脚本来一键输出终端配色方案</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:lysyi3m/macos-terminal-themes.git</span><br><span class="line"><span class="built_in">cd</span> macos-terminal-themes/tool</span><br><span class="line"><span class="built_in">chmod</span> +x preview.sh</span><br><span class="line">./preview.sh</span><br></pre></td></tr></table></figure>

<p>得到的输出如图</p>
<div style="width:50%;margin:auto"> <img src="/2022/07/27/%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAJetbrain%E9%A3%8E%E6%A0%BC%E7%9A%84MacOS-Terminal/jetbrain_color_schema.webp" class="" title="jetbrain原版效果 200"> </div>

<p>之后只需要抄色即可</p>
<h2 id="2-获取jetbrain-mono字体"><a href="#2-获取jetbrain-mono字体" class="headerlink" title="2. 获取jetbrain mono字体"></a>2. 获取jetbrain mono字体</h2><p>项目地址：<a href="https://github.com/JetBrains/JetBrainsMono">https://github.com/JetBrains/JetBrainsMono</a></p>
<p>可以使用homebrew安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap homebrew/cask-fonts</span><br><span class="line">brew install --cask font-jetbrains-mono</span><br></pre></td></tr></table></figure>

<h2 id="3-配置MacOS-Terminal"><a href="#3-配置MacOS-Terminal" class="headerlink" title="3. 配置MacOS Terminal"></a>3. 配置MacOS Terminal</h2><p>打开Terminal，点击屏幕右上角“终端”，“偏好设置“进行配置。</p>
<p>配置好的配置文件可以在此<a href="/2022/07/27/%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAJetbrain%E9%A3%8E%E6%A0%BC%E7%9A%84MacOS-Terminal/Jetbrain.terminal" title="下载">下载</a></p>
<p>得到的输出效果如图</p>
<div style="width:50%;margin:auto"> <img src="/2022/07/27/%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAJetbrain%E9%A3%8E%E6%A0%BC%E7%9A%84MacOS-Terminal/final_effect.webp" class="" title="terminal效果 200"> </div>

<div style="width:50%;margin:auto"> <img src="/2022/07/27/%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAJetbrain%E9%A3%8E%E6%A0%BC%E7%9A%84MacOS-Terminal/final_effect_cli.webp" class="" title="terminal效果 200"> </div>]]></content>
      <categories>
        <category>macos</category>
      </categories>
      <tags>
        <tag>terminal</tag>
        <tag>color schema</tag>
        <tag>jerbrain mono</tag>
      </tags>
  </entry>
  <entry>
    <title>链表相关题目</title>
    <url>/2021/05/03/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>链表类相关题目</p>
<span id="more"></span>

<h1 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/submissions/">https://leetcode-cn.com/problems/linked-list-cycle/submissions/</a></p>
<p>快慢指针法, 快指针一次2步，慢指针一次1步，如果指针之一发现nil尾节点，则返回无环。<br>如果指针重合，返回有环。</p>
<h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p>
<p>使用双指针，分别从a, b开始遍历，到达a的末尾后衔接b的头。b也同理。</p>
<p>注意完成跳转的轮次不能进行其他工作，否则会导致头节点被错过。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pointA == <span class="literal">nil</span> &#123;</span><br><span class="line">    pointA = headB</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pointA = pointA.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
